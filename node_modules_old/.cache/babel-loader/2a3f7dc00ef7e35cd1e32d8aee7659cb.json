{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"./events\");\n\nconst Is = require(\"./is\");\n\nlet DefaultSize = 8192;\nlet CR = Buffer.from('\\r', 'ascii')[0];\nlet LF = Buffer.from('\\n', 'ascii')[0];\nlet CRLF = '\\r\\n';\n\nclass MessageBuffer {\n  constructor(encoding = 'utf8') {\n    this.encoding = encoding;\n    this.index = 0;\n    this.buffer = Buffer.allocUnsafe(DefaultSize);\n  }\n\n  append(chunk) {\n    var toAppend = chunk;\n\n    if (typeof chunk === 'string') {\n      var str = chunk;\n      var bufferLen = Buffer.byteLength(str, this.encoding);\n      toAppend = Buffer.allocUnsafe(bufferLen);\n      toAppend.write(str, 0, bufferLen, this.encoding);\n    }\n\n    if (this.buffer.length - this.index >= toAppend.length) {\n      toAppend.copy(this.buffer, this.index, 0, toAppend.length);\n    } else {\n      var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\n\n      if (this.index === 0) {\n        this.buffer = Buffer.allocUnsafe(newSize);\n        toAppend.copy(this.buffer, 0, 0, toAppend.length);\n      } else {\n        this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\n      }\n    }\n\n    this.index += toAppend.length;\n  }\n\n  tryReadHeaders() {\n    let result = undefined;\n    let current = 0;\n\n    while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\n      current++;\n    } // No header / body separator found (e.g CRLFCRLF)\n\n\n    if (current + 3 >= this.index) {\n      return result;\n    }\n\n    result = Object.create(null);\n    let headers = this.buffer.toString('ascii', 0, current).split(CRLF);\n    headers.forEach(header => {\n      let index = header.indexOf(':');\n\n      if (index === -1) {\n        throw new Error('Message header must separate key and value using :');\n      }\n\n      let key = header.substr(0, index);\n      let value = header.substr(index + 1).trim();\n      result[key] = value;\n    });\n    let nextStart = current + 4;\n    this.buffer = this.buffer.slice(nextStart);\n    this.index = this.index - nextStart;\n    return result;\n  }\n\n  tryReadContent(length) {\n    if (this.index < length) {\n      return null;\n    }\n\n    let result = this.buffer.toString(this.encoding, 0, length);\n    let nextStart = length;\n    this.buffer.copy(this.buffer, 0, nextStart);\n    this.index = this.index - nextStart;\n    return result;\n  }\n\n  get numberOfBytes() {\n    return this.index;\n  }\n\n}\n\nvar MessageReader;\n\n(function (MessageReader) {\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n  }\n\n  MessageReader.is = is;\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\n\nclass AbstractMessageReader {\n  constructor() {\n    this.errorEmitter = new events_1.Emitter();\n    this.closeEmitter = new events_1.Emitter();\n    this.partialMessageEmitter = new events_1.Emitter();\n  }\n\n  dispose() {\n    this.errorEmitter.dispose();\n    this.closeEmitter.dispose();\n  }\n\n  get onError() {\n    return this.errorEmitter.event;\n  }\n\n  fireError(error) {\n    this.errorEmitter.fire(this.asError(error));\n  }\n\n  get onClose() {\n    return this.closeEmitter.event;\n  }\n\n  fireClose() {\n    this.closeEmitter.fire(undefined);\n  }\n\n  get onPartialMessage() {\n    return this.partialMessageEmitter.event;\n  }\n\n  firePartialMessage(info) {\n    this.partialMessageEmitter.fire(info);\n  }\n\n  asError(error) {\n    if (error instanceof Error) {\n      return error;\n    } else {\n      return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n    }\n  }\n\n}\n\nexports.AbstractMessageReader = AbstractMessageReader;\n\nclass StreamMessageReader extends AbstractMessageReader {\n  constructor(readable, encoding = 'utf8') {\n    super();\n    this.readable = readable;\n    this.buffer = new MessageBuffer(encoding);\n    this._partialMessageTimeout = 10000;\n  }\n\n  set partialMessageTimeout(timeout) {\n    this._partialMessageTimeout = timeout;\n  }\n\n  get partialMessageTimeout() {\n    return this._partialMessageTimeout;\n  }\n\n  listen(callback) {\n    this.nextMessageLength = -1;\n    this.messageToken = 0;\n    this.partialMessageTimer = undefined;\n    this.callback = callback;\n    this.readable.on('data', data => {\n      this.onData(data);\n    });\n    this.readable.on('error', error => this.fireError(error));\n    this.readable.on('close', () => this.fireClose());\n  }\n\n  onData(data) {\n    this.buffer.append(data);\n\n    while (true) {\n      if (this.nextMessageLength === -1) {\n        let headers = this.buffer.tryReadHeaders();\n\n        if (!headers) {\n          return;\n        }\n\n        let contentLength = headers['Content-Length'];\n\n        if (!contentLength) {\n          throw new Error('Header must provide a Content-Length property.');\n        }\n\n        let length = parseInt(contentLength);\n\n        if (isNaN(length)) {\n          throw new Error('Content-Length value must be a number.');\n        }\n\n        this.nextMessageLength = length; // Take the encoding form the header. For compatibility\n        // treat both utf-8 and utf8 as node utf8\n      }\n\n      var msg = this.buffer.tryReadContent(this.nextMessageLength);\n\n      if (msg === null) {\n        /** We haven't recevied the full message yet. */\n        this.setPartialMessageTimer();\n        return;\n      }\n\n      this.clearPartialMessageTimer();\n      this.nextMessageLength = -1;\n      this.messageToken++;\n      var json = JSON.parse(msg);\n      this.callback(json);\n    }\n  }\n\n  clearPartialMessageTimer() {\n    if (this.partialMessageTimer) {\n      clearTimeout(this.partialMessageTimer);\n      this.partialMessageTimer = undefined;\n    }\n  }\n\n  setPartialMessageTimer() {\n    this.clearPartialMessageTimer();\n\n    if (this._partialMessageTimeout <= 0) {\n      return;\n    }\n\n    this.partialMessageTimer = setTimeout((token, timeout) => {\n      this.partialMessageTimer = undefined;\n\n      if (token === this.messageToken) {\n        this.firePartialMessage({\n          messageToken: token,\n          waitingTime: timeout\n        });\n        this.setPartialMessageTimer();\n      }\n    }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n  }\n\n}\n\nexports.StreamMessageReader = StreamMessageReader;\n\nclass IPCMessageReader extends AbstractMessageReader {\n  constructor(process) {\n    super();\n    this.process = process;\n    let eventEmitter = this.process;\n    eventEmitter.on('error', error => this.fireError(error));\n    eventEmitter.on('close', () => this.fireClose());\n  }\n\n  listen(callback) {\n    this.process.on('message', callback);\n  }\n\n}\n\nexports.IPCMessageReader = IPCMessageReader;\n\nclass SocketMessageReader extends StreamMessageReader {\n  constructor(socket, encoding = 'utf-8') {\n    super(socket, encoding);\n  }\n\n}\n\nexports.SocketMessageReader = SocketMessageReader;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/vscode-jsonrpc/lib/messageReader.js"],"names":["Object","defineProperty","exports","value","events_1","require","Is","DefaultSize","CR","Buffer","from","LF","CRLF","MessageBuffer","constructor","encoding","index","buffer","allocUnsafe","append","chunk","toAppend","str","bufferLen","byteLength","write","length","copy","newSize","Math","ceil","concat","slice","tryReadHeaders","result","undefined","current","create","headers","toString","split","forEach","header","indexOf","Error","key","substr","trim","nextStart","tryReadContent","numberOfBytes","MessageReader","is","candidate","func","listen","dispose","onError","onClose","onPartialMessage","AbstractMessageReader","errorEmitter","Emitter","closeEmitter","partialMessageEmitter","event","fireError","error","fire","asError","fireClose","firePartialMessage","info","string","message","StreamMessageReader","readable","_partialMessageTimeout","partialMessageTimeout","timeout","callback","nextMessageLength","messageToken","partialMessageTimer","on","data","onData","contentLength","parseInt","isNaN","msg","setPartialMessageTimer","clearPartialMessageTimer","json","JSON","parse","clearTimeout","setTimeout","token","waitingTime","IPCMessageReader","process","eventEmitter","SocketMessageReader","socket"],"mappings":"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","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"./events\");\r\nconst Is = require(\"./is\");\r\nlet DefaultSize = 8192;\r\nlet CR = Buffer.from('\\r', 'ascii')[0];\r\nlet LF = Buffer.from('\\n', 'ascii')[0];\r\nlet CRLF = '\\r\\n';\r\nclass MessageBuffer {\r\n    constructor(encoding = 'utf8') {\r\n        this.encoding = encoding;\r\n        this.index = 0;\r\n        this.buffer = Buffer.allocUnsafe(DefaultSize);\r\n    }\r\n    append(chunk) {\r\n        var toAppend = chunk;\r\n        if (typeof (chunk) === 'string') {\r\n            var str = chunk;\r\n            var bufferLen = Buffer.byteLength(str, this.encoding);\r\n            toAppend = Buffer.allocUnsafe(bufferLen);\r\n            toAppend.write(str, 0, bufferLen, this.encoding);\r\n        }\r\n        if (this.buffer.length - this.index >= toAppend.length) {\r\n            toAppend.copy(this.buffer, this.index, 0, toAppend.length);\r\n        }\r\n        else {\r\n            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\r\n            if (this.index === 0) {\r\n                this.buffer = Buffer.allocUnsafe(newSize);\r\n                toAppend.copy(this.buffer, 0, 0, toAppend.length);\r\n            }\r\n            else {\r\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\r\n            }\r\n        }\r\n        this.index += toAppend.length;\r\n    }\r\n    tryReadHeaders() {\r\n        let result = undefined;\r\n        let current = 0;\r\n        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\r\n            current++;\r\n        }\r\n        // No header / body separator found (e.g CRLFCRLF)\r\n        if (current + 3 >= this.index) {\r\n            return result;\r\n        }\r\n        result = Object.create(null);\r\n        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);\r\n        headers.forEach((header) => {\r\n            let index = header.indexOf(':');\r\n            if (index === -1) {\r\n                throw new Error('Message header must separate key and value using :');\r\n            }\r\n            let key = header.substr(0, index);\r\n            let value = header.substr(index + 1).trim();\r\n            result[key] = value;\r\n        });\r\n        let nextStart = current + 4;\r\n        this.buffer = this.buffer.slice(nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    tryReadContent(length) {\r\n        if (this.index < length) {\r\n            return null;\r\n        }\r\n        let result = this.buffer.toString(this.encoding, 0, length);\r\n        let nextStart = length;\r\n        this.buffer.copy(this.buffer, 0, nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    get numberOfBytes() {\r\n        return this.index;\r\n    }\r\n}\r\nvar MessageReader;\r\n(function (MessageReader) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\r\n    }\r\n    MessageReader.is = is;\r\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\r\nclass AbstractMessageReader {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n        this.partialMessageEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error) {\r\n        this.errorEmitter.fire(this.asError(error));\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    get onPartialMessage() {\r\n        return this.partialMessageEmitter.event;\r\n    }\r\n    firePartialMessage(info) {\r\n        this.partialMessageEmitter.fire(info);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageReader = AbstractMessageReader;\r\nclass StreamMessageReader extends AbstractMessageReader {\r\n    constructor(readable, encoding = 'utf8') {\r\n        super();\r\n        this.readable = readable;\r\n        this.buffer = new MessageBuffer(encoding);\r\n        this._partialMessageTimeout = 10000;\r\n    }\r\n    set partialMessageTimeout(timeout) {\r\n        this._partialMessageTimeout = timeout;\r\n    }\r\n    get partialMessageTimeout() {\r\n        return this._partialMessageTimeout;\r\n    }\r\n    listen(callback) {\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.partialMessageTimer = undefined;\r\n        this.callback = callback;\r\n        this.readable.on('data', (data) => {\r\n            this.onData(data);\r\n        });\r\n        this.readable.on('error', (error) => this.fireError(error));\r\n        this.readable.on('close', () => this.fireClose());\r\n    }\r\n    onData(data) {\r\n        this.buffer.append(data);\r\n        while (true) {\r\n            if (this.nextMessageLength === -1) {\r\n                let headers = this.buffer.tryReadHeaders();\r\n                if (!headers) {\r\n                    return;\r\n                }\r\n                let contentLength = headers['Content-Length'];\r\n                if (!contentLength) {\r\n                    throw new Error('Header must provide a Content-Length property.');\r\n                }\r\n                let length = parseInt(contentLength);\r\n                if (isNaN(length)) {\r\n                    throw new Error('Content-Length value must be a number.');\r\n                }\r\n                this.nextMessageLength = length;\r\n                // Take the encoding form the header. For compatibility\r\n                // treat both utf-8 and utf8 as node utf8\r\n            }\r\n            var msg = this.buffer.tryReadContent(this.nextMessageLength);\r\n            if (msg === null) {\r\n                /** We haven't recevied the full message yet. */\r\n                this.setPartialMessageTimer();\r\n                return;\r\n            }\r\n            this.clearPartialMessageTimer();\r\n            this.nextMessageLength = -1;\r\n            this.messageToken++;\r\n            var json = JSON.parse(msg);\r\n            this.callback(json);\r\n        }\r\n    }\r\n    clearPartialMessageTimer() {\r\n        if (this.partialMessageTimer) {\r\n            clearTimeout(this.partialMessageTimer);\r\n            this.partialMessageTimer = undefined;\r\n        }\r\n    }\r\n    setPartialMessageTimer() {\r\n        this.clearPartialMessageTimer();\r\n        if (this._partialMessageTimeout <= 0) {\r\n            return;\r\n        }\r\n        this.partialMessageTimer = setTimeout((token, timeout) => {\r\n            this.partialMessageTimer = undefined;\r\n            if (token === this.messageToken) {\r\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\r\n                this.setPartialMessageTimer();\r\n            }\r\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\r\n    }\r\n}\r\nexports.StreamMessageReader = StreamMessageReader;\r\nclass IPCMessageReader extends AbstractMessageReader {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose());\r\n    }\r\n    listen(callback) {\r\n        this.process.on('message', callback);\r\n    }\r\n}\r\nexports.IPCMessageReader = IPCMessageReader;\r\nclass SocketMessageReader extends StreamMessageReader {\r\n    constructor(socket, encoding = 'utf-8') {\r\n        super(socket, encoding);\r\n    }\r\n}\r\nexports.SocketMessageReader = SocketMessageReader;\r\n"]},"metadata":{},"sourceType":"script"}