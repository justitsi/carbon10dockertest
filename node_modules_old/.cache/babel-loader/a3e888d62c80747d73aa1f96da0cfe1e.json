{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"./events\");\n\nconst Is = require(\"./is\");\n\nlet ContentLength = 'Content-Length: ';\nlet CRLF = '\\r\\n';\nvar MessageWriter;\n\n(function (MessageWriter) {\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);\n  }\n\n  MessageWriter.is = is;\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\n\nclass AbstractMessageWriter {\n  constructor() {\n    this.errorEmitter = new events_1.Emitter();\n    this.closeEmitter = new events_1.Emitter();\n  }\n\n  dispose() {\n    this.errorEmitter.dispose();\n    this.closeEmitter.dispose();\n  }\n\n  get onError() {\n    return this.errorEmitter.event;\n  }\n\n  fireError(error, message, count) {\n    this.errorEmitter.fire([this.asError(error), message, count]);\n  }\n\n  get onClose() {\n    return this.closeEmitter.event;\n  }\n\n  fireClose() {\n    this.closeEmitter.fire(undefined);\n  }\n\n  asError(error) {\n    if (error instanceof Error) {\n      return error;\n    } else {\n      return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n    }\n  }\n\n}\n\nexports.AbstractMessageWriter = AbstractMessageWriter;\n\nclass StreamMessageWriter extends AbstractMessageWriter {\n  constructor(writable, encoding = 'utf8') {\n    super();\n    this.writable = writable;\n    this.encoding = encoding;\n    this.errorCount = 0;\n    this.writable.on('error', error => this.fireError(error));\n    this.writable.on('close', () => this.fireClose());\n  }\n\n  write(msg) {\n    let json = JSON.stringify(msg);\n    let contentLength = Buffer.byteLength(json, this.encoding);\n    let headers = [ContentLength, contentLength.toString(), CRLF, CRLF];\n\n    try {\n      // Header must be written in ASCII encoding\n      this.writable.write(headers.join(''), 'ascii'); // Now write the content. This can be written in any encoding\n\n      this.writable.write(json, this.encoding);\n      this.errorCount = 0;\n    } catch (error) {\n      this.errorCount++;\n      this.fireError(error, msg, this.errorCount);\n    }\n  }\n\n}\n\nexports.StreamMessageWriter = StreamMessageWriter;\n\nclass IPCMessageWriter extends AbstractMessageWriter {\n  constructor(process) {\n    super();\n    this.process = process;\n    this.errorCount = 0;\n    this.queue = [];\n    this.sending = false;\n    let eventEmitter = this.process;\n    eventEmitter.on('error', error => this.fireError(error));\n    eventEmitter.on('close', () => this.fireClose);\n  }\n\n  write(msg) {\n    if (!this.sending && this.queue.length === 0) {\n      // See https://github.com/nodejs/node/issues/7657\n      this.doWriteMessage(msg);\n    } else {\n      this.queue.push(msg);\n    }\n  }\n\n  doWriteMessage(msg) {\n    try {\n      if (this.process.send) {\n        this.sending = true;\n        this.process.send(msg, undefined, undefined, error => {\n          this.sending = false;\n\n          if (error) {\n            this.errorCount++;\n            this.fireError(error, msg, this.errorCount);\n          } else {\n            this.errorCount = 0;\n          }\n\n          if (this.queue.length > 0) {\n            this.doWriteMessage(this.queue.shift());\n          }\n        });\n      }\n    } catch (error) {\n      this.errorCount++;\n      this.fireError(error, msg, this.errorCount);\n    }\n  }\n\n}\n\nexports.IPCMessageWriter = IPCMessageWriter;\n\nclass SocketMessageWriter extends AbstractMessageWriter {\n  constructor(socket, encoding = 'utf8') {\n    super();\n    this.socket = socket;\n    this.queue = [];\n    this.sending = false;\n    this.encoding = encoding;\n    this.errorCount = 0;\n    this.socket.on('error', error => this.fireError(error));\n    this.socket.on('close', () => this.fireClose());\n  }\n\n  write(msg) {\n    if (!this.sending && this.queue.length === 0) {\n      // See https://github.com/nodejs/node/issues/7657\n      this.doWriteMessage(msg);\n    } else {\n      this.queue.push(msg);\n    }\n  }\n\n  doWriteMessage(msg) {\n    let json = JSON.stringify(msg);\n    let contentLength = Buffer.byteLength(json, this.encoding);\n    let headers = [ContentLength, contentLength.toString(), CRLF, CRLF];\n\n    try {\n      // Header must be written in ASCII encoding\n      this.sending = true;\n      this.socket.write(headers.join(''), 'ascii', error => {\n        if (error) {\n          this.handleError(error, msg);\n        }\n\n        try {\n          // Now write the content. This can be written in any encoding\n          this.socket.write(json, this.encoding, error => {\n            this.sending = false;\n\n            if (error) {\n              this.handleError(error, msg);\n            } else {\n              this.errorCount = 0;\n            }\n\n            if (this.queue.length > 0) {\n              this.doWriteMessage(this.queue.shift());\n            }\n          });\n        } catch (error) {\n          this.handleError(error, msg);\n        }\n      });\n    } catch (error) {\n      this.handleError(error, msg);\n    }\n  }\n\n  handleError(error, msg) {\n    this.errorCount++;\n    this.fireError(error, msg, this.errorCount);\n  }\n\n}\n\nexports.SocketMessageWriter = SocketMessageWriter;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/vscode-jsonrpc/lib/messageWriter.js"],"names":["Object","defineProperty","exports","value","events_1","require","Is","ContentLength","CRLF","MessageWriter","is","candidate","func","dispose","onClose","onError","write","AbstractMessageWriter","constructor","errorEmitter","Emitter","closeEmitter","event","fireError","error","message","count","fire","asError","fireClose","undefined","Error","string","StreamMessageWriter","writable","encoding","errorCount","on","msg","json","JSON","stringify","contentLength","Buffer","byteLength","headers","toString","join","IPCMessageWriter","process","queue","sending","eventEmitter","length","doWriteMessage","push","send","shift","SocketMessageWriter","socket","handleError"],"mappings":"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","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"./events\");\r\nconst Is = require(\"./is\");\r\nlet ContentLength = 'Content-Length: ';\r\nlet CRLF = '\\r\\n';\r\nvar MessageWriter;\r\n(function (MessageWriter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.write);\r\n    }\r\n    MessageWriter.is = is;\r\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\r\nclass AbstractMessageWriter {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error, message, count) {\r\n        this.errorEmitter.fire([this.asError(error), message, count]);\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageWriter = AbstractMessageWriter;\r\nclass StreamMessageWriter extends AbstractMessageWriter {\r\n    constructor(writable, encoding = 'utf8') {\r\n        super();\r\n        this.writable = writable;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.writable.on('error', (error) => this.fireError(error));\r\n        this.writable.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.writable.write(headers.join(''), 'ascii');\r\n            // Now write the content. This can be written in any encoding\r\n            this.writable.write(json, this.encoding);\r\n            this.errorCount = 0;\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.StreamMessageWriter = StreamMessageWriter;\r\nclass IPCMessageWriter extends AbstractMessageWriter {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        this.errorCount = 0;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose);\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        try {\r\n            if (this.process.send) {\r\n                this.sending = true;\r\n                this.process.send(msg, undefined, undefined, (error) => {\r\n                    this.sending = false;\r\n                    if (error) {\r\n                        this.errorCount++;\r\n                        this.fireError(error, msg, this.errorCount);\r\n                    }\r\n                    else {\r\n                        this.errorCount = 0;\r\n                    }\r\n                    if (this.queue.length > 0) {\r\n                        this.doWriteMessage(this.queue.shift());\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.IPCMessageWriter = IPCMessageWriter;\r\nclass SocketMessageWriter extends AbstractMessageWriter {\r\n    constructor(socket, encoding = 'utf8') {\r\n        super();\r\n        this.socket = socket;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.socket.on('error', (error) => this.fireError(error));\r\n        this.socket.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.sending = true;\r\n            this.socket.write(headers.join(''), 'ascii', (error) => {\r\n                if (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n                try {\r\n                    // Now write the content. This can be written in any encoding\r\n                    this.socket.write(json, this.encoding, (error) => {\r\n                        this.sending = false;\r\n                        if (error) {\r\n                            this.handleError(error, msg);\r\n                        }\r\n                        else {\r\n                            this.errorCount = 0;\r\n                        }\r\n                        if (this.queue.length > 0) {\r\n                            this.doWriteMessage(this.queue.shift());\r\n                        }\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n            });\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n}\r\nexports.SocketMessageWriter = SocketMessageWriter;\r\n"]},"metadata":{},"sourceType":"script"}