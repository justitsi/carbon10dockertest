{"ast":null,"code":"\"use strict\";\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Touch;\n\n(function (Touch) {\n  Touch.None = 0;\n  Touch.First = 1;\n  Touch.Last = 2;\n})(Touch = exports.Touch || (exports.Touch = {}));\n\nclass LinkedMap {\n  constructor() {\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n  }\n\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    const item = this._map.get(key);\n\n    if (!item) {\n      return undefined;\n    }\n\n    return item.value;\n  }\n\n  set(key, value, touch = Touch.None) {\n    let item = this._map.get(key);\n\n    if (item) {\n      item.value = value;\n\n      if (touch !== Touch.None) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n\n      switch (touch) {\n        case Touch.None:\n          this.addItemLast(item);\n          break;\n\n        case Touch.First:\n          this.addItemFirst(item);\n          break;\n\n        case Touch.Last:\n          this.addItemLast(item);\n          break;\n\n        default:\n          this.addItemLast(item);\n          break;\n      }\n\n      this._map.set(key, item);\n\n      this._size++;\n    }\n  }\n\n  delete(key) {\n    const item = this._map.get(key);\n\n    if (!item) {\n      return false;\n    }\n\n    this._map.delete(key);\n\n    this.removeItem(item);\n    this._size--;\n    return true;\n  }\n\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    const item = this._head;\n\n    this._map.delete(item.key);\n\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n\n  forEach(callbackfn, thisArg) {\n    let current = this._head;\n\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n\n      current = current.next;\n    }\n  }\n\n  forEachReverse(callbackfn, thisArg) {\n    let current = this._tail;\n\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n\n      current = current.previous;\n    }\n  }\n\n  values() {\n    let result = [];\n    let current = this._head;\n\n    while (current) {\n      result.push(current.value);\n      current = current.next;\n    }\n\n    return result;\n  }\n\n  keys() {\n    let result = [];\n    let current = this._head;\n\n    while (current) {\n      result.push(current.key);\n      current = current.next;\n    }\n\n    return result;\n  }\n  /* JSON RPC run on es5 which has no Symbol.iterator\r\n  public keys(): IterableIterator<K> {\r\n      let current = this._head;\r\n      let iterator: IterableIterator<K> = {\r\n          [Symbol.iterator]() {\r\n              return iterator;\r\n          },\r\n          next():IteratorResult<K> {\r\n              if (current) {\r\n                  let result = { value: current.key, done: false };\r\n                  current = current.next;\r\n                  return result;\r\n              } else {\r\n                  return { value: undefined, done: true };\r\n              }\r\n          }\r\n      };\r\n      return iterator;\r\n  }\r\n    public values(): IterableIterator<V> {\r\n      let current = this._head;\r\n      let iterator: IterableIterator<V> = {\r\n          [Symbol.iterator]() {\r\n              return iterator;\r\n          },\r\n          next():IteratorResult<V> {\r\n              if (current) {\r\n                  let result = { value: current.value, done: false };\r\n                  current = current.next;\r\n                  return result;\r\n              } else {\r\n                  return { value: undefined, done: true };\r\n              }\r\n          }\r\n      };\r\n      return iterator;\r\n  }\r\n  */\n\n\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n\n    this._head = item;\n  }\n\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n\n    this._tail = item;\n  }\n\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      this._head = item.next;\n    } else if (item === this._tail) {\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n\n      next.previous = previous;\n      previous.next = next;\n    }\n  }\n\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n\n    if (touch !== Touch.First && touch !== Touch.Last) {\n      return;\n    }\n\n    if (touch === Touch.First) {\n      if (item === this._head) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item\n\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      } // Insert the node at head\n\n\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n    } else if (touch === Touch.Last) {\n      if (item === this._tail) {\n        return;\n      }\n\n      const next = item.next;\n      const previous = item.previous; // Unlink the item.\n\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n    }\n  }\n\n}\n\nexports.LinkedMap = LinkedMap;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/vscode-jsonrpc/lib/linkedMap.js"],"names":["Object","defineProperty","exports","value","Touch","None","First","Last","LinkedMap","constructor","_map","Map","_head","undefined","_tail","_size","clear","isEmpty","size","has","key","get","item","set","touch","next","previous","addItemLast","addItemFirst","delete","removeItem","shift","Error","forEach","callbackfn","thisArg","current","bind","forEachReverse","values","result","push","keys"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Touch;\r\n(function (Touch) {\r\n    Touch.None = 0;\r\n    Touch.First = 1;\r\n    Touch.Last = 2;\r\n})(Touch = exports.Touch || (exports.Touch = {}));\r\nclass LinkedMap {\r\n    constructor() {\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = Touch.None) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== Touch.None) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case Touch.None:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case Touch.First:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case Touch.Last:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n    }\r\n    delete(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return false;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return true;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    forEachReverse(callbackfn, thisArg) {\r\n        let current = this._tail;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.previous;\r\n        }\r\n    }\r\n    values() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.value);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    keys() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.key);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    /* JSON RPC run on es5 which has no Symbol.iterator\r\n    public keys(): IterableIterator<K> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<K> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<K> {\r\n                if (current) {\r\n                    let result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    public values(): IterableIterator<V> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<V> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<V> {\r\n                if (current) {\r\n                    let result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    */\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\r\n            return;\r\n        }\r\n        if (touch === Touch.First) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n        }\r\n        else if (touch === Touch.Last) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n        }\r\n    }\r\n}\r\nexports.LinkedMap = LinkedMap;\r\n"]},"metadata":{},"sourceType":"script"}