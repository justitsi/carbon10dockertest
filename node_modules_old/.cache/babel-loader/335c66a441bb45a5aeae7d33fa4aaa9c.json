{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\n\nrequire(\"apollo-server-env\");\n\nconst graphql_1 = require(\"graphql\");\n\nconst apollo_graphql_1 = require(\"apollo-graphql\");\n\nconst directives_1 = __importDefault(require(\"../directives\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst rules_1 = require(\"./rules\");\n\nconst EmptyQueryDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.query\n  },\n  fields: [],\n  serviceName: null\n};\nconst EmptyMutationDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.mutation\n  },\n  fields: [],\n  serviceName: null\n};\n\nfunction buildMapsFromServiceList(serviceList) {\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directiveDefinitionsMap = Object.create(null);\n  const typeToServiceMap = Object.create(null);\n  const externalFields = [];\n  const keyDirectivesMap = Object.create(null);\n  const valueTypes = new Set();\n\n  for (const {\n    typeDefs,\n    name: serviceName\n  } of serviceList) {\n    const {\n      typeDefsWithoutExternalFields,\n      strippedFields\n    } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n    externalFields.push(...strippedFields);\n    const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n\n    for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n      if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n        const typeName = definition.name.value;\n\n        for (const keyDirective of utils_1.findDirectivesOnTypeOrField(definition, 'key')) {\n          if (keyDirective.arguments && utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n            keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n            keyDirectivesMap[typeName][serviceName] = keyDirectivesMap[typeName][serviceName] || [];\n            keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n          }\n        }\n      }\n\n      if (graphql_1.isTypeDefinitionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (!typeToServiceMap[typeName]) {\n          typeToServiceMap[typeName] = {\n            extensionFieldsToOwningServiceMap: Object.create(null)\n          };\n        }\n\n        typeToServiceMap[typeName].owningService = serviceName;\n\n        if (typeDefinitionsMap[typeName]) {\n          const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n\n          if (isValueType) {\n            valueTypes.add(typeName);\n          }\n\n          typeDefinitionsMap[typeName].push(Object.assign(Object.assign({}, definition), {\n            serviceName\n          }));\n        } else {\n          typeDefinitionsMap[typeName] = [Object.assign(Object.assign({}, definition), {\n            serviceName\n          })];\n        }\n      } else if (graphql_1.isTypeExtensionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION || definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n          if (!definition.fields) break;\n          const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = Object.assign(Object.assign({}, typeToServiceMap[typeName].extensionFieldsToOwningServiceMap), fields);\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: fields\n            };\n          }\n        }\n\n        if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n          if (!definition.values) break;\n          const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = Object.assign(Object.assign({}, typeToServiceMap[typeName].extensionFieldsToOwningServiceMap), values);\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: values\n            };\n          }\n        }\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(Object.assign(Object.assign({}, definition), {\n            serviceName\n          }));\n        } else {\n          typeExtensionsMap[typeName] = [Object.assign(Object.assign({}, definition), {\n            serviceName\n          })];\n        }\n      } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n        const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n        if (executableLocations.length === 0) continue;\n        const definitionWithExecutableLocations = Object.assign(Object.assign({}, definition), {\n          locations: executableLocations\n        });\n\n        if (directiveDefinitionsMap[directiveName]) {\n          directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n        } else {\n          directiveDefinitionsMap[directiveName] = {\n            [serviceName]: definitionWithExecutableLocations\n          };\n        }\n      }\n    }\n  }\n\n  if (!typeDefinitionsMap.Query) typeDefinitionsMap.Query = [EmptyQueryDefinition];\n  if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation) typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n  return {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes\n  };\n}\n\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\n\nfunction buildSchemaFromDefinitionsAndExtensions({\n  typeDefinitionsMap,\n  typeExtensionsMap,\n  directiveDefinitionsMap\n}) {\n  let errors = undefined;\n  let schema = new graphql_1.GraphQLSchema({\n    query: undefined,\n    directives: [...graphql_1.specifiedDirectives, ...directives_1.default]\n  });\n  const definitionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...Object.values(typeDefinitionsMap).flat(), ...Object.values(directiveDefinitionsMap).map(definitions => Object.values(definitions)[0])]\n  };\n  errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n  schema = graphql_1.extendSchema(schema, definitionsDocument, {\n    assumeValidSDL: true\n  });\n  const extensionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: Object.values(typeExtensionsMap).flat()\n  };\n  errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n  schema = graphql_1.extendSchema(schema, extensionsDocument, {\n    assumeValidSDL: true\n  });\n  schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign({}, schema.toConfig()), {\n    directives: [...schema.getDirectives().filter(x => !utils_1.isFederationDirective(x))]\n  }));\n  return {\n    schema,\n    errors\n  };\n}\n\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\n\nfunction addFederationMetadataToSchemaNodes({\n  schema,\n  typeToServiceMap,\n  externalFields,\n  keyDirectivesMap,\n  valueTypes,\n  directiveDefinitionsMap\n}) {\n  var _a;\n\n  for (const [typeName, {\n    owningService,\n    extensionFieldsToOwningServiceMap\n  }] of Object.entries(typeToServiceMap)) {\n    const namedType = schema.getType(typeName);\n    if (!namedType) continue;\n    const isValueType = valueTypes.has(typeName);\n    const serviceName = isValueType ? null : owningService;\n    const federationMetadata = Object.assign(Object.assign(Object.assign({}, utils_1.getFederationMetadata(namedType)), {\n      serviceName,\n      isValueType\n    }), keyDirectivesMap[typeName] && {\n      keys: keyDirectivesMap[typeName]\n    });\n    namedType.extensions = Object.assign(Object.assign({}, namedType.extensions), {\n      federation: federationMetadata\n    });\n\n    if (graphql_1.isObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        const [providesDirective] = utils_1.findDirectivesOnTypeOrField(field.astNode, 'provides');\n\n        if (providesDirective && providesDirective.arguments && utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n          const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), {\n            serviceName,\n            provides: utils_1.parseSelections(providesDirective.arguments[0].value.value),\n            belongsToValueType: isValueType\n          });\n          field.extensions = Object.assign(Object.assign({}, field.extensions), {\n            federation: fieldFederationMetadata\n          });\n        }\n      }\n    }\n\n    for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n      if (graphql_1.isObjectType(namedType)) {\n        const field = namedType.getFields()[fieldName];\n        const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), {\n          serviceName: extendingServiceName\n        });\n        field.extensions = Object.assign(Object.assign({}, field.extensions), {\n          federation: fieldFederationMetadata\n        });\n        const [requiresDirective] = utils_1.findDirectivesOnTypeOrField(field.astNode, 'requires');\n\n        if (requiresDirective && requiresDirective.arguments && utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n          const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), {\n            requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value)\n          });\n          field.extensions = Object.assign(Object.assign({}, field.extensions), {\n            federation: fieldFederationMetadata\n          });\n        }\n      }\n    }\n  }\n\n  for (const field of externalFields) {\n    const namedType = schema.getType(field.parentTypeName);\n    if (!namedType) continue;\n    const existingMetadata = utils_1.getFederationMetadata(namedType);\n    const typeFederationMetadata = Object.assign(Object.assign({}, existingMetadata), {\n      externals: Object.assign(Object.assign({}, existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals), {\n        [field.serviceName]: [...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []), field]\n      })\n    });\n    namedType.extensions = Object.assign(Object.assign({}, namedType.extensions), {\n      federation: typeFederationMetadata\n    });\n  }\n\n  for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n    const directive = schema.getDirective(directiveName);\n    if (!directive) continue;\n    const directiveFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(directive)), {\n      directiveDefinitions: directiveDefinitionsMap[directiveName]\n    });\n    directive.extensions = Object.assign(Object.assign({}, directive.extensions), {\n      federation: directiveFederationMetadata\n    });\n  }\n}\n\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\n\nfunction composeServices(services) {\n  const {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes\n  } = buildMapsFromServiceList(services);\n  let {\n    schema,\n    errors\n  } = buildSchemaFromDefinitionsAndExtensions({\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap\n  });\n  schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign({}, schema.toConfig()), utils_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName ? schema.getType(typeName) : undefined)));\n  schema = apollo_graphql_1.transformSchema(schema, type => {\n    if (graphql_1.isObjectType(type)) {\n      const config = type.toConfig();\n      return new graphql_1.GraphQLObjectType(Object.assign(Object.assign({}, config), {\n        interfaces: Array.from(new Set(config.interfaces))\n      }));\n    }\n\n    return undefined;\n  });\n  addFederationMetadataToSchemaNodes({\n    schema,\n    typeToServiceMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    directiveDefinitionsMap\n  });\n  return {\n    schema,\n    errors\n  };\n}\n\nexports.composeServices = composeServices;","map":{"version":3,"sources":["../../src/composition/compose.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\nrequire(\"apollo-server-env\");\nconst graphql_1 = require(\"graphql\");\nconst apollo_graphql_1 = require(\"apollo-graphql\");\nconst directives_1 = __importDefault(require(\"../directives\"));\nconst utils_1 = require(\"./utils\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst rules_1 = require(\"./rules\");\nconst EmptyQueryDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.query },\n    fields: [],\n    serviceName: null,\n};\nconst EmptyMutationDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.mutation },\n    fields: [],\n    serviceName: null,\n};\nfunction buildMapsFromServiceList(serviceList) {\n    const typeDefinitionsMap = Object.create(null);\n    const typeExtensionsMap = Object.create(null);\n    const directiveDefinitionsMap = Object.create(null);\n    const typeToServiceMap = Object.create(null);\n    const externalFields = [];\n    const keyDirectivesMap = Object.create(null);\n    const valueTypes = new Set();\n    for (const { typeDefs, name: serviceName } of serviceList) {\n        const { typeDefsWithoutExternalFields, strippedFields, } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n        externalFields.push(...strippedFields);\n        const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n        for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n            if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION ||\n                definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n                const typeName = definition.name.value;\n                for (const keyDirective of utils_1.findDirectivesOnTypeOrField(definition, 'key')) {\n                    if (keyDirective.arguments &&\n                        utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n                        keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n                        keyDirectivesMap[typeName][serviceName] =\n                            keyDirectivesMap[typeName][serviceName] || [];\n                        keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n                    }\n                }\n            }\n            if (graphql_1.isTypeDefinitionNode(definition)) {\n                const typeName = definition.name.value;\n                if (!typeToServiceMap[typeName]) {\n                    typeToServiceMap[typeName] = {\n                        extensionFieldsToOwningServiceMap: Object.create(null),\n                    };\n                }\n                typeToServiceMap[typeName].owningService = serviceName;\n                if (typeDefinitionsMap[typeName]) {\n                    const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n                    if (isValueType) {\n                        valueTypes.add(typeName);\n                    }\n                    typeDefinitionsMap[typeName].push(Object.assign(Object.assign({}, definition), { serviceName }));\n                }\n                else {\n                    typeDefinitionsMap[typeName] = [Object.assign(Object.assign({}, definition), { serviceName })];\n                }\n            }\n            else if (graphql_1.isTypeExtensionNode(definition)) {\n                const typeName = definition.name.value;\n                if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ||\n                    definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n                    if (!definition.fields)\n                        break;\n                    const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = Object.assign(Object.assign({}, typeToServiceMap[typeName].extensionFieldsToOwningServiceMap), fields);\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: fields,\n                        };\n                    }\n                }\n                if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n                    if (!definition.values)\n                        break;\n                    const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = Object.assign(Object.assign({}, typeToServiceMap[typeName].extensionFieldsToOwningServiceMap), values);\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: values,\n                        };\n                    }\n                }\n                if (typeExtensionsMap[typeName]) {\n                    typeExtensionsMap[typeName].push(Object.assign(Object.assign({}, definition), { serviceName }));\n                }\n                else {\n                    typeExtensionsMap[typeName] = [Object.assign(Object.assign({}, definition), { serviceName })];\n                }\n            }\n            else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n                const directiveName = definition.name.value;\n                const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n                if (executableLocations.length === 0)\n                    continue;\n                const definitionWithExecutableLocations = Object.assign(Object.assign({}, definition), { locations: executableLocations });\n                if (directiveDefinitionsMap[directiveName]) {\n                    directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n                }\n                else {\n                    directiveDefinitionsMap[directiveName] = {\n                        [serviceName]: definitionWithExecutableLocations,\n                    };\n                }\n            }\n        }\n    }\n    if (!typeDefinitionsMap.Query)\n        typeDefinitionsMap.Query = [EmptyQueryDefinition];\n    if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation)\n        typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n    return {\n        typeToServiceMap,\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n    };\n}\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\nfunction buildSchemaFromDefinitionsAndExtensions({ typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, }) {\n    let errors = undefined;\n    let schema = new graphql_1.GraphQLSchema({\n        query: undefined,\n        directives: [...graphql_1.specifiedDirectives, ...directives_1.default],\n    });\n    const definitionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [\n            ...Object.values(typeDefinitionsMap).flat(),\n            ...Object.values(directiveDefinitionsMap).map(definitions => Object.values(definitions)[0]),\n        ],\n    };\n    errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n    schema = graphql_1.extendSchema(schema, definitionsDocument, { assumeValidSDL: true });\n    const extensionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: Object.values(typeExtensionsMap).flat(),\n    };\n    errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n    schema = graphql_1.extendSchema(schema, extensionsDocument, { assumeValidSDL: true });\n    schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign({}, schema.toConfig()), { directives: [\n            ...schema.getDirectives().filter(x => !utils_1.isFederationDirective(x)),\n        ] }));\n    return { schema, errors };\n}\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\nfunction addFederationMetadataToSchemaNodes({ schema, typeToServiceMap, externalFields, keyDirectivesMap, valueTypes, directiveDefinitionsMap, }) {\n    var _a;\n    for (const [typeName, { owningService, extensionFieldsToOwningServiceMap },] of Object.entries(typeToServiceMap)) {\n        const namedType = schema.getType(typeName);\n        if (!namedType)\n            continue;\n        const isValueType = valueTypes.has(typeName);\n        const serviceName = isValueType ? null : owningService;\n        const federationMetadata = Object.assign(Object.assign(Object.assign({}, utils_1.getFederationMetadata(namedType)), { serviceName,\n            isValueType }), (keyDirectivesMap[typeName] && {\n            keys: keyDirectivesMap[typeName],\n        }));\n        namedType.extensions = Object.assign(Object.assign({}, namedType.extensions), { federation: federationMetadata });\n        if (graphql_1.isObjectType(namedType)) {\n            for (const field of Object.values(namedType.getFields())) {\n                const [providesDirective] = utils_1.findDirectivesOnTypeOrField(field.astNode, 'provides');\n                if (providesDirective &&\n                    providesDirective.arguments &&\n                    utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), { serviceName, provides: utils_1.parseSelections(providesDirective.arguments[0].value.value), belongsToValueType: isValueType });\n                    field.extensions = Object.assign(Object.assign({}, field.extensions), { federation: fieldFederationMetadata });\n                }\n            }\n        }\n        for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n            if (graphql_1.isObjectType(namedType)) {\n                const field = namedType.getFields()[fieldName];\n                const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), { serviceName: extendingServiceName });\n                field.extensions = Object.assign(Object.assign({}, field.extensions), { federation: fieldFederationMetadata });\n                const [requiresDirective] = utils_1.findDirectivesOnTypeOrField(field.astNode, 'requires');\n                if (requiresDirective &&\n                    requiresDirective.arguments &&\n                    utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(field)), { requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value) });\n                    field.extensions = Object.assign(Object.assign({}, field.extensions), { federation: fieldFederationMetadata });\n                }\n            }\n        }\n    }\n    for (const field of externalFields) {\n        const namedType = schema.getType(field.parentTypeName);\n        if (!namedType)\n            continue;\n        const existingMetadata = utils_1.getFederationMetadata(namedType);\n        const typeFederationMetadata = Object.assign(Object.assign({}, existingMetadata), { externals: Object.assign(Object.assign({}, existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals), { [field.serviceName]: [\n                    ...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []),\n                    field,\n                ] }) });\n        namedType.extensions = Object.assign(Object.assign({}, namedType.extensions), { federation: typeFederationMetadata });\n    }\n    for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n        const directive = schema.getDirective(directiveName);\n        if (!directive)\n            continue;\n        const directiveFederationMetadata = Object.assign(Object.assign({}, utils_1.getFederationMetadata(directive)), { directiveDefinitions: directiveDefinitionsMap[directiveName] });\n        directive.extensions = Object.assign(Object.assign({}, directive.extensions), { federation: directiveFederationMetadata });\n    }\n}\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\nfunction composeServices(services) {\n    const { typeToServiceMap, typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, externalFields, keyDirectivesMap, valueTypes, } = buildMapsFromServiceList(services);\n    let { schema, errors } = buildSchemaFromDefinitionsAndExtensions({\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n    });\n    schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign({}, schema.toConfig()), utils_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName\n        ? schema.getType(typeName)\n        : undefined)));\n    schema = apollo_graphql_1.transformSchema(schema, type => {\n        if (graphql_1.isObjectType(type)) {\n            const config = type.toConfig();\n            return new graphql_1.GraphQLObjectType(Object.assign(Object.assign({}, config), { interfaces: Array.from(new Set(config.interfaces)) }));\n        }\n        return undefined;\n    });\n    addFederationMetadataToSchemaNodes({\n        schema,\n        typeToServiceMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n        directiveDefinitionsMap,\n    });\n    return { schema, errors };\n}\nexports.composeServices = composeServices;\n//# sourceMappingURL=compose.js.map"]},"metadata":{},"sourceType":"script"}