{"ast":null,"code":"\"use strict\"; // Dependencies\n\nvar protocols = require(\"protocols\"),\n    isSsh = require(\"is-ssh\"),\n    qs = require(\"querystring\");\n/**\n * parsePath\n * Parses the input url.\n *\n * @name parsePath\n * @function\n * @param {String} url The input url.\n * @return {Object} An object containing the following fields:\n *\n *  - `protocols` (Array): An array with the url protocols (usually it has one element).\n *  - `protocol` (String): The first protocol, `\"ssh\"` (if the url is a ssh url) or `\"file\"`.\n *  - `port` (null|Number): The domain port.\n *  - `resource` (String): The url domain (including subdomains).\n *  - `user` (String): The authentication user (usually for ssh urls).\n *  - `pathname` (String): The url pathname.\n *  - `hash` (String): The url hash.\n *  - `search` (String): The url querystring value.\n *  - `href` (String): The input url.\n *  - `query` (Object): The url querystring, parsed as object.\n */\n\n\nfunction parsePath(url) {\n  url = (url || \"\").trim();\n  var output = {\n    protocols: protocols(url),\n    protocol: null,\n    port: null,\n    resource: \"\",\n    user: \"\",\n    pathname: \"\",\n    hash: \"\",\n    search: \"\",\n    href: url,\n    query: Object.create(null)\n  },\n      protocolIndex = url.indexOf(\"://\"),\n      resourceIndex = -1,\n      splits = null,\n      parts = null;\n\n  if (url.startsWith(\".\")) {\n    if (url.startsWith(\"./\")) {\n      url = url.substring(2);\n    }\n\n    output.pathname = url;\n    output.protocol = \"file\";\n  }\n\n  var firstChar = url.charAt(1);\n\n  if (!output.protocol) {\n    output.protocol = output.protocols[0];\n\n    if (!output.protocol) {\n      if (isSsh(url)) {\n        output.protocol = \"ssh\";\n      } else if (firstChar === \"/\" || firstChar === \"~\") {\n        url = url.substring(2);\n        output.protocol = \"file\";\n      } else {\n        output.protocol = \"file\";\n      }\n    }\n  }\n\n  if (protocolIndex !== -1) {\n    url = url.substring(protocolIndex + 3);\n  }\n\n  parts = url.split(\"/\");\n\n  if (output.protocol !== \"file\") {\n    output.resource = parts.shift();\n  } else {\n    output.resource = \"\";\n  } // user@domain\n\n\n  splits = output.resource.split(\"@\");\n\n  if (splits.length === 2) {\n    output.user = splits[0];\n    output.resource = splits[1];\n  } // domain.com:port\n\n\n  splits = output.resource.split(\":\");\n\n  if (splits.length === 2) {\n    output.resource = splits[0];\n\n    if (splits[1]) {\n      output.port = Number(splits[1]);\n\n      if (isNaN(output.port)) {\n        output.port = null;\n        parts.unshift(splits[1]);\n      }\n    } else {\n      output.port = null;\n    }\n  } // Remove empty elements\n\n\n  parts = parts.filter(Boolean); // Stringify the pathname\n\n  if (output.protocol === \"file\") {\n    output.pathname = output.href;\n  } else {\n    output.pathname = output.pathname || (output.protocol !== \"file\" || output.href[0] === \"/\" ? \"/\" : \"\") + parts.join(\"/\");\n  } // #some-hash\n\n\n  splits = output.pathname.split(\"#\");\n\n  if (splits.length === 2) {\n    output.pathname = splits[0];\n    output.hash = splits[1];\n  } // ?foo=bar\n\n\n  splits = output.pathname.split(\"?\");\n\n  if (splits.length === 2) {\n    output.pathname = splits[0];\n    output.search = splits[1];\n  }\n\n  output.query = qs.parse(output.search);\n  output.href = output.href.replace(/\\/$/, \"\");\n  output.pathname = output.pathname.replace(/\\/$/, \"\");\n  return output;\n}\n\nmodule.exports = parsePath;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/parse-path/lib/index.js"],"names":["protocols","require","isSsh","qs","parsePath","url","trim","output","protocol","port","resource","user","pathname","hash","search","href","query","Object","create","protocolIndex","indexOf","resourceIndex","splits","parts","startsWith","substring","firstChar","charAt","split","shift","length","Number","isNaN","unshift","filter","Boolean","join","parse","replace","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Dependencies\nvar protocols = require(\"protocols\"),\n    isSsh = require(\"is-ssh\"),\n    qs = require(\"querystring\");\n\n/**\n * parsePath\n * Parses the input url.\n *\n * @name parsePath\n * @function\n * @param {String} url The input url.\n * @return {Object} An object containing the following fields:\n *\n *  - `protocols` (Array): An array with the url protocols (usually it has one element).\n *  - `protocol` (String): The first protocol, `\"ssh\"` (if the url is a ssh url) or `\"file\"`.\n *  - `port` (null|Number): The domain port.\n *  - `resource` (String): The url domain (including subdomains).\n *  - `user` (String): The authentication user (usually for ssh urls).\n *  - `pathname` (String): The url pathname.\n *  - `hash` (String): The url hash.\n *  - `search` (String): The url querystring value.\n *  - `href` (String): The input url.\n *  - `query` (Object): The url querystring, parsed as object.\n */\nfunction parsePath(url) {\n    url = (url || \"\").trim();\n    var output = {\n        protocols: protocols(url),\n        protocol: null,\n        port: null,\n        resource: \"\",\n        user: \"\",\n        pathname: \"\",\n        hash: \"\",\n        search: \"\",\n        href: url,\n        query: Object.create(null)\n    },\n        protocolIndex = url.indexOf(\"://\"),\n        resourceIndex = -1,\n        splits = null,\n        parts = null;\n\n    if (url.startsWith(\".\")) {\n        if (url.startsWith(\"./\")) {\n            url = url.substring(2);\n        }\n        output.pathname = url;\n        output.protocol = \"file\";\n    }\n\n    var firstChar = url.charAt(1);\n    if (!output.protocol) {\n        output.protocol = output.protocols[0];\n        if (!output.protocol) {\n            if (isSsh(url)) {\n                output.protocol = \"ssh\";\n            } else if (firstChar === \"/\" || firstChar === \"~\") {\n                url = url.substring(2);\n                output.protocol = \"file\";\n            } else {\n                output.protocol = \"file\";\n            }\n        }\n    }\n\n    if (protocolIndex !== -1) {\n        url = url.substring(protocolIndex + 3);\n    }\n\n    parts = url.split(\"/\");\n    if (output.protocol !== \"file\") {\n        output.resource = parts.shift();\n    } else {\n        output.resource = \"\";\n    }\n\n    // user@domain\n    splits = output.resource.split(\"@\");\n    if (splits.length === 2) {\n        output.user = splits[0];\n        output.resource = splits[1];\n    }\n\n    // domain.com:port\n    splits = output.resource.split(\":\");\n    if (splits.length === 2) {\n        output.resource = splits[0];\n        if (splits[1]) {\n            output.port = Number(splits[1]);\n            if (isNaN(output.port)) {\n                output.port = null;\n                parts.unshift(splits[1]);\n            }\n        } else {\n            output.port = null;\n        }\n    }\n\n    // Remove empty elements\n    parts = parts.filter(Boolean);\n\n    // Stringify the pathname\n    if (output.protocol === \"file\") {\n        output.pathname = output.href;\n    } else {\n        output.pathname = output.pathname || (output.protocol !== \"file\" || output.href[0] === \"/\" ? \"/\" : \"\") + parts.join(\"/\");\n    }\n\n    // #some-hash\n    splits = output.pathname.split(\"#\");\n    if (splits.length === 2) {\n        output.pathname = splits[0];\n        output.hash = splits[1];\n    }\n\n    // ?foo=bar\n    splits = output.pathname.split(\"?\");\n    if (splits.length === 2) {\n        output.pathname = splits[0];\n        output.search = splits[1];\n    }\n\n    output.query = qs.parse(output.search);\n    output.href = output.href.replace(/\\/$/, \"\");\n    output.pathname = output.pathname.replace(/\\/$/, \"\");\n    return output;\n}\n\nmodule.exports = parsePath;"]},"metadata":{},"sourceType":"script"}