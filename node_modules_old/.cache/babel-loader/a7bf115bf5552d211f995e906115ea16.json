{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueUnionTypes = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst lodash_xorby_1 = __importDefault(require(\"lodash.xorby\"));\n\nconst utils_1 = require(\"../../utils\");\n\nconst uniqueTypeNamesWithFields_1 = require(\"./uniqueTypeNamesWithFields\");\n\nfunction UniqueUnionTypes(context) {\n  const knownTypes = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    UnionTypeDefinition: validateUnionTypes\n  };\n\n  function validateUnionTypes(node) {\n    const typeName = node.name.value;\n    const typeFromSchema = schema && schema.getType(typeName);\n    const typeNodeFromSchema = typeFromSchema && typeFromSchema.astNode;\n    const typeNodeFromDefs = knownTypes[typeName];\n    const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n\n    if (duplicateTypeNode) {\n      const unionDiff = lodash_xorby_1.default(node.types, duplicateTypeNode.types, 'name.value');\n      const diffLength = unionDiff.length;\n\n      if (diffLength > 0) {\n        context.reportError(utils_1.errorWithCode('VALUE_TYPE_UNION_TYPES_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}The union \\`${typeName}\\` is defined in services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`, however their types do not match. Union types with the same name must also consist of identical types. The type${diffLength > 1 ? 's' : ''} ${unionDiff.map(diffEntry => diffEntry.name.value).join(', ')} ${diffLength > 1 ? 'are' : 'is'} mismatched.`, [node, duplicateTypeNode]));\n      }\n\n      return false;\n    }\n\n    if (typeFromSchema) {\n      context.reportError(new graphql_1.GraphQLError(uniqueTypeNamesWithFields_1.existedTypeNameMessage(typeName), node.name));\n      return;\n    }\n\n    if (knownTypes[typeName]) {\n      context.reportError(new graphql_1.GraphQLError(uniqueTypeNamesWithFields_1.duplicateTypeNameMessage(typeName), [knownTypes[typeName], node.name]));\n    } else {\n      knownTypes[typeName] = node;\n    }\n\n    return false;\n  }\n}\n\nexports.UniqueUnionTypes = UniqueUnionTypes;","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/matchingUnions.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,2BAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;AAUA,SAAgB,gBAAhB,CAAiC,OAAjC,EAA8D;AAC5D,QAAM,UAAU,GAEZ,MAAM,CAAC,MAAP,CAAc,IAAd,CAFJ;AAGA,QAAM,MAAM,GAAG,OAAO,CAAC,SAAR,EAAf;AAEA,SAAO;AACL,IAAA,mBAAmB,EAAE;AADhB,GAAP;;AAIA,WAAS,kBAAT,CAA4B,IAA5B,EAAyD;AACvD,UAAM,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,KAA3B;AACA,UAAM,cAAc,GAAG,MAAM,IAAI,MAAM,CAAC,OAAP,CAAe,QAAf,CAAjC;AACA,UAAM,kBAAkB,GACtB,cAAc,IACb,cAAc,CAAC,OAFlB;AAIA,UAAM,gBAAgB,GAAG,UAAU,CAAC,QAAD,CAAnC;AACA,UAAM,iBAAiB,GAAG,kBAAkB,IAAI,gBAAhD;;AAGA,QAAI,iBAAJ,EAAuB;AACrB,YAAM,SAAS,GAAG,cAAA,CAAA,OAAA,CAChB,IAAI,CAAC,KADW,EAEhB,iBAAiB,CAAC,KAFF,EAGhB,YAHgB,CAAlB;AAMA,YAAM,UAAU,GAAG,SAAS,CAAC,MAA7B;;AACA,UAAI,UAAU,GAAG,CAAjB,EAAoB;AAClB,QAAA,OAAO,CAAC,WAAR,CACE,OAAA,CAAA,aAAA,CACE,iCADF,EAEE,GAAG,OAAA,CAAA,iBAAA,CACD,iBAAiB,CAAC,WADjB,EAED,QAFC,CAGF,eAAe,QAAQ,+BACtB,iBAAiB,CAAC,WACpB,YACE,IAAI,CAAC,WACP,sHACE,UAAU,GAAG,CAAb,GAAiB,GAAjB,GAAuB,EACzB,IAAI,SAAS,CAAC,GAAV,CAAc,SAAS,IAAI,SAAS,CAAC,IAAV,CAAe,KAA1C,EAAiD,IAAjD,CAAsD,IAAtD,CAA2D,IAC7D,UAAU,GAAG,CAAb,GAAiB,KAAjB,GAAyB,IAC3B,cAbF,EAcE,CAAC,IAAD,EAAO,iBAAP,CAdF,CADF;AAkBD;;AAED,aAAO,KAAP;AACD;;AAED,QAAI,cAAJ,EAAoB;AAClB,MAAA,OAAO,CAAC,WAAR,CACE,IAAI,SAAA,CAAA,YAAJ,CAAiB,2BAAA,CAAA,sBAAA,CAAuB,QAAvB,CAAjB,EAAmD,IAAI,CAAC,IAAxD,CADF;AAGA;AACD;;AAED,QAAI,UAAU,CAAC,QAAD,CAAd,EAA0B;AACxB,MAAA,OAAO,CAAC,WAAR,CACE,IAAI,SAAA,CAAA,YAAJ,CAAiB,2BAAA,CAAA,wBAAA,CAAyB,QAAzB,CAAjB,EAAqD,CACnD,UAAU,CAAC,QAAD,CADyC,EAEnD,IAAI,CAAC,IAF8C,CAArD,CADF;AAMD,KAPD,MAOO;AACL,MAAA,UAAU,CAAC,QAAD,CAAV,GAAuB,IAAvB;AACD;;AAED,WAAO,KAAP;AACD;AACF;;AAzED,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueUnionTypes = void 0;\nconst graphql_1 = require(\"graphql\");\nconst lodash_xorby_1 = __importDefault(require(\"lodash.xorby\"));\nconst utils_1 = require(\"../../utils\");\nconst uniqueTypeNamesWithFields_1 = require(\"./uniqueTypeNamesWithFields\");\nfunction UniqueUnionTypes(context) {\n    const knownTypes = Object.create(null);\n    const schema = context.getSchema();\n    return {\n        UnionTypeDefinition: validateUnionTypes,\n    };\n    function validateUnionTypes(node) {\n        const typeName = node.name.value;\n        const typeFromSchema = schema && schema.getType(typeName);\n        const typeNodeFromSchema = typeFromSchema &&\n            typeFromSchema.astNode;\n        const typeNodeFromDefs = knownTypes[typeName];\n        const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n        if (duplicateTypeNode) {\n            const unionDiff = lodash_xorby_1.default(node.types, duplicateTypeNode.types, 'name.value');\n            const diffLength = unionDiff.length;\n            if (diffLength > 0) {\n                context.reportError(utils_1.errorWithCode('VALUE_TYPE_UNION_TYPES_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}The union \\`${typeName}\\` is defined in services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`, however their types do not match. Union types with the same name must also consist of identical types. The type${diffLength > 1 ? 's' : ''} ${unionDiff.map(diffEntry => diffEntry.name.value).join(', ')} ${diffLength > 1 ? 'are' : 'is'} mismatched.`, [node, duplicateTypeNode]));\n            }\n            return false;\n        }\n        if (typeFromSchema) {\n            context.reportError(new graphql_1.GraphQLError(uniqueTypeNamesWithFields_1.existedTypeNameMessage(typeName), node.name));\n            return;\n        }\n        if (knownTypes[typeName]) {\n            context.reportError(new graphql_1.GraphQLError(uniqueTypeNamesWithFields_1.duplicateTypeNameMessage(typeName), [\n                knownTypes[typeName],\n                node.name,\n            ]));\n        }\n        else {\n            knownTypes[typeName] = node;\n        }\n        return false;\n    }\n}\nexports.UniqueUnionTypes = UniqueUnionTypes;\n//# sourceMappingURL=matchingUnions.js.map"]},"metadata":{},"sourceType":"script"}