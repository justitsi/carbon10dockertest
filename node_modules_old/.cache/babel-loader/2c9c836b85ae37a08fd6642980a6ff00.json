{"ast":null,"code":"// Ignore warning about 'new String()'\n\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\n\nvar fs = require('fs');\n\nvar glob = require('glob');\n\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell); // objectAssign(target_obj, source_obj1 [, source_obj2 ...])\n// \"Ponyfill\" for Object.assign\n//    objectAssign({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}\n\nvar objectAssign = typeof Object.assign === 'function' ? Object.assign : function objectAssign(target) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    Object.keys(source).forEach(function (key) {\n      target[key] = source[key];\n    });\n  });\n  return target;\n};\nexports.extend = objectAssign; // Check if we're running under electron\n\nvar isElectron = Boolean(process.versions.electron); // Module globals (assume no execPath by default)\n\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null\n};\nvar config = {\n  reset: function () {\n    objectAssign(this, DEFAULT_CONFIG);\n\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  }\n};\nconfig.reset();\nexports.config = config;\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js',\n  tempDir: null\n};\nexports.state = state;\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\nvar platform = os.type().match(/^Win/) ? 'win' : 'unix';\nexports.platform = platform; // This is populated by calls to commonl.wrap()\n\nvar pipeMethods = []; // Reliably test if something is any sort of javascript object\n\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\n\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\n\nexports.log = log; // Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\n\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n\n  return msg.replace(/\\\\/g, '/');\n}\n\nexports.convertErrorOutput = convertErrorOutput; // Shows error message. Throws if config.fatal is true\n\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) {\n    // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') {\n    // no 'options'\n    options = {\n      code: _code\n    };\n  } else if (typeof _code !== 'number') {\n    // only 'msg'\n    options = {};\n  }\n\n  options = objectAssign({}, DEFAULT_OPTIONS, options);\n  if (!state.errorCode) state.errorCode = options.code;\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry; // Throw an error, or log the entry\n\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: new ShellString('', state.error, state.errorCode)\n    };\n  }\n}\n\nexports.error = error; //@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`\n\nfunction ShellString(stdout, stderr, code) {\n  var that;\n\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n\n  that.stderr = stderr;\n  that.code = code; // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString; // Return the home directory in a platform-agnostic way, with consideration for\n// older versions of node\n\nfunction getUserHome() {\n  var result;\n\n  if (os.homedir) {\n    result = os.homedir(); // node 3+\n  } else {\n    result = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];\n  }\n\n  return result;\n}\n\nexports.getUserHome = getUserHome; // Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  } // All options are false by default\n\n\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      error(\"Options string must start with a '-'\", errorOptions || {});\n    } // e.g. chars = ['R', 'f']\n\n\n    var chars = opt.slice(1).split('');\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else {\n    // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n\n  return options;\n}\n\nexports.parseOptions = parseOptions; // Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\n\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret = glob.sync(listEl, config.globOptions); // if glob fails, interpret the string literally\n\n      expanded = expanded.concat(ret.length > 0 ? ret : [listEl]);\n    }\n  });\n  return expanded;\n}\n\nexports.expand = expand; // Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\n\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\n\nexports.unlinkSync = unlinkSync; // e.g. 'shelljs_a5f185d0443ca...'\n\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n\n    var hash = '';\n\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\n\nexports.randomFileName = randomFileName; // Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\n\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n\n  if (options.canReceivePipe) {\n    pipeMethods.push(cmd);\n  }\n\n  return function () {\n    var retValue = null;\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0); // Log the command to stderr, if appropriate\n\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      } // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n\n\n      state.pipedValue = this && typeof this.stdout === 'string' ? this.stdout : '';\n\n      if (options.unix === false) {\n        // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else {\n        // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {// a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        } // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n\n\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n\n          accum.push(cur);\n          return accum;\n        }, []); // Convert ShellStrings (basically just String objects) to regular strings\n\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n\n          return arg;\n        }); // Expand the '~' if appropriate\n\n        var homeDir = getUserHome();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n\n          return arg;\n        }); // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        console.error('ShellJS: internal error');\n        console.error(e.stack || e);\n        process.exit(1);\n      }\n\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput && (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\n\n\nexports.wrap = wrap; // This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\n\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\n\nexports.readFromPipe = _readFromPipe;\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: false,\n  globStart: 1,\n  pipeOnly: false,\n  unix: true,\n  wrapOutput: true,\n  overWrite: false\n}; // Register a new ShellJS command\n\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {}; // If an option isn't specified, use the default\n\n  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name] && !wrapOptions.overWrite) {\n    throw new Error('unable to overwrite `' + name + '` command');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n}\n\nexports.register = _register;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/shelljs/src/common.js"],"names":["os","require","fs","glob","shell","shellMethods","Object","create","objectAssign","assign","target","sources","slice","call","arguments","forEach","source","keys","key","exports","extend","isElectron","Boolean","process","versions","electron","DEFAULT_CONFIG","fatal","globOptions","maxdepth","noglob","silent","verbose","execPath","config","reset","resetForTesting","state","error","errorCode","currentCmd","tempDir","env","OLDPWD","platform","type","match","pipeMethods","isObject","a","log","console","apply","convertErrorOutput","msg","TypeError","replace","_code","options","Error","DEFAULT_OPTIONS","continue","code","prefix","logEntry","length","retValue","ShellString","stdout","stderr","that","Array","join","String","cmd","bind","getUserHome","result","homedir","parseOptions","opt","map","errorOptions","letter","optName","chars","split","c","optionName","expand","list","isArray","expanded","listEl","push","ret","sync","concat","unlinkSync","file","e","chmodSync","randomFileName","randomHash","count","parseInt","Math","random","toString","hash","i","wrap","fn","canReceivePipe","args","pipedValue","unix","constructor","name","unshift","reduce","accum","cur","arg","homeDir","allowGlobbing","globStart","cmdOptions","stack","exit","wrapOutput","_readFromPipe","readFromPipe","DEFAULT_WRAP_OPTIONS","pipeOnly","overWrite","_register","implementation","wrapOptions","register"],"mappings":"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","sourcesContent":["// Ignore warning about 'new String()'\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\nvar fs = require('fs');\nvar glob = require('glob');\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\n\n// objectAssign(target_obj, source_obj1 [, source_obj2 ...])\n// \"Ponyfill\" for Object.assign\n//    objectAssign({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}\nvar objectAssign = typeof Object.assign === 'function' ?\n  Object.assign :\n  function objectAssign(target) {\n    var sources = [].slice.call(arguments, 1);\n    sources.forEach(function (source) {\n      Object.keys(source).forEach(function (key) {\n        target[key] = source[key];\n      });\n    });\n\n    return target;\n  };\nexports.extend = objectAssign;\n\n// Check if we're running under electron\nvar isElectron = Boolean(process.versions.electron);\n\n// Module globals (assume no execPath by default)\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n};\n\nvar config = {\n  reset: function () {\n    objectAssign(this, DEFAULT_CONFIG);\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  },\n};\n\nconfig.reset();\nexports.config = config;\n\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js',\n  tempDir: null,\n};\nexports.state = state;\n\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\nvar platform = os.type().match(/^Win/) ? 'win' : 'unix';\nexports.platform = platform;\n\n// This is populated by calls to commonl.wrap()\nvar pipeMethods = [];\n\n// Reliably test if something is any sort of javascript object\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\nexports.log = log;\n\n// Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  return msg.replace(/\\\\/g, '/');\n}\nexports.convertErrorOutput = convertErrorOutput;\n\n// Shows error message. Throws if config.fatal is true\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false,\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) { // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') { // no 'options'\n    options = { code: _code };\n  } else if (typeof _code !== 'number') { // only 'msg'\n    options = {};\n  }\n  options = objectAssign({}, DEFAULT_OPTIONS, options);\n\n  if (!state.errorCode) state.errorCode = options.code;\n\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry;\n\n  // Throw an error, or log the entry\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: (new ShellString('', state.error, state.errorCode)),\n    };\n  }\n}\nexports.error = error;\n\n//@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`\nfunction ShellString(stdout, stderr, code) {\n  var that;\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n  that.stderr = stderr;\n  that.code = code;\n  // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString;\n\n// Return the home directory in a platform-agnostic way, with consideration for\n// older versions of node\nfunction getUserHome() {\n  var result;\n  if (os.homedir) {\n    result = os.homedir(); // node 3+\n  } else {\n    result = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  }\n  return result;\n}\nexports.getUserHome = getUserHome;\n\n// Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  // All options are false by default\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      error(\"Options string must start with a '-'\", errorOptions || {});\n    }\n\n    // e.g. chars = ['R', 'f']\n    var chars = opt.slice(1).split('');\n\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else { // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret = glob.sync(listEl, config.globOptions);\n      // if glob fails, interpret the string literally\n      expanded = expanded.concat(ret.length > 0 ? ret : [listEl]);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n    var hash = '';\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  if (options.canReceivePipe) {\n    pipeMethods.push(cmd);\n  }\n  return function () {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      // Log the command to stderr, if appropriate\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      }\n\n      // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n      state.pipedValue = (this && typeof this.stdout === 'string') ? this.stdout : '';\n\n      if (options.unix === false) { // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else { // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {\n          // a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        }\n\n        // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n          accum.push(cur);\n          return accum;\n        }, []);\n\n        // Convert ShellStrings (basically just String objects) to regular strings\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n          return arg;\n        });\n\n        // Expand the '~' if appropriate\n        var homeDir = getUserHome();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n          return arg;\n        });\n\n        // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        console.error('ShellJS: internal error');\n        console.error(e.stack || e);\n        process.exit(1);\n      }\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput &&\n        (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n\n// This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\nexports.readFromPipe = _readFromPipe;\n\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: false,\n  globStart: 1,\n  pipeOnly: false,\n  unix: true,\n  wrapOutput: true,\n  overWrite: false,\n};\n\n// Register a new ShellJS command\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {};\n  // If an option isn't specified, use the default\n  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name] && !wrapOptions.overWrite) {\n    throw new Error('unable to overwrite `' + name + '` command');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n}\nexports.register = _register;\n"]},"metadata":{},"sourceType":"script"}