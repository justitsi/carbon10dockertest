{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar common = require('./common');\n\nvar glob = require('glob');\n\nvar globPatternRecursive = path.sep + '**';\ncommon.register('ls', _ls, {\n  cmdOptions: {\n    'R': 'recursive',\n    'A': 'all',\n    'L': 'link',\n    'a': 'all_deprecated',\n    'd': 'directory',\n    'l': 'long'\n  }\n}); //@\n//@ ### ls([options,] [path, ...])\n//@ ### ls([options,] path_array)\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@ + `-L`: follow symlinks\n//@ + `-d`: list directories themselves, not their contents\n//@ + `-l`: list objects representing each file, each with fields containing `ls\n//@         -l` output fields. See\n//@         [fs.Stats](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n//@         for more info\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ls('-l', 'file.txt'); // { name: 'file.txt', mode: 33188, nlink: 1, ...}\n//@ ```\n//@\n//@ Returns array of files in the given path, or in current directory if no path provided.\n\nfunction _ls(options, paths) {\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths) {\n    paths = ['.'];\n  } else {\n    paths = [].slice.call(arguments, 1);\n  }\n\n  var list = [];\n\n  function pushFile(abs, relName, stat) {\n    if (process.platform === 'win32') {\n      relName = relName.replace(/\\\\/g, '/');\n    }\n\n    if (options.long) {\n      stat = stat || (options.link ? fs.statSync(abs) : fs.lstatSync(abs));\n      list.push(addLsAttributes(relName, stat));\n    } else {\n      // list.push(path.relative(rel || '.', file));\n      list.push(relName);\n    }\n  }\n\n  paths.forEach(function (p) {\n    var stat;\n\n    try {\n      stat = options.link ? fs.statSync(p) : fs.lstatSync(p);\n    } catch (e) {\n      common.error('no such file or directory: ' + p, 2, {\n        continue: true\n      });\n      return;\n    } // If the stat succeeded\n\n\n    if (stat.isDirectory() && !options.directory) {\n      if (options.recursive) {\n        // use glob, because it's simple\n        glob.sync(p + globPatternRecursive, {\n          dot: options.all,\n          follow: options.link\n        }).forEach(function (item) {\n          // Glob pattern returns the directory itself and needs to be filtered out.\n          if (path.relative(p, item)) {\n            pushFile(item, path.relative(p, item));\n          }\n        });\n      } else if (options.all) {\n        // use fs.readdirSync, because it's fast\n        fs.readdirSync(p).forEach(function (item) {\n          pushFile(path.join(p, item), item);\n        });\n      } else {\n        // use fs.readdirSync and then filter out secret files\n        fs.readdirSync(p).forEach(function (item) {\n          if (item[0] !== '.') {\n            pushFile(path.join(p, item), item);\n          }\n        });\n      }\n    } else {\n      pushFile(p, p, stat);\n    }\n  }); // Add methods, to make this more compatible with ShellStrings\n\n  return list;\n}\n\nfunction addLsAttributes(pathName, stats) {\n  // Note: this object will contain more information than .toString() returns\n  stats.name = pathName;\n\n  stats.toString = function () {\n    // Return a string resembling unix's `ls -l` format\n    return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(' ');\n  };\n\n  return stats;\n}\n\nmodule.exports = _ls;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/shelljs/src/ls.js"],"names":["path","require","fs","common","glob","globPatternRecursive","sep","register","_ls","cmdOptions","options","paths","all_deprecated","log","all","slice","call","arguments","list","pushFile","abs","relName","stat","process","platform","replace","long","link","statSync","lstatSync","push","addLsAttributes","forEach","p","e","error","continue","isDirectory","directory","recursive","sync","dot","follow","item","relative","readdirSync","join","pathName","stats","name","toString","mode","nlink","uid","gid","size","mtime","module","exports"],"mappings":"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","sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar common = require('./common');\nvar glob = require('glob');\n\nvar globPatternRecursive = path.sep + '**';\n\ncommon.register('ls', _ls, {\n  cmdOptions: {\n    'R': 'recursive',\n    'A': 'all',\n    'L': 'link',\n    'a': 'all_deprecated',\n    'd': 'directory',\n    'l': 'long',\n  },\n});\n\n//@\n//@ ### ls([options,] [path, ...])\n//@ ### ls([options,] path_array)\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@ + `-L`: follow symlinks\n//@ + `-d`: list directories themselves, not their contents\n//@ + `-l`: list objects representing each file, each with fields containing `ls\n//@         -l` output fields. See\n//@         [fs.Stats](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n//@         for more info\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ls('-l', 'file.txt'); // { name: 'file.txt', mode: 33188, nlink: 1, ...}\n//@ ```\n//@\n//@ Returns array of files in the given path, or in current directory if no path provided.\nfunction _ls(options, paths) {\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths) {\n    paths = ['.'];\n  } else {\n    paths = [].slice.call(arguments, 1);\n  }\n\n  var list = [];\n\n  function pushFile(abs, relName, stat) {\n    if (process.platform === 'win32') {\n      relName = relName.replace(/\\\\/g, '/');\n    }\n    if (options.long) {\n      stat = stat || (options.link ? fs.statSync(abs) : fs.lstatSync(abs));\n      list.push(addLsAttributes(relName, stat));\n    } else {\n      // list.push(path.relative(rel || '.', file));\n      list.push(relName);\n    }\n  }\n\n  paths.forEach(function (p) {\n    var stat;\n\n    try {\n      stat = options.link ? fs.statSync(p) : fs.lstatSync(p);\n    } catch (e) {\n      common.error('no such file or directory: ' + p, 2, { continue: true });\n      return;\n    }\n\n    // If the stat succeeded\n    if (stat.isDirectory() && !options.directory) {\n      if (options.recursive) {\n        // use glob, because it's simple\n        glob.sync(p + globPatternRecursive, { dot: options.all, follow: options.link })\n          .forEach(function (item) {\n            // Glob pattern returns the directory itself and needs to be filtered out.\n            if (path.relative(p, item)) {\n              pushFile(item, path.relative(p, item));\n            }\n          });\n      } else if (options.all) {\n        // use fs.readdirSync, because it's fast\n        fs.readdirSync(p).forEach(function (item) {\n          pushFile(path.join(p, item), item);\n        });\n      } else {\n        // use fs.readdirSync and then filter out secret files\n        fs.readdirSync(p).forEach(function (item) {\n          if (item[0] !== '.') {\n            pushFile(path.join(p, item), item);\n          }\n        });\n      }\n    } else {\n      pushFile(p, p, stat);\n    }\n  });\n\n  // Add methods, to make this more compatible with ShellStrings\n  return list;\n}\n\nfunction addLsAttributes(pathName, stats) {\n  // Note: this object will contain more information than .toString() returns\n  stats.name = pathName;\n  stats.toString = function () {\n    // Return a string resembling unix's `ls -l` format\n    return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(' ');\n  };\n  return stats;\n}\n\nmodule.exports = _ls;\n"]},"metadata":{},"sourceType":"script"}