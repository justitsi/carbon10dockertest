{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.externalUnused = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nexports.externalUnused = ({\n  schema\n}) => {\n  const errors = [];\n  const types = schema.getTypeMap();\n\n  for (const [parentTypeName, parentType] of Object.entries(types)) {\n    if (!graphql_1.isObjectType(parentType)) continue;\n    const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n\n    if (typeFederationMetadata === null || typeFederationMetadata === void 0 ? void 0 : typeFederationMetadata.externals) {\n      for (const [serviceName, externalFieldsForService] of Object.entries(typeFederationMetadata.externals)) {\n        for (const {\n          field: externalField\n        } of externalFieldsForService) {\n          const externalFieldName = externalField.name.value;\n          const hasMatchingKeyOnType = Boolean(utils_1.hasMatchingFieldInDirectives({\n            directives: utils_1.findDirectivesOnTypeOrField(parentType.astNode, 'key'),\n            fieldNameToMatch: externalFieldName,\n            namedType: parentType\n          }));\n          if (hasMatchingKeyOnType) continue;\n          const hasMatchingProvidesOnAnotherType = utils_1.findFieldsThatReturnType({\n            schema,\n            typeToFind: parentType\n          }).some(field => utils_1.findDirectivesOnTypeOrField(field.astNode, 'provides').some(directive => {\n            if (!directive.arguments) return false;\n            const selections = utils_1.isStringValueNode(directive.arguments[0].value) && utils_1.parseSelections(directive.arguments[0].value.value);\n            return selections && selections.some(selection => selection.kind === graphql_1.Kind.FIELD && selection.name.value === externalFieldName);\n          }));\n          if (hasMatchingProvidesOnAnotherType) continue;\n          const hasMatchingRequiresOnAnotherType = Object.values(schema.getTypeMap()).some(namedType => {\n            if (!graphql_1.isObjectType(namedType)) return false;\n            return Object.values(namedType.getFields()).some(field => utils_1.findDirectivesOnTypeOrField(field.astNode, 'requires').some(directive => {\n              if (!directive.arguments) return false;\n              const selections = utils_1.isStringValueNode(directive.arguments[0].value) && utils_1.parseSelections(directive.arguments[0].value.value);\n              if (!selections) return false;\n              return utils_1.selectionIncludesField({\n                selections,\n                selectionSetType: namedType,\n                typeToFind: parentType,\n                fieldToFind: externalFieldName\n              });\n            }));\n          });\n          if (hasMatchingRequiresOnAnotherType) continue;\n          const hasMatchingRequiresOnType = Object.values(parentType.getFields()).some(maybeRequiresField => {\n            var _a;\n\n            const fieldOwner = (_a = utils_1.getFederationMetadata(maybeRequiresField)) === null || _a === void 0 ? void 0 : _a.serviceName;\n            if (fieldOwner !== serviceName) return false;\n            const requiresDirectives = utils_1.findDirectivesOnTypeOrField(maybeRequiresField.astNode, 'requires');\n            return utils_1.hasMatchingFieldInDirectives({\n              directives: requiresDirectives,\n              fieldNameToMatch: externalFieldName,\n              namedType: parentType\n            });\n          });\n          if (hasMatchingRequiresOnType) continue;\n          const fieldsOnInterfacesImplementedByParentType = new Set();\n\n          for (const _interface of parentType.getInterfaces()) {\n            for (const fieldName in _interface.getFields()) {\n              fieldsOnInterfacesImplementedByParentType.add(fieldName);\n            }\n          }\n\n          if (fieldsOnInterfacesImplementedByParentType.has(externalFieldName)) {\n            continue;\n          }\n\n          errors.push(utils_1.errorWithCode('EXTERNAL_UNUSED', utils_1.logServiceAndType(serviceName, parentTypeName, externalFieldName) + `is marked as @external but is not used by a @requires, @key, or @provides directive.`));\n        }\n      }\n    }\n  }\n\n  return errors;\n};","map":{"version":3,"sources":["../../../../src/composition/validate/postComposition/externalUnused.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAiBa,OAAA,CAAA,cAAA,GAA2C,CAAC;AAAE,EAAA;AAAF,CAAD,KAAe;AACrE,QAAM,MAAM,GAAmB,EAA/B;AACA,QAAM,KAAK,GAAG,MAAM,CAAC,UAAP,EAAd;;AACA,OAAK,MAAM,CAAC,cAAD,EAAiB,UAAjB,CAAX,IAA2C,MAAM,CAAC,OAAP,CAAe,KAAf,CAA3C,EAAkE;AAEhE,QAAI,CAAC,SAAA,CAAA,YAAA,CAAa,UAAb,CAAL,EAA+B;AAG/B,UAAM,sBAAsB,GAAG,OAAA,CAAA,qBAAA,CAAsB,UAAtB,CAA/B;;AACA,QAAI,sBAAsB,KAAA,IAAtB,IAAA,sBAAsB,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAA,sBAAsB,CAAE,SAA5B,EAAuC;AAErC,WAAK,MAAM,CAAC,WAAD,EAAc,wBAAd,CAAX,IAAsD,MAAM,CAAC,OAAP,CACpD,sBAAsB,CAAC,SAD6B,CAAtD,EAEG;AAED,aAAK,MAAM;AAAE,UAAA,KAAK,EAAE;AAAT,SAAX,IAAuC,wBAAvC,EAAiE;AAC/D,gBAAM,iBAAiB,GAAG,aAAa,CAAC,IAAd,CAAmB,KAA7C;AAGA,gBAAM,oBAAoB,GAAG,OAAO,CAClC,OAAA,CAAA,4BAAA,CAA6B;AAC3B,YAAA,UAAU,EAAE,OAAA,CAAA,2BAAA,CACV,UAAU,CAAC,OADD,EAEV,KAFU,CADe;AAK3B,YAAA,gBAAgB,EAAE,iBALS;AAM3B,YAAA,SAAS,EAAE;AANgB,WAA7B,CADkC,CAApC;AAUA,cAAI,oBAAJ,EAA0B;AAmB1B,gBAAM,gCAAgC,GAAG,OAAA,CAAA,wBAAA,CAAyB;AAChE,YAAA,MADgE;AAEhE,YAAA,UAAU,EAAE;AAFoD,WAAzB,EAGtC,IAHsC,CAGjC,KAAK,IACX,OAAA,CAAA,2BAAA,CAA4B,KAAK,CAAC,OAAlC,EAA2C,UAA3C,EAAuD,IAAvD,CACE,SAAS,IAAG;AACV,gBAAI,CAAC,SAAS,CAAC,SAAf,EAA0B,OAAO,KAAP;AAC1B,kBAAM,UAAU,GACd,OAAA,CAAA,iBAAA,CAAkB,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,KAAzC,KACA,OAAA,CAAA,eAAA,CAAgB,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,KAAvB,CAA6B,KAA7C,CAFF;AAKA,mBACE,UAAU,IACV,UAAU,CAAC,IAAX,CACE,SAAS,IACP,SAAS,CAAC,IAAV,KAAmB,SAAA,CAAA,IAAA,CAAK,KAAxB,IACA,SAAS,CAAC,IAAV,CAAe,KAAf,KAAyB,iBAH7B,CAFF;AAQD,WAhBH,CAJuC,CAAzC;AAwBA,cAAI,gCAAJ,EAAsC;AAwBtC,gBAAM,gCAAgC,GAAG,MAAM,CAAC,MAAP,CACvC,MAAM,CAAC,UAAP,EADuC,EAEvC,IAFuC,CAElC,SAAS,IAAG;AACjB,gBAAI,CAAC,SAAA,CAAA,YAAA,CAAa,SAAb,CAAL,EAA8B,OAAO,KAAP;AAG9B,mBAAO,MAAM,CAAC,MAAP,CAAc,SAAS,CAAC,SAAV,EAAd,EAAqC,IAArC,CAA0C,KAAK,IACpD,OAAA,CAAA,2BAAA,CAA4B,KAAK,CAAC,OAAlC,EAA2C,UAA3C,EAAuD,IAAvD,CACE,SAAS,IAAG;AACV,kBAAI,CAAC,SAAS,CAAC,SAAf,EAA0B,OAAO,KAAP;AAC1B,oBAAM,UAAU,GACd,OAAA,CAAA,iBAAA,CAAkB,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,KAAzC,KACA,OAAA,CAAA,eAAA,CAAgB,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,KAAvB,CAA6B,KAA7C,CAFF;AAIA,kBAAI,CAAC,UAAL,EAAiB,OAAO,KAAP;AACjB,qBAAO,OAAA,CAAA,sBAAA,CAAuB;AAC5B,gBAAA,UAD4B;AAE5B,gBAAA,gBAAgB,EAAE,SAFU;AAG5B,gBAAA,UAAU,EAAE,UAHgB;AAI5B,gBAAA,WAAW,EAAE;AAJe,eAAvB,CAAP;AAMD,aAdH,CADK,CAAP;AAkBD,WAxBwC,CAAzC;AA0BA,cAAI,gCAAJ,EAAsC;AAEtC,gBAAM,yBAAyB,GAAG,MAAM,CAAC,MAAP,CAChC,UAAU,CAAC,SAAX,EADgC,EAEhC,IAFgC,CAE3B,kBAAkB,IAAG;;;AAC1B,kBAAM,UAAU,GAAA,CAAA,EAAA,GAAG,OAAA,CAAA,qBAAA,CAAsB,kBAAtB,CAAH,MAA4C,IAA5C,IAA4C,EAAA,KAAA,KAAA,CAA5C,GAA4C,KAAA,CAA5C,GAA4C,EAAA,CAAE,WAA9D;AACA,gBAAI,UAAU,KAAK,WAAnB,EAAgC,OAAO,KAAP;AAEhC,kBAAM,kBAAkB,GAAG,OAAA,CAAA,2BAAA,CACzB,kBAAkB,CAAC,OADM,EAEzB,UAFyB,CAA3B;AAKA,mBAAO,OAAA,CAAA,4BAAA,CAA6B;AAClC,cAAA,UAAU,EAAE,kBADsB;AAElC,cAAA,gBAAgB,EAAE,iBAFgB;AAGlC,cAAA,SAAS,EAAE;AAHuB,aAA7B,CAAP;AAKD,WAhBiC,CAAlC;AAkBA,cAAI,yBAAJ,EAA+B;AAoC/B,gBAAM,yCAAyC,GAAgB,IAAI,GAAJ,EAA/D;;AAGA,eAAK,MAAM,UAAX,IAAyB,UAAU,CAAC,aAAX,EAAzB,EAAqD;AAEnD,iBAAK,MAAM,SAAX,IAAwB,UAAU,CAAC,SAAX,EAAxB,EAAgD;AAC9C,cAAA,yCAAyC,CAAC,GAA1C,CAA8C,SAA9C;AACD;AACF;;AAGD,cAAI,yCAAyC,CAAC,GAA1C,CAA8C,iBAA9C,CAAJ,EAAsE;AACpE;AACD;;AAED,UAAA,MAAM,CAAC,IAAP,CACE,OAAA,CAAA,aAAA,CACE,iBADF,EAEE,OAAA,CAAA,iBAAA,CACE,WADF,EAEE,cAFF,EAGE,iBAHF,IAKE,sFAPJ,CADF;AAWD;AACF;AACF;AACF;;AAED,SAAO,MAAP;AACD,CAlNY","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.externalUnused = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nexports.externalUnused = ({ schema }) => {\n    const errors = [];\n    const types = schema.getTypeMap();\n    for (const [parentTypeName, parentType] of Object.entries(types)) {\n        if (!graphql_1.isObjectType(parentType))\n            continue;\n        const typeFederationMetadata = utils_1.getFederationMetadata(parentType);\n        if (typeFederationMetadata === null || typeFederationMetadata === void 0 ? void 0 : typeFederationMetadata.externals) {\n            for (const [serviceName, externalFieldsForService] of Object.entries(typeFederationMetadata.externals)) {\n                for (const { field: externalField } of externalFieldsForService) {\n                    const externalFieldName = externalField.name.value;\n                    const hasMatchingKeyOnType = Boolean(utils_1.hasMatchingFieldInDirectives({\n                        directives: utils_1.findDirectivesOnTypeOrField(parentType.astNode, 'key'),\n                        fieldNameToMatch: externalFieldName,\n                        namedType: parentType,\n                    }));\n                    if (hasMatchingKeyOnType)\n                        continue;\n                    const hasMatchingProvidesOnAnotherType = utils_1.findFieldsThatReturnType({\n                        schema,\n                        typeToFind: parentType,\n                    }).some(field => utils_1.findDirectivesOnTypeOrField(field.astNode, 'provides').some(directive => {\n                        if (!directive.arguments)\n                            return false;\n                        const selections = utils_1.isStringValueNode(directive.arguments[0].value) &&\n                            utils_1.parseSelections(directive.arguments[0].value.value);\n                        return (selections &&\n                            selections.some(selection => selection.kind === graphql_1.Kind.FIELD &&\n                                selection.name.value === externalFieldName));\n                    }));\n                    if (hasMatchingProvidesOnAnotherType)\n                        continue;\n                    const hasMatchingRequiresOnAnotherType = Object.values(schema.getTypeMap()).some(namedType => {\n                        if (!graphql_1.isObjectType(namedType))\n                            return false;\n                        return Object.values(namedType.getFields()).some(field => utils_1.findDirectivesOnTypeOrField(field.astNode, 'requires').some(directive => {\n                            if (!directive.arguments)\n                                return false;\n                            const selections = utils_1.isStringValueNode(directive.arguments[0].value) &&\n                                utils_1.parseSelections(directive.arguments[0].value.value);\n                            if (!selections)\n                                return false;\n                            return utils_1.selectionIncludesField({\n                                selections,\n                                selectionSetType: namedType,\n                                typeToFind: parentType,\n                                fieldToFind: externalFieldName,\n                            });\n                        }));\n                    });\n                    if (hasMatchingRequiresOnAnotherType)\n                        continue;\n                    const hasMatchingRequiresOnType = Object.values(parentType.getFields()).some(maybeRequiresField => {\n                        var _a;\n                        const fieldOwner = (_a = utils_1.getFederationMetadata(maybeRequiresField)) === null || _a === void 0 ? void 0 : _a.serviceName;\n                        if (fieldOwner !== serviceName)\n                            return false;\n                        const requiresDirectives = utils_1.findDirectivesOnTypeOrField(maybeRequiresField.astNode, 'requires');\n                        return utils_1.hasMatchingFieldInDirectives({\n                            directives: requiresDirectives,\n                            fieldNameToMatch: externalFieldName,\n                            namedType: parentType,\n                        });\n                    });\n                    if (hasMatchingRequiresOnType)\n                        continue;\n                    const fieldsOnInterfacesImplementedByParentType = new Set();\n                    for (const _interface of parentType.getInterfaces()) {\n                        for (const fieldName in _interface.getFields()) {\n                            fieldsOnInterfacesImplementedByParentType.add(fieldName);\n                        }\n                    }\n                    if (fieldsOnInterfacesImplementedByParentType.has(externalFieldName)) {\n                        continue;\n                    }\n                    errors.push(utils_1.errorWithCode('EXTERNAL_UNUSED', utils_1.logServiceAndType(serviceName, parentTypeName, externalFieldName) +\n                        `is marked as @external but is not used by a @requires, @key, or @provides directive.`));\n                }\n            }\n        }\n    }\n    return errors;\n};\n//# sourceMappingURL=externalUnused.js.map"]},"metadata":{},"sourceType":"script"}