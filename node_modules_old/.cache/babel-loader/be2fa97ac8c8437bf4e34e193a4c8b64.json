{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseRules = exports.LexRules = exports.isIgnored = undefined;\n\nvar _RuleHelpers = require('./RuleHelpers');\n/**\n * Whitespace tokens defined in GraphQL spec.\n */\n\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n\nvar isIgnored = exports.isIgnored = function isIgnored(ch) {\n  return ch === ' ' || ch === '\\t' || ch === ',' || ch === '\\n' || ch === '\\r' || ch === '\\uFEFF';\n};\n/**\n * The lexer rules. These are exactly as described by the spec.\n */\n\n\nvar LexRules = exports.LexRules = {\n  // The Name token.\n  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n  // All Punctuation used in GraphQL\n  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|@|\\[|]|\\{|\\||\\})/,\n  // Combines the IntValue and FloatValue tokens.\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  // Note the closing quote is made optional as an IDE experience improvment.\n  String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n  // Comments consume entire lines.\n  Comment: /^#.*/\n};\n/**\n * The parser rules. These are very close to, but not exactly the same as the\n * spec. Minor deviations allow for a simpler implementation. The resulting\n * parser can parse everything the spec declares possible.\n */\n\nvar ParseRules = exports.ParseRules = {\n  Document: [(0, _RuleHelpers.list)('Definition')],\n  Definition: function Definition(token) {\n    switch (token.value) {\n      case '{':\n        return 'ShortQuery';\n\n      case 'query':\n        return 'Query';\n\n      case 'mutation':\n        return 'Mutation';\n\n      case 'subscription':\n        return 'Subscription';\n\n      case 'fragment':\n        return 'FragmentDefinition';\n\n      case 'schema':\n        return 'SchemaDef';\n\n      case 'scalar':\n        return 'ScalarDef';\n\n      case 'type':\n        return 'ObjectTypeDef';\n\n      case 'interface':\n        return 'InterfaceDef';\n\n      case 'union':\n        return 'UnionDef';\n\n      case 'enum':\n        return 'EnumDef';\n\n      case 'input':\n        return 'InputDef';\n\n      case 'extend':\n        return 'ExtendDef';\n\n      case 'directive':\n        return 'DirectiveDef';\n    }\n  },\n  // Note: instead of \"Operation\", these rules have been separated out.\n  ShortQuery: ['SelectionSet'],\n  Query: [word('query'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  Mutation: [word('mutation'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  Subscription: [word('subscription'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  VariableDefinitions: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('VariableDefinition'), (0, _RuleHelpers.p)(')')],\n  VariableDefinition: ['Variable', (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue')],\n  Variable: [(0, _RuleHelpers.p)('$', 'variable'), name('variable')],\n  DefaultValue: [(0, _RuleHelpers.p)('='), 'Value'],\n  SelectionSet: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('Selection'), (0, _RuleHelpers.p)('}')],\n  Selection: function Selection(token, stream) {\n    return token.value === '...' ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\\s\\u00a0,]*:/, false) ? 'AliasedField' : 'Field';\n  },\n  // Note: this minor deviation of \"AliasedField\" simplifies the lookahead.\n  AliasedField: [name('property'), (0, _RuleHelpers.p)(':'), name('qualifier'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],\n  Field: [name('property'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],\n  Arguments: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('Argument'), (0, _RuleHelpers.p)(')')],\n  Argument: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],\n  FragmentSpread: [(0, _RuleHelpers.p)('...'), name('def'), (0, _RuleHelpers.list)('Directive')],\n  InlineFragment: [(0, _RuleHelpers.p)('...'), (0, _RuleHelpers.opt)('TypeCondition'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  FragmentDefinition: [word('fragment'), (0, _RuleHelpers.opt)((0, _RuleHelpers.butNot)(name('def'), [word('on')])), 'TypeCondition', (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  TypeCondition: [word('on'), 'NamedType'],\n  // Variables could be parsed in cases where only Const is expected by spec.\n  Value: function Value(token) {\n    switch (token.kind) {\n      case 'Number':\n        return 'NumberValue';\n\n      case 'String':\n        return 'StringValue';\n\n      case 'Punctuation':\n        switch (token.value) {\n          case '[':\n            return 'ListValue';\n\n          case '{':\n            return 'ObjectValue';\n\n          case '$':\n            return 'Variable';\n        }\n\n        return null;\n\n      case 'Name':\n        switch (token.value) {\n          case 'true':\n          case 'false':\n            return 'BooleanValue';\n        }\n\n        if (token.value === 'null') {\n          return 'NullValue';\n        }\n\n        return 'EnumValue';\n    }\n  },\n  NumberValue: [(0, _RuleHelpers.t)('Number', 'number')],\n  StringValue: [(0, _RuleHelpers.t)('String', 'string')],\n  BooleanValue: [(0, _RuleHelpers.t)('Name', 'builtin')],\n  NullValue: [(0, _RuleHelpers.t)('Name', 'keyword')],\n  EnumValue: [name('string-2')],\n  ListValue: [(0, _RuleHelpers.p)('['), (0, _RuleHelpers.list)('Value'), (0, _RuleHelpers.p)(']')],\n  ObjectValue: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('ObjectField'), (0, _RuleHelpers.p)('}')],\n  ObjectField: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],\n  Type: function Type(token) {\n    return token.value === '[' ? 'ListType' : 'NonNullType';\n  },\n  // NonNullType has been merged into ListType to simplify.\n  ListType: [(0, _RuleHelpers.p)('['), 'Type', (0, _RuleHelpers.p)(']'), (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],\n  NonNullType: ['NamedType', (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],\n  NamedType: [type('atom')],\n  Directive: [(0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('Arguments')],\n  // GraphQL schema language\n  SchemaDef: [word('schema'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('OperationTypeDef'), (0, _RuleHelpers.p)('}')],\n  OperationTypeDef: [name('keyword'), (0, _RuleHelpers.p)(':'), name('atom')],\n  ScalarDef: [word('scalar'), name('atom'), (0, _RuleHelpers.list)('Directive')],\n  ObjectTypeDef: [word('type'), name('atom'), (0, _RuleHelpers.opt)('Implements'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],\n  Implements: [word('implements'), (0, _RuleHelpers.list)('NamedType')],\n  FieldDef: [name('property'), (0, _RuleHelpers.opt)('ArgumentsDef'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.list)('Directive')],\n  ArgumentsDef: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)(')')],\n  InputValueDef: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue'), (0, _RuleHelpers.list)('Directive')],\n  InterfaceDef: [word('interface'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],\n  UnionDef: [word('union'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('='), (0, _RuleHelpers.list)('UnionMember', (0, _RuleHelpers.p)('|'))],\n  UnionMember: ['NamedType'],\n  EnumDef: [word('enum'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('EnumValueDef'), (0, _RuleHelpers.p)('}')],\n  EnumValueDef: [name('string-2'), (0, _RuleHelpers.list)('Directive')],\n  InputDef: [word('input'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)('}')],\n  ExtendDef: [word('extend'), 'ObjectTypeDef'],\n  DirectiveDef: [word('directive'), (0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('ArgumentsDef'), word('on'), (0, _RuleHelpers.list)('DirectiveLocation', (0, _RuleHelpers.p)('|'))],\n  DirectiveLocation: [name('string-2')]\n}; // A keyword Token.\n\nfunction word(value) {\n  return {\n    style: 'keyword',\n    match: function match(token) {\n      return token.kind === 'Name' && token.value === value;\n    }\n  };\n} // A Name Token which will decorate the state with a `name`.\n\n\nfunction name(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      state.name = token.value;\n    }\n  };\n} // A Name Token which will decorate the previous state with a `type`.\n\n\nfunction type(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      if (state.prevState && state.prevState.prevState) {\n        state.name = token.value;\n        state.prevState.prevState.type = token.value;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/@apollographql/graphql-language-service-parser/dist/Rules.js"],"names":["Object","defineProperty","exports","value","ParseRules","LexRules","isIgnored","undefined","_RuleHelpers","require","ch","Name","Punctuation","Number","String","Comment","Document","list","Definition","token","ShortQuery","Query","word","opt","name","Mutation","Subscription","VariableDefinitions","p","VariableDefinition","Variable","DefaultValue","SelectionSet","Selection","stream","match","AliasedField","Field","Arguments","Argument","FragmentSpread","InlineFragment","FragmentDefinition","butNot","TypeCondition","Value","kind","NumberValue","t","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Type","ListType","NonNullType","NamedType","type","Directive","SchemaDef","OperationTypeDef","ScalarDef","ObjectTypeDef","Implements","FieldDef","ArgumentsDef","InputValueDef","InterfaceDef","UnionDef","UnionMember","EnumDef","EnumValueDef","InputDef","ExtendDef","DirectiveDef","DirectiveLocation","style","update","state","prevState"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,UAAR,GAAqBF,OAAO,CAACG,QAAR,GAAmBH,OAAO,CAACI,SAAR,GAAoBC,SAA5D;;AAEA,IAAIC,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;AAEA;;;;AAGA;;;;;;;;;;;AAUA,IAAIH,SAAS,GAAGJ,OAAO,CAACI,SAAR,GAAoB,SAASA,SAAT,CAAmBI,EAAnB,EAAuB;AACzD,SAAOA,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,IAArB,IAA6BA,EAAE,KAAK,GAApC,IAA2CA,EAAE,KAAK,IAAlD,IAA0DA,EAAE,KAAK,IAAjE,IAAyEA,EAAE,KAAK,QAAvF;AACD,CAFD;AAIA;;;;;AAGA,IAAIL,QAAQ,GAAGH,OAAO,CAACG,QAAR,GAAmB;AAChC;AACAM,EAAAA,IAAI,EAAE,yBAF0B;AAIhC;AACAC,EAAAA,WAAW,EAAE,4CALmB;AAOhC;AACAC,EAAAA,MAAM,EAAE,2DARwB;AAUhC;AACAC,EAAAA,MAAM,EAAE,qGAXwB;AAahC;AACAC,EAAAA,OAAO,EAAE;AAduB,CAAlC;AAiBA;;;;;;AAKA,IAAIX,UAAU,GAAGF,OAAO,CAACE,UAAR,GAAqB;AACpCY,EAAAA,QAAQ,EAAE,CAAC,CAAC,GAAGR,YAAY,CAACS,IAAjB,EAAuB,YAAvB,CAAD,CAD0B;AAEpCC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBC,KAApB,EAA2B;AACrC,YAAQA,KAAK,CAAChB,KAAd;AACE,WAAK,GAAL;AACE,eAAO,YAAP;;AACF,WAAK,OAAL;AACE,eAAO,OAAP;;AACF,WAAK,UAAL;AACE,eAAO,UAAP;;AACF,WAAK,cAAL;AACE,eAAO,cAAP;;AACF,WAAK,UAAL;AACE,eAAO,oBAAP;;AACF,WAAK,QAAL;AACE,eAAO,WAAP;;AACF,WAAK,QAAL;AACE,eAAO,WAAP;;AACF,WAAK,MAAL;AACE,eAAO,eAAP;;AACF,WAAK,WAAL;AACE,eAAO,cAAP;;AACF,WAAK,OAAL;AACE,eAAO,UAAP;;AACF,WAAK,MAAL;AACE,eAAO,SAAP;;AACF,WAAK,OAAL;AACE,eAAO,UAAP;;AACF,WAAK,QAAL;AACE,eAAO,WAAP;;AACF,WAAK,WAAL;AACE,eAAO,cAAP;AA5BJ;AA8BD,GAjCmC;AAmCpC;AACAiB,EAAAA,UAAU,EAAE,CAAC,cAAD,CApCwB;AAqCpCC,EAAAA,KAAK,EAAE,CAACC,IAAI,CAAC,OAAD,CAAL,EAAgB,CAAC,GAAGd,YAAY,CAACe,GAAjB,EAAsBC,IAAI,CAAC,KAAD,CAA1B,CAAhB,EAAoD,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,qBAAtB,CAApD,EAAkG,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAlG,EAAuI,cAAvI,CArC6B;AAsCpCQ,EAAAA,QAAQ,EAAE,CAACH,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGd,YAAY,CAACe,GAAjB,EAAsBC,IAAI,CAAC,KAAD,CAA1B,CAAnB,EAAuD,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,qBAAtB,CAAvD,EAAqG,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAArG,EAA0I,cAA1I,CAtC0B;AAuCpCS,EAAAA,YAAY,EAAE,CAACJ,IAAI,CAAC,cAAD,CAAL,EAAuB,CAAC,GAAGd,YAAY,CAACe,GAAjB,EAAsBC,IAAI,CAAC,KAAD,CAA1B,CAAvB,EAA2D,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,qBAAtB,CAA3D,EAAyG,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAzG,EAA8I,cAA9I,CAvCsB;AAwCpCU,EAAAA,mBAAmB,EAAE,CAAC,CAAC,GAAGnB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,oBAAvB,CAA3B,EAAyE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAzE,CAxCe;AAyCpCC,EAAAA,kBAAkB,EAAE,CAAC,UAAD,EAAa,CAAC,GAAGrB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAb,EAAuC,MAAvC,EAA+C,CAAC,GAAGpB,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAA/C,CAzCgB;AA0CpCO,EAAAA,QAAQ,EAAE,CAAC,CAAC,GAAGtB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,EAAyB,UAAzB,CAAD,EAAuCJ,IAAI,CAAC,UAAD,CAA3C,CA1C0B;AA2CpCO,EAAAA,YAAY,EAAE,CAAC,CAAC,GAAGvB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,OAA3B,CA3CsB;AA4CpCI,EAAAA,YAAY,EAAE,CAAC,CAAC,GAAGxB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA3B,EAAgE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAhE,CA5CsB;AA6CpCK,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBd,KAAnB,EAA0Be,MAA1B,EAAkC;AAC3C,WAAOf,KAAK,CAAChB,KAAN,KAAgB,KAAhB,GAAwB+B,MAAM,CAACC,KAAP,CAAa,wBAAb,EAAuC,KAAvC,IAAgD,gBAAhD,GAAmE,gBAA3F,GAA8GD,MAAM,CAACC,KAAP,CAAa,eAAb,EAA8B,KAA9B,IAAuC,cAAvC,GAAwD,OAA7K;AACD,GA/CmC;AAiDpC;AACAC,EAAAA,YAAY,EAAE,CAACZ,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGhB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAnB,EAA6CJ,IAAI,CAAC,WAAD,CAAjD,EAAgE,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,WAAtB,CAAhE,EAAoG,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAApG,EAAyI,CAAC,GAAGT,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAAzI,CAlDsB;AAmDpCc,EAAAA,KAAK,EAAE,CAACb,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,WAAtB,CAAnB,EAAuD,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAvD,EAA4F,CAAC,GAAGT,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAA5F,CAnD6B;AAoDpCe,EAAAA,SAAS,EAAE,CAAC,CAAC,GAAG9B,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,UAAvB,CAA3B,EAA+D,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAA/D,CApDyB;AAqDpCW,EAAAA,QAAQ,EAAE,CAACf,IAAI,CAAC,WAAD,CAAL,EAAoB,CAAC,GAAGhB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAApB,EAA8C,OAA9C,CArD0B;AAsDpCY,EAAAA,cAAc,EAAE,CAAC,CAAC,GAAGhC,YAAY,CAACoB,CAAjB,EAAoB,KAApB,CAAD,EAA6BJ,IAAI,CAAC,KAAD,CAAjC,EAA0C,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA1C,CAtDoB;AAuDpCwB,EAAAA,cAAc,EAAE,CAAC,CAAC,GAAGjC,YAAY,CAACoB,CAAjB,EAAoB,KAApB,CAAD,EAA6B,CAAC,GAAGpB,YAAY,CAACe,GAAjB,EAAsB,eAAtB,CAA7B,EAAqE,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAArE,EAA0G,cAA1G,CAvDoB;AAwDpCyB,EAAAA,kBAAkB,EAAE,CAACpB,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGd,YAAY,CAACe,GAAjB,EAAsB,CAAC,GAAGf,YAAY,CAACmC,MAAjB,EAAyBnB,IAAI,CAAC,KAAD,CAA7B,EAAsC,CAACF,IAAI,CAAC,IAAD,CAAL,CAAtC,CAAtB,CAAnB,EAA+F,eAA/F,EAAgH,CAAC,GAAGd,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAhH,EAAqJ,cAArJ,CAxDgB;AAyDpC2B,EAAAA,aAAa,EAAE,CAACtB,IAAI,CAAC,IAAD,CAAL,EAAa,WAAb,CAzDqB;AA0DpC;AACAuB,EAAAA,KAAK,EAAE,SAASA,KAAT,CAAe1B,KAAf,EAAsB;AAC3B,YAAQA,KAAK,CAAC2B,IAAd;AACE,WAAK,QAAL;AACE,eAAO,aAAP;;AACF,WAAK,QAAL;AACE,eAAO,aAAP;;AACF,WAAK,aAAL;AACE,gBAAQ3B,KAAK,CAAChB,KAAd;AACE,eAAK,GAAL;AACE,mBAAO,WAAP;;AACF,eAAK,GAAL;AACE,mBAAO,aAAP;;AACF,eAAK,GAAL;AACE,mBAAO,UAAP;AANJ;;AAQA,eAAO,IAAP;;AACF,WAAK,MAAL;AACE,gBAAQgB,KAAK,CAAChB,KAAd;AACE,eAAK,MAAL;AACA,eAAK,OAAL;AACE,mBAAO,cAAP;AAHJ;;AAKA,YAAIgB,KAAK,CAAChB,KAAN,KAAgB,MAApB,EAA4B;AAC1B,iBAAO,WAAP;AACD;;AACD,eAAO,WAAP;AAxBJ;AA0BD,GAtFmC;AAwFpC4C,EAAAA,WAAW,EAAE,CAAC,CAAC,GAAGvC,YAAY,CAACwC,CAAjB,EAAoB,QAApB,EAA8B,QAA9B,CAAD,CAxFuB;AAyFpCC,EAAAA,WAAW,EAAE,CAAC,CAAC,GAAGzC,YAAY,CAACwC,CAAjB,EAAoB,QAApB,EAA8B,QAA9B,CAAD,CAzFuB;AA0FpCE,EAAAA,YAAY,EAAE,CAAC,CAAC,GAAG1C,YAAY,CAACwC,CAAjB,EAAoB,MAApB,EAA4B,SAA5B,CAAD,CA1FsB;AA2FpCG,EAAAA,SAAS,EAAE,CAAC,CAAC,GAAG3C,YAAY,CAACwC,CAAjB,EAAoB,MAApB,EAA4B,SAA5B,CAAD,CA3FyB;AA4FpCI,EAAAA,SAAS,EAAE,CAAC5B,IAAI,CAAC,UAAD,CAAL,CA5FyB;AA6FpC6B,EAAAA,SAAS,EAAE,CAAC,CAAC,GAAG7C,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,OAAvB,CAA3B,EAA4D,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAA5D,CA7FyB;AA8FpC0B,EAAAA,WAAW,EAAE,CAAC,CAAC,GAAG9C,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,aAAvB,CAA3B,EAAkE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAlE,CA9FuB;AA+FpC2B,EAAAA,WAAW,EAAE,CAAC/B,IAAI,CAAC,WAAD,CAAL,EAAoB,CAAC,GAAGhB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAApB,EAA8C,OAA9C,CA/FuB;AAgGpC4B,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcrC,KAAd,EAAqB;AACzB,WAAOA,KAAK,CAAChB,KAAN,KAAgB,GAAhB,GAAsB,UAAtB,GAAmC,aAA1C;AACD,GAlGmC;AAoGpC;AACAsD,EAAAA,QAAQ,EAAE,CAAC,CAAC,GAAGjD,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,MAA3B,EAAmC,CAAC,GAAGpB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAnC,EAA6D,CAAC,GAAGpB,YAAY,CAACe,GAAjB,EAAsB,CAAC,GAAGf,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAtB,CAA7D,CArG0B;AAsGpC8B,EAAAA,WAAW,EAAE,CAAC,WAAD,EAAc,CAAC,GAAGlD,YAAY,CAACe,GAAjB,EAAsB,CAAC,GAAGf,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAtB,CAAd,CAtGuB;AAuGpC+B,EAAAA,SAAS,EAAE,CAACC,IAAI,CAAC,MAAD,CAAL,CAvGyB;AAwGpCC,EAAAA,SAAS,EAAE,CAAC,CAAC,GAAGrD,YAAY,CAACoB,CAAjB,EAAoB,GAApB,EAAyB,MAAzB,CAAD,EAAmCJ,IAAI,CAAC,MAAD,CAAvC,EAAiD,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,WAAtB,CAAjD,CAxGyB;AAyGpC;AACAuC,EAAAA,SAAS,EAAE,CAACxC,IAAI,CAAC,QAAD,CAAL,EAAiB,CAAC,GAAGd,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAjB,EAAsD,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAtD,EAAgF,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,kBAAvB,CAAhF,EAA4H,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAA5H,CA1GyB;AA2GpCmC,EAAAA,gBAAgB,EAAE,CAACvC,IAAI,CAAC,SAAD,CAAL,EAAkB,CAAC,GAAGhB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAlB,EAA4CJ,IAAI,CAAC,MAAD,CAAhD,CA3GkB;AA4GpCwC,EAAAA,SAAS,EAAE,CAAC1C,IAAI,CAAC,QAAD,CAAL,EAAiBE,IAAI,CAAC,MAAD,CAArB,EAA+B,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA/B,CA5GyB;AA6GpCgD,EAAAA,aAAa,EAAE,CAAC3C,IAAI,CAAC,MAAD,CAAL,EAAeE,IAAI,CAAC,MAAD,CAAnB,EAA6B,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,YAAtB,CAA7B,EAAkE,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAlE,EAAuG,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAvG,EAAiI,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,UAAvB,CAAjI,EAAqK,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAArK,CA7GqB;AA8GpCsC,EAAAA,UAAU,EAAE,CAAC5C,IAAI,CAAC,YAAD,CAAL,EAAqB,CAAC,GAAGd,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAArB,CA9GwB;AA+GpCkD,EAAAA,QAAQ,EAAE,CAAC3C,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAAnB,EAA0D,CAAC,GAAGf,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAA1D,EAAoF,MAApF,EAA4F,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA5F,CA/G0B;AAgHpCmD,EAAAA,YAAY,EAAE,CAAC,CAAC,GAAG5D,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAD,EAA2B,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,eAAvB,CAA3B,EAAoE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAApE,CAhHsB;AAiHpCyC,EAAAA,aAAa,EAAE,CAAC7C,IAAI,CAAC,WAAD,CAAL,EAAoB,CAAC,GAAGhB,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAApB,EAA8C,MAA9C,EAAsD,CAAC,GAAGpB,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAAtD,EAA6F,CAAC,GAAGf,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA7F,CAjHqB;AAkHpCqD,EAAAA,YAAY,EAAE,CAAChD,IAAI,CAAC,WAAD,CAAL,EAAoBE,IAAI,CAAC,MAAD,CAAxB,EAAkC,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAlC,EAAuE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAvE,EAAiG,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,UAAvB,CAAjG,EAAqI,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAArI,CAlHsB;AAmHpC2C,EAAAA,QAAQ,EAAE,CAACjD,IAAI,CAAC,OAAD,CAAL,EAAgBE,IAAI,CAAC,MAAD,CAApB,EAA8B,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA9B,EAAmE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAnE,EAA6F,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,aAAvB,EAAsC,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAtC,CAA7F,CAnH0B;AAoHpC4C,EAAAA,WAAW,EAAE,CAAC,WAAD,CApHuB;AAqHpCC,EAAAA,OAAO,EAAE,CAACnD,IAAI,CAAC,MAAD,CAAL,EAAeE,IAAI,CAAC,MAAD,CAAnB,EAA6B,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA7B,EAAkE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAlE,EAA4F,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,cAAvB,CAA5F,EAAoI,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAApI,CArH2B;AAsHpC8C,EAAAA,YAAY,EAAE,CAAClD,IAAI,CAAC,UAAD,CAAL,EAAmB,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAAnB,CAtHsB;AAuHpC0D,EAAAA,QAAQ,EAAE,CAACrD,IAAI,CAAC,OAAD,CAAL,EAAgBE,IAAI,CAAC,MAAD,CAApB,EAA8B,CAAC,GAAGhB,YAAY,CAACS,IAAjB,EAAuB,WAAvB,CAA9B,EAAmE,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAnE,EAA6F,CAAC,GAAGpB,YAAY,CAACS,IAAjB,EAAuB,eAAvB,CAA7F,EAAsI,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAAtI,CAvH0B;AAwHpCgD,EAAAA,SAAS,EAAE,CAACtD,IAAI,CAAC,QAAD,CAAL,EAAiB,eAAjB,CAxHyB;AAyHpCuD,EAAAA,YAAY,EAAE,CAACvD,IAAI,CAAC,WAAD,CAAL,EAAoB,CAAC,GAAGd,YAAY,CAACoB,CAAjB,EAAoB,GAApB,EAAyB,MAAzB,CAApB,EAAsDJ,IAAI,CAAC,MAAD,CAA1D,EAAoE,CAAC,GAAGhB,YAAY,CAACe,GAAjB,EAAsB,cAAtB,CAApE,EAA2GD,IAAI,CAAC,IAAD,CAA/G,EAAuH,CAAC,GAAGd,YAAY,CAACS,IAAjB,EAAuB,mBAAvB,EAA4C,CAAC,GAAGT,YAAY,CAACoB,CAAjB,EAAoB,GAApB,CAA5C,CAAvH,CAzHsB;AA0HpCkD,EAAAA,iBAAiB,EAAE,CAACtD,IAAI,CAAC,UAAD,CAAL;AA1HiB,CAAtC,C,CA6HA;;AACA,SAASF,IAAT,CAAcnB,KAAd,EAAqB;AACnB,SAAO;AACL4E,IAAAA,KAAK,EAAE,SADF;AAEL5C,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAehB,KAAf,EAAsB;AAC3B,aAAOA,KAAK,CAAC2B,IAAN,KAAe,MAAf,IAAyB3B,KAAK,CAAChB,KAAN,KAAgBA,KAAhD;AACD;AAJI,GAAP;AAMD,C,CAED;;;AACA,SAASqB,IAAT,CAAcuD,KAAd,EAAqB;AACnB,SAAO;AACLA,IAAAA,KAAK,EAAEA,KADF;AAEL5C,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAehB,KAAf,EAAsB;AAC3B,aAAOA,KAAK,CAAC2B,IAAN,KAAe,MAAtB;AACD,KAJI;AAKLkC,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,KAAhB,EAAuB9D,KAAvB,EAA8B;AACpC8D,MAAAA,KAAK,CAACzD,IAAN,GAAaL,KAAK,CAAChB,KAAnB;AACD;AAPI,GAAP;AASD,C,CAED;;;AACA,SAASyD,IAAT,CAAcmB,KAAd,EAAqB;AACnB,SAAO;AACLA,IAAAA,KAAK,EAAEA,KADF;AAEL5C,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAehB,KAAf,EAAsB;AAC3B,aAAOA,KAAK,CAAC2B,IAAN,KAAe,MAAtB;AACD,KAJI;AAKLkC,IAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,KAAhB,EAAuB9D,KAAvB,EAA8B;AACpC,UAAI8D,KAAK,CAACC,SAAN,IAAmBD,KAAK,CAACC,SAAN,CAAgBA,SAAvC,EAAkD;AAChDD,QAAAA,KAAK,CAACzD,IAAN,GAAaL,KAAK,CAAChB,KAAnB;AACA8E,QAAAA,KAAK,CAACC,SAAN,CAAgBA,SAAhB,CAA0BtB,IAA1B,GAAiCzC,KAAK,CAAChB,KAAvC;AACD;AACF;AAVI,GAAP;AAYD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseRules = exports.LexRules = exports.isIgnored = undefined;\n\nvar _RuleHelpers = require('./RuleHelpers');\n\n/**\n * Whitespace tokens defined in GraphQL spec.\n */\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\nvar isIgnored = exports.isIgnored = function isIgnored(ch) {\n  return ch === ' ' || ch === '\\t' || ch === ',' || ch === '\\n' || ch === '\\r' || ch === '\\uFEFF';\n};\n\n/**\n * The lexer rules. These are exactly as described by the spec.\n */\nvar LexRules = exports.LexRules = {\n  // The Name token.\n  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n\n  // All Punctuation used in GraphQL\n  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|@|\\[|]|\\{|\\||\\})/,\n\n  // Combines the IntValue and FloatValue tokens.\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n\n  // Note the closing quote is made optional as an IDE experience improvment.\n  String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n\n  // Comments consume entire lines.\n  Comment: /^#.*/\n};\n\n/**\n * The parser rules. These are very close to, but not exactly the same as the\n * spec. Minor deviations allow for a simpler implementation. The resulting\n * parser can parse everything the spec declares possible.\n */\nvar ParseRules = exports.ParseRules = {\n  Document: [(0, _RuleHelpers.list)('Definition')],\n  Definition: function Definition(token) {\n    switch (token.value) {\n      case '{':\n        return 'ShortQuery';\n      case 'query':\n        return 'Query';\n      case 'mutation':\n        return 'Mutation';\n      case 'subscription':\n        return 'Subscription';\n      case 'fragment':\n        return 'FragmentDefinition';\n      case 'schema':\n        return 'SchemaDef';\n      case 'scalar':\n        return 'ScalarDef';\n      case 'type':\n        return 'ObjectTypeDef';\n      case 'interface':\n        return 'InterfaceDef';\n      case 'union':\n        return 'UnionDef';\n      case 'enum':\n        return 'EnumDef';\n      case 'input':\n        return 'InputDef';\n      case 'extend':\n        return 'ExtendDef';\n      case 'directive':\n        return 'DirectiveDef';\n    }\n  },\n\n  // Note: instead of \"Operation\", these rules have been separated out.\n  ShortQuery: ['SelectionSet'],\n  Query: [word('query'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  Mutation: [word('mutation'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  Subscription: [word('subscription'), (0, _RuleHelpers.opt)(name('def')), (0, _RuleHelpers.opt)('VariableDefinitions'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  VariableDefinitions: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('VariableDefinition'), (0, _RuleHelpers.p)(')')],\n  VariableDefinition: ['Variable', (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue')],\n  Variable: [(0, _RuleHelpers.p)('$', 'variable'), name('variable')],\n  DefaultValue: [(0, _RuleHelpers.p)('='), 'Value'],\n  SelectionSet: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('Selection'), (0, _RuleHelpers.p)('}')],\n  Selection: function Selection(token, stream) {\n    return token.value === '...' ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false) ? 'InlineFragment' : 'FragmentSpread' : stream.match(/[\\s\\u00a0,]*:/, false) ? 'AliasedField' : 'Field';\n  },\n\n  // Note: this minor deviation of \"AliasedField\" simplifies the lookahead.\n  AliasedField: [name('property'), (0, _RuleHelpers.p)(':'), name('qualifier'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],\n  Field: [name('property'), (0, _RuleHelpers.opt)('Arguments'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.opt)('SelectionSet')],\n  Arguments: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('Argument'), (0, _RuleHelpers.p)(')')],\n  Argument: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],\n  FragmentSpread: [(0, _RuleHelpers.p)('...'), name('def'), (0, _RuleHelpers.list)('Directive')],\n  InlineFragment: [(0, _RuleHelpers.p)('...'), (0, _RuleHelpers.opt)('TypeCondition'), (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  FragmentDefinition: [word('fragment'), (0, _RuleHelpers.opt)((0, _RuleHelpers.butNot)(name('def'), [word('on')])), 'TypeCondition', (0, _RuleHelpers.list)('Directive'), 'SelectionSet'],\n  TypeCondition: [word('on'), 'NamedType'],\n  // Variables could be parsed in cases where only Const is expected by spec.\n  Value: function Value(token) {\n    switch (token.kind) {\n      case 'Number':\n        return 'NumberValue';\n      case 'String':\n        return 'StringValue';\n      case 'Punctuation':\n        switch (token.value) {\n          case '[':\n            return 'ListValue';\n          case '{':\n            return 'ObjectValue';\n          case '$':\n            return 'Variable';\n        }\n        return null;\n      case 'Name':\n        switch (token.value) {\n          case 'true':\n          case 'false':\n            return 'BooleanValue';\n        }\n        if (token.value === 'null') {\n          return 'NullValue';\n        }\n        return 'EnumValue';\n    }\n  },\n\n  NumberValue: [(0, _RuleHelpers.t)('Number', 'number')],\n  StringValue: [(0, _RuleHelpers.t)('String', 'string')],\n  BooleanValue: [(0, _RuleHelpers.t)('Name', 'builtin')],\n  NullValue: [(0, _RuleHelpers.t)('Name', 'keyword')],\n  EnumValue: [name('string-2')],\n  ListValue: [(0, _RuleHelpers.p)('['), (0, _RuleHelpers.list)('Value'), (0, _RuleHelpers.p)(']')],\n  ObjectValue: [(0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('ObjectField'), (0, _RuleHelpers.p)('}')],\n  ObjectField: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Value'],\n  Type: function Type(token) {\n    return token.value === '[' ? 'ListType' : 'NonNullType';\n  },\n\n  // NonNullType has been merged into ListType to simplify.\n  ListType: [(0, _RuleHelpers.p)('['), 'Type', (0, _RuleHelpers.p)(']'), (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],\n  NonNullType: ['NamedType', (0, _RuleHelpers.opt)((0, _RuleHelpers.p)('!'))],\n  NamedType: [type('atom')],\n  Directive: [(0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('Arguments')],\n  // GraphQL schema language\n  SchemaDef: [word('schema'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('OperationTypeDef'), (0, _RuleHelpers.p)('}')],\n  OperationTypeDef: [name('keyword'), (0, _RuleHelpers.p)(':'), name('atom')],\n  ScalarDef: [word('scalar'), name('atom'), (0, _RuleHelpers.list)('Directive')],\n  ObjectTypeDef: [word('type'), name('atom'), (0, _RuleHelpers.opt)('Implements'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],\n  Implements: [word('implements'), (0, _RuleHelpers.list)('NamedType')],\n  FieldDef: [name('property'), (0, _RuleHelpers.opt)('ArgumentsDef'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.list)('Directive')],\n  ArgumentsDef: [(0, _RuleHelpers.p)('('), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)(')')],\n  InputValueDef: [name('attribute'), (0, _RuleHelpers.p)(':'), 'Type', (0, _RuleHelpers.opt)('DefaultValue'), (0, _RuleHelpers.list)('Directive')],\n  InterfaceDef: [word('interface'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('FieldDef'), (0, _RuleHelpers.p)('}')],\n  UnionDef: [word('union'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('='), (0, _RuleHelpers.list)('UnionMember', (0, _RuleHelpers.p)('|'))],\n  UnionMember: ['NamedType'],\n  EnumDef: [word('enum'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('EnumValueDef'), (0, _RuleHelpers.p)('}')],\n  EnumValueDef: [name('string-2'), (0, _RuleHelpers.list)('Directive')],\n  InputDef: [word('input'), name('atom'), (0, _RuleHelpers.list)('Directive'), (0, _RuleHelpers.p)('{'), (0, _RuleHelpers.list)('InputValueDef'), (0, _RuleHelpers.p)('}')],\n  ExtendDef: [word('extend'), 'ObjectTypeDef'],\n  DirectiveDef: [word('directive'), (0, _RuleHelpers.p)('@', 'meta'), name('meta'), (0, _RuleHelpers.opt)('ArgumentsDef'), word('on'), (0, _RuleHelpers.list)('DirectiveLocation', (0, _RuleHelpers.p)('|'))],\n  DirectiveLocation: [name('string-2')]\n};\n\n// A keyword Token.\nfunction word(value) {\n  return {\n    style: 'keyword',\n    match: function match(token) {\n      return token.kind === 'Name' && token.value === value;\n    }\n  };\n}\n\n// A Name Token which will decorate the state with a `name`.\nfunction name(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      state.name = token.value;\n    }\n  };\n}\n\n// A Name Token which will decorate the previous state with a `type`.\nfunction type(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === 'Name';\n    },\n    update: function update(state, token) {\n      if (state.prevState && state.prevState.prevState) {\n        state.name = token.value;\n        state.prevState.prevState.type = token.value;\n      }\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}