{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig; // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  } // Remember initial indentation\n\n\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  } // Consume spaces and ignored characters\n\n\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  } // Get a matched token from the stream, using lex\n\n\n  var token = lex(lexRules, stream); // If there's no matching token, skip ahead.\n\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  } // If the next token is a Comment, insert a Comment parsing rule.\n\n\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  } // Save state before continuing.\n\n\n  var backupState = assign({}, state); // Handle changes in expected indentation level\n\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step]; // Seperator between list elements if necessary.\n\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      } // A string represents a Rule\n\n\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      } // Otherwise, match a Terminal.\n\n\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        } // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n\n\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  } // The parser does not know how to interpret this token, do not affect state.\n\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n} // Utility function to assign from object to another object.\n\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n} // A special rule set for parsing comment tokens.\n\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n}; // Push a new rule onto the state.\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n} // Pop the current rule from the state.\n\n\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n} // Advance the step of the current rule.\n\n\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator; // If the separator was optional, then give it an opportunity to repeat.\n\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    } // If this was a successful list parse, then allow it to repeat itself.\n\n\n    if (successful) {\n      return;\n    }\n  } // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n\n\n  state.needsSeperator = false;\n  state.step++; // While the current rule is completed.\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n} // Unwind the state after an unsuccessful match.\n\n\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  } // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n} // Given a stream, returns a { kind, value } pair, or null.\n\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/@apollographql/graphql-language-service-parser/dist/onlineParser.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","onlineParser","_Rules","require","options","undefined","eatWhitespace","stream","eatWhile","isIgnored","lexRules","LexRules","parseRules","ParseRules","editorConfig","startState","initialState","level","step","name","kind","type","rule","needsSeperator","prevState","pushRule","token","state","getToken","popRule","needsAdvance","advanceRule","sol","tabSize","indentLevel","Math","floor","indentation","lex","match","SpecialParseRules","backupState","test","levels","concat","slice","expected","separator","ofRule","update","style","unsuccessful","to","from","keys","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","Array","isArray","kinds"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.\n                                                                                                                                                                                                                                                                   *  All rights reserved.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the\n                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  \n                                                                                                                                                                                                                                                                   */\n\n/**\n * Builds an online immutable parser, designed to be used as part of a syntax\n * highlighting and code intelligence tools.\n *\n * Options:\n *\n *     eatWhitespace: (\n *       stream: Stream | CodeMirror.StringStream | CharacterStream\n *     ) => boolean\n *       Use CodeMirror API.\n *\n *     LexRules: { [name: string]: RegExp }, Includes `Punctuation`, `Comment`.\n *\n *     ParseRules: { [name: string]: Array<Rule> }, Includes `Document`.\n *\n *     editorConfig: { [name: string]: any }, Provides an editor-specific\n *       configurations set.\n *\n */\n\nexports.default = onlineParser;\n\nvar _Rules = require('./Rules');\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(_Rules.isIgnored);\n    },\n    lexRules: _Rules.LexRules,\n    parseRules: _Rules.ParseRules,\n    editorConfig: {}\n  };\n\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, 'Document');\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n  // Restore state after an empty-rule.\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  // Remember initial indentation\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  // Consume spaces and ignored characters\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  }\n\n  // Get a matched token from the stream, using lex\n  var token = lex(lexRules, stream);\n\n  // If there's no matching token, skip ahead.\n  if (!token) {\n    stream.match(/\\S+/);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  }\n\n  // If the next token is a Comment, insert a Comment parsing rule.\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  }\n\n  // Save state before continuing.\n  var backupState = assign({}, state);\n\n  // Handle changes in expected indentation level\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      // Push on the stack of levels one level deeper than the current level.\n      state.levels = (state.levels || []).concat(state.indentLevel + 1);\n    } else if (/^[})\\]]/.test(token.value)) {\n      // Pop from the stack of levels.\n      // If the top of the stack is lower than the current level, lower the\n      // current level to match.\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    // If this is a forking rule, determine what rule to use based on\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    // Seperator between list elements if necessary.\n    if (state.needsSeperator) {\n      expected = expected && expected.separator;\n    }\n\n    if (expected) {\n      // Un-wrap optional/list parseRules.\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      // A string represents a Rule\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      // Otherwise, match a Terminal.\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        // If this token was a punctuator, advance the parse rule, otherwise\n        // mark the state to be advanced before the next token. This ensures\n        // that tokens which can be appended to keep the appropriate state.\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n\n  // The parser does not know how to interpret this token, do not affect state.\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n}\n\n// Utility function to assign from object to another object.\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n\n// A special rule set for parsing comment tokens.\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\n// Push a new rule onto the state.\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n  state.prevState = _extends({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n\n// Pop the current rule from the state.\nfunction popRule(state) {\n  // Check if there's anything to pop\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n\n// Advance the step of the current rule.\nfunction advanceRule(state, successful) {\n  // If this is advancing successfully and the current state is a list, give\n  // it an opportunity to repeat itself.\n  if (isList(state)) {\n    if (state.rule && state.rule[state.step].separator) {\n      var separator = state.rule[state.step].separator;\n      state.needsSeperator = !state.needsSeperator;\n      // If the separator was optional, then give it an opportunity to repeat.\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n    // If this was a successful list parse, then allow it to repeat itself.\n    if (successful) {\n      return;\n    }\n  }\n\n  // Advance the step in the rule. If the rule is completed, pop\n  // the rule and advance the parent rule as well (recursively).\n  state.needsSeperator = false;\n  state.step++;\n\n  // While the current rule is completed.\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      // Do not advance a List step so it has the opportunity to repeat itself.\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  return Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step].isList;\n}\n\n// Unwind the state after an unsuccessful match.\nfunction unsuccessful(state) {\n  // Fall back to the parent rule until you get to an optional or list rule or\n  // until the entire stack of rules is empty.\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  // If there is still a rule, it must be an optional or list rule.\n  // Consider this rule a success so that we may move past it.\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n// Given a stream, returns a { kind, value } pair, or null.\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}