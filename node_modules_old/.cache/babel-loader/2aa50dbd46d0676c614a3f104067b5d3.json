{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar common = require('./common');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force'\n  }\n}); //@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves files.\n\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && fs.statSync(dest); // Dest is not existing dir, but multiple sources given\n\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  } // Dest is an existing file, but no -f given\n\n\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    } // If here, src exists\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n\n\n    var thisDest = dest;\n\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n\n  return '';\n} // mv\n\n\nmodule.exports = _mv;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/shelljs/src/mv.js"],"names":["fs","require","path","common","cp","rm","register","_mv","cmdOptions","options","sources","dest","arguments","length","error","slice","call","exists","existsSync","stats","statSync","isDirectory","isFile","no_force","forEach","src","continue","thisDest","normalize","basename","resolve","dirname","renameSync","e","code","module","exports"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar cp = require('./cp');\nvar rm = require('./rm');\n\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n  },\n});\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves files.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest);\n  var stats = exists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n\n  sources.forEach(function (src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, { continue: true });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, { continue: true });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;\n"]},"metadata":{},"sourceType":"script"}