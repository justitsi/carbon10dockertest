{"ast":null,"code":"'use strict';\n\nconst Observable = require('any-observable');\n\nfunction or(option, alternate, required) {\n  const result = option === false ? false : option || alternate;\n\n  if (required && !result || result && typeof result !== 'string') {\n    throw new TypeError(alternate + 'Event must be a string.');\n  }\n\n  return result;\n}\n\nmodule.exports = (stream, opts) => {\n  opts = opts || {};\n  let complete = false;\n  let dataListeners = [];\n  const awaited = opts.await;\n  const dataEvent = or(opts.dataEvent, 'data', true);\n  const errorEvent = or(opts.errorEvent, 'error');\n  const endEvent = or(opts.endEvent, 'end');\n\n  function cleanup() {\n    complete = true;\n    dataListeners.forEach(listener => {\n      stream.removeListener(dataEvent, listener);\n    });\n    dataListeners = null;\n  }\n\n  const completion = new Promise((resolve, reject) => {\n    function onEnd(result) {\n      if (awaited) {\n        awaited.then(resolve);\n      } else {\n        resolve(result);\n      }\n    }\n\n    if (endEvent) {\n      stream.once(endEvent, onEnd);\n    } else if (awaited) {\n      onEnd();\n    }\n\n    if (errorEvent) {\n      stream.once(errorEvent, reject);\n    }\n\n    if (awaited) {\n      awaited.catch(reject);\n    }\n  }).catch(err => {\n    cleanup();\n    throw err;\n  }).then(result => {\n    cleanup();\n    return result;\n  });\n  return new Observable(observer => {\n    completion.then(observer.complete.bind(observer)).catch(observer.error.bind(observer));\n\n    if (complete) {\n      return null;\n    }\n\n    const onData = data => {\n      observer.next(data);\n    };\n\n    stream.on(dataEvent, onData);\n    dataListeners.push(onData);\n    return () => {\n      stream.removeListener(dataEvent, onData);\n\n      if (complete) {\n        return;\n      }\n\n      const idx = dataListeners.indexOf(onData);\n\n      if (idx !== -1) {\n        dataListeners.splice(idx, 1);\n      }\n    };\n  });\n};","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/@samverschueren/stream-to-observable/index.js"],"names":["Observable","require","or","option","alternate","required","result","TypeError","module","exports","stream","opts","complete","dataListeners","awaited","await","dataEvent","errorEvent","endEvent","cleanup","forEach","listener","removeListener","completion","Promise","resolve","reject","onEnd","then","once","catch","err","observer","bind","error","onData","data","next","on","push","idx","indexOf","splice"],"mappings":"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","sourcesContent":["'use strict';\nconst Observable = require('any-observable');\n\nfunction or(option, alternate, required) {\n\tconst result = option === false ? false : option || alternate;\n\n\tif ((required && !result) || (result && typeof result !== 'string')) {\n\t\tthrow new TypeError(alternate + 'Event must be a string.');\n\t}\n\n\treturn result;\n}\n\nmodule.exports = (stream, opts) => {\n\topts = opts || {};\n\n\tlet complete = false;\n\tlet dataListeners = [];\n\tconst awaited = opts.await;\n\tconst dataEvent = or(opts.dataEvent, 'data', true);\n\tconst errorEvent = or(opts.errorEvent, 'error');\n\tconst endEvent = or(opts.endEvent, 'end');\n\n\tfunction cleanup() {\n\t\tcomplete = true;\n\t\tdataListeners.forEach(listener => {\n\t\t\tstream.removeListener(dataEvent, listener);\n\t\t});\n\t\tdataListeners = null;\n\t}\n\n\tconst completion = new Promise((resolve, reject) => {\n\t\tfunction onEnd(result) {\n\t\t\tif (awaited) {\n\t\t\t\tawaited.then(resolve);\n\t\t\t} else {\n\t\t\t\tresolve(result);\n\t\t\t}\n\t\t}\n\n\t\tif (endEvent) {\n\t\t\tstream.once(endEvent, onEnd);\n\t\t} else if (awaited) {\n\t\t\tonEnd();\n\t\t}\n\n\t\tif (errorEvent) {\n\t\t\tstream.once(errorEvent, reject);\n\t\t}\n\n\t\tif (awaited) {\n\t\t\tawaited.catch(reject);\n\t\t}\n\t}).catch(err => {\n\t\tcleanup();\n\t\tthrow err;\n\t}).then(result => {\n\t\tcleanup();\n\t\treturn result;\n\t});\n\n\treturn new Observable(observer => {\n\t\tcompletion\n\t\t\t.then(observer.complete.bind(observer))\n\t\t\t.catch(observer.error.bind(observer));\n\n\t\tif (complete) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst onData = data => {\n\t\t\tobserver.next(data);\n\t\t};\n\n\t\tstream.on(dataEvent, onData);\n\t\tdataListeners.push(onData);\n\n\t\treturn () => {\n\t\t\tstream.removeListener(dataEvent, onData);\n\n\t\t\tif (complete) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst idx = dataListeners.indexOf(onData);\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tdataListeners.splice(idx, 1);\n\t\t\t}\n\t\t};\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}