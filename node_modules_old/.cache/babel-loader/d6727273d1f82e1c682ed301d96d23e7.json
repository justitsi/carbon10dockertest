{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"./thenable.ts\" />\n'use strict';\n\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Is = require(\"./is\");\n\nconst messages_1 = require(\"./messages\");\n\nexports.RequestType = messages_1.RequestType;\nexports.RequestType0 = messages_1.RequestType0;\nexports.RequestType1 = messages_1.RequestType1;\nexports.RequestType2 = messages_1.RequestType2;\nexports.RequestType3 = messages_1.RequestType3;\nexports.RequestType4 = messages_1.RequestType4;\nexports.RequestType5 = messages_1.RequestType5;\nexports.RequestType6 = messages_1.RequestType6;\nexports.RequestType7 = messages_1.RequestType7;\nexports.RequestType8 = messages_1.RequestType8;\nexports.RequestType9 = messages_1.RequestType9;\nexports.ResponseError = messages_1.ResponseError;\nexports.ErrorCodes = messages_1.ErrorCodes;\nexports.NotificationType = messages_1.NotificationType;\nexports.NotificationType0 = messages_1.NotificationType0;\nexports.NotificationType1 = messages_1.NotificationType1;\nexports.NotificationType2 = messages_1.NotificationType2;\nexports.NotificationType3 = messages_1.NotificationType3;\nexports.NotificationType4 = messages_1.NotificationType4;\nexports.NotificationType5 = messages_1.NotificationType5;\nexports.NotificationType6 = messages_1.NotificationType6;\nexports.NotificationType7 = messages_1.NotificationType7;\nexports.NotificationType8 = messages_1.NotificationType8;\nexports.NotificationType9 = messages_1.NotificationType9;\n\nconst messageReader_1 = require(\"./messageReader\");\n\nexports.MessageReader = messageReader_1.MessageReader;\nexports.StreamMessageReader = messageReader_1.StreamMessageReader;\nexports.IPCMessageReader = messageReader_1.IPCMessageReader;\nexports.SocketMessageReader = messageReader_1.SocketMessageReader;\n\nconst messageWriter_1 = require(\"./messageWriter\");\n\nexports.MessageWriter = messageWriter_1.MessageWriter;\nexports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;\nexports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;\nexports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;\n\nconst events_1 = require(\"./events\");\n\nexports.Disposable = events_1.Disposable;\nexports.Event = events_1.Event;\nexports.Emitter = events_1.Emitter;\n\nconst cancellation_1 = require(\"./cancellation\");\n\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\nexports.CancellationToken = cancellation_1.CancellationToken;\n\nconst linkedMap_1 = require(\"./linkedMap\");\n\n__export(require(\"./pipeSupport\"));\n\n__export(require(\"./socketSupport\"));\n\nvar CancelNotification;\n\n(function (CancelNotification) {\n  CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\n\nexports.NullLogger = Object.freeze({\n  error: () => {},\n  warn: () => {},\n  info: () => {},\n  log: () => {}\n});\nvar Trace;\n\n(function (Trace) {\n  Trace[Trace[\"Off\"] = 0] = \"Off\";\n  Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n  Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\n})(Trace = exports.Trace || (exports.Trace = {}));\n\n(function (Trace) {\n  function fromString(value) {\n    value = value.toLowerCase();\n\n    switch (value) {\n      case 'off':\n        return Trace.Off;\n\n      case 'messages':\n        return Trace.Messages;\n\n      case 'verbose':\n        return Trace.Verbose;\n\n      default:\n        return Trace.Off;\n    }\n  }\n\n  Trace.fromString = fromString;\n\n  function toString(value) {\n    switch (value) {\n      case Trace.Off:\n        return 'off';\n\n      case Trace.Messages:\n        return 'messages';\n\n      case Trace.Verbose:\n        return 'verbose';\n\n      default:\n        return 'off';\n    }\n  }\n\n  Trace.toString = toString;\n})(Trace = exports.Trace || (exports.Trace = {}));\n\nvar TraceFormat;\n\n(function (TraceFormat) {\n  TraceFormat[\"Text\"] = \"text\";\n  TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n\n(function (TraceFormat) {\n  function fromString(value) {\n    value = value.toLowerCase();\n\n    if (value === 'json') {\n      return TraceFormat.JSON;\n    } else {\n      return TraceFormat.Text;\n    }\n  }\n\n  TraceFormat.fromString = fromString;\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n\nvar SetTraceNotification;\n\n(function (SetTraceNotification) {\n  SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\n\nvar LogTraceNotification;\n\n(function (LogTraceNotification) {\n  LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\n\nvar ConnectionErrors;\n\n(function (ConnectionErrors) {\n  /**\r\n   * The connection is closed.\r\n   */\n  ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n  /**\r\n   * The connection got disposed.\r\n   */\n\n  ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n  /**\r\n   * The connection is already in listening mode.\r\n   */\n\n  ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\n\nclass ConnectionError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    Object.setPrototypeOf(this, ConnectionError.prototype);\n  }\n\n}\n\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n\n(function (ConnectionStrategy) {\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.func(candidate.cancelUndispatched);\n  }\n\n  ConnectionStrategy.is = is;\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\n\nvar ConnectionState;\n\n(function (ConnectionState) {\n  ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n  ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n  ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n  ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\n\nfunction _createMessageConnection(messageReader, messageWriter, logger, strategy) {\n  let sequenceNumber = 0;\n  let notificationSquenceNumber = 0;\n  let unknownResponseSquenceNumber = 0;\n  const version = '2.0';\n  let starRequestHandler = undefined;\n  let requestHandlers = Object.create(null);\n  let starNotificationHandler = undefined;\n  let notificationHandlers = Object.create(null);\n  let timer;\n  let messageQueue = new linkedMap_1.LinkedMap();\n  let responsePromises = Object.create(null);\n  let requestTokens = Object.create(null);\n  let trace = Trace.Off;\n  let traceFormat = TraceFormat.Text;\n  let tracer;\n  let state = ConnectionState.New;\n  let errorEmitter = new events_1.Emitter();\n  let closeEmitter = new events_1.Emitter();\n  let unhandledNotificationEmitter = new events_1.Emitter();\n  let disposeEmitter = new events_1.Emitter();\n\n  function createRequestQueueKey(id) {\n    return 'req-' + id.toString();\n  }\n\n  function createResponseQueueKey(id) {\n    if (id === null) {\n      return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\n    } else {\n      return 'res-' + id.toString();\n    }\n  }\n\n  function createNotificationQueueKey() {\n    return 'not-' + (++notificationSquenceNumber).toString();\n  }\n\n  function addMessageToQueue(queue, message) {\n    if (messages_1.isRequestMessage(message)) {\n      queue.set(createRequestQueueKey(message.id), message);\n    } else if (messages_1.isResponseMessage(message)) {\n      queue.set(createResponseQueueKey(message.id), message);\n    } else {\n      queue.set(createNotificationQueueKey(), message);\n    }\n  }\n\n  function cancelUndispatched(_message) {\n    return undefined;\n  }\n\n  function isListening() {\n    return state === ConnectionState.Listening;\n  }\n\n  function isClosed() {\n    return state === ConnectionState.Closed;\n  }\n\n  function isDisposed() {\n    return state === ConnectionState.Disposed;\n  }\n\n  function closeHandler() {\n    if (state === ConnectionState.New || state === ConnectionState.Listening) {\n      state = ConnectionState.Closed;\n      closeEmitter.fire(undefined);\n    } // If the connection is disposed don't sent close events.\n\n  }\n\n  ;\n\n  function readErrorHandler(error) {\n    errorEmitter.fire([error, undefined, undefined]);\n  }\n\n  function writeErrorHandler(data) {\n    errorEmitter.fire(data);\n  }\n\n  messageReader.onClose(closeHandler);\n  messageReader.onError(readErrorHandler);\n  messageWriter.onClose(closeHandler);\n  messageWriter.onError(writeErrorHandler);\n\n  function triggerMessageQueue() {\n    if (timer || messageQueue.size === 0) {\n      return;\n    }\n\n    timer = setImmediate(() => {\n      timer = undefined;\n      processMessageQueue();\n    });\n  }\n\n  function processMessageQueue() {\n    if (messageQueue.size === 0) {\n      return;\n    }\n\n    let message = messageQueue.shift();\n\n    try {\n      if (messages_1.isRequestMessage(message)) {\n        handleRequest(message);\n      } else if (messages_1.isNotificationMessage(message)) {\n        handleNotification(message);\n      } else if (messages_1.isResponseMessage(message)) {\n        handleResponse(message);\n      } else {\n        handleInvalidMessage(message);\n      }\n    } finally {\n      triggerMessageQueue();\n    }\n  }\n\n  let callback = message => {\n    try {\n      // We have received a cancellation message. Check if the message is still in the queue\n      // and cancel it if allowed to do so.\n      if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\n        let key = createRequestQueueKey(message.params.id);\n        let toCancel = messageQueue.get(key);\n\n        if (messages_1.isRequestMessage(toCancel)) {\n          let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n\n          if (response && (response.error !== void 0 || response.result !== void 0)) {\n            messageQueue.delete(key);\n            response.id = toCancel.id;\n            traceSendingResponse(response, message.method, Date.now());\n            messageWriter.write(response);\n            return;\n          }\n        }\n      }\n\n      addMessageToQueue(messageQueue, message);\n    } finally {\n      triggerMessageQueue();\n    }\n  };\n\n  function handleRequest(requestMessage) {\n    if (isDisposed()) {\n      // we return here silently since we fired an event when the\n      // connection got disposed.\n      return;\n    }\n\n    function reply(resultOrError, method, startTime) {\n      let message = {\n        jsonrpc: version,\n        id: requestMessage.id\n      };\n\n      if (resultOrError instanceof messages_1.ResponseError) {\n        message.error = resultOrError.toJson();\n      } else {\n        message.result = resultOrError === void 0 ? null : resultOrError;\n      }\n\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    function replyError(error, method, startTime) {\n      let message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        error: error.toJson()\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    function replySuccess(result, method, startTime) {\n      // The JSON RPC defines that a response must either have a result or an error\n      // So we can't treat undefined as a valid response result.\n      if (result === void 0) {\n        result = null;\n      }\n\n      let message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        result: result\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message);\n    }\n\n    traceReceivedRequest(requestMessage);\n    let element = requestHandlers[requestMessage.method];\n    let type;\n    let requestHandler;\n\n    if (element) {\n      type = element.type;\n      requestHandler = element.handler;\n    }\n\n    let startTime = Date.now();\n\n    if (requestHandler || starRequestHandler) {\n      let cancellationSource = new cancellation_1.CancellationTokenSource();\n      let tokenKey = String(requestMessage.id);\n      requestTokens[tokenKey] = cancellationSource;\n\n      try {\n        let handlerResult;\n\n        if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {\n          handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);\n        } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {\n          handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);\n        } else {\n          handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n        }\n\n        let promise = handlerResult;\n\n        if (!handlerResult) {\n          delete requestTokens[tokenKey];\n          replySuccess(handlerResult, requestMessage.method, startTime);\n        } else if (promise.then) {\n          promise.then(resultOrError => {\n            delete requestTokens[tokenKey];\n            reply(resultOrError, requestMessage.method, startTime);\n          }, error => {\n            delete requestTokens[tokenKey];\n\n            if (error instanceof messages_1.ResponseError) {\n              replyError(error, requestMessage.method, startTime);\n            } else if (error && Is.string(error.message)) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n            } else {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n            }\n          });\n        } else {\n          delete requestTokens[tokenKey];\n          reply(handlerResult, requestMessage.method, startTime);\n        }\n      } catch (error) {\n        delete requestTokens[tokenKey];\n\n        if (error instanceof messages_1.ResponseError) {\n          reply(error, requestMessage.method, startTime);\n        } else if (error && Is.string(error.message)) {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n        } else {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n        }\n      }\n    } else {\n      replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n    }\n  }\n\n  function handleResponse(responseMessage) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n\n    if (responseMessage.id === null) {\n      if (responseMessage.error) {\n        logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n      } else {\n        logger.error(`Received response message without id. No further error information provided.`);\n      }\n    } else {\n      let key = String(responseMessage.id);\n      let responsePromise = responsePromises[key];\n      traceReceivedResponse(responseMessage, responsePromise);\n\n      if (responsePromise) {\n        delete responsePromises[key];\n\n        try {\n          if (responseMessage.error) {\n            let error = responseMessage.error;\n            responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n          } else if (responseMessage.result !== void 0) {\n            responsePromise.resolve(responseMessage.result);\n          } else {\n            throw new Error('Should never happen.');\n          }\n        } catch (error) {\n          if (error.message) {\n            logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n          } else {\n            logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n          }\n        }\n      }\n    }\n  }\n\n  function handleNotification(message) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n\n    let type = undefined;\n    let notificationHandler;\n\n    if (message.method === CancelNotification.type.method) {\n      notificationHandler = params => {\n        let id = params.id;\n        let source = requestTokens[String(id)];\n\n        if (source) {\n          source.cancel();\n        }\n      };\n    } else {\n      let element = notificationHandlers[message.method];\n\n      if (element) {\n        notificationHandler = element.handler;\n        type = element.type;\n      }\n    }\n\n    if (notificationHandler || starNotificationHandler) {\n      try {\n        traceReceivedNotification(message);\n\n        if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {\n          notificationHandler ? notificationHandler() : starNotificationHandler(message.method);\n        } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {\n          notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);\n        } else {\n          notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);\n        }\n      } catch (error) {\n        if (error.message) {\n          logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n        } else {\n          logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n        }\n      }\n    } else {\n      unhandledNotificationEmitter.fire(message);\n    }\n  }\n\n  function handleInvalidMessage(message) {\n    if (!message) {\n      logger.error('Received empty message.');\n      return;\n    }\n\n    logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`); // Test whether we find an id to reject the promise\n\n    let responseMessage = message;\n\n    if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n      let key = String(responseMessage.id);\n      let responseHandler = responsePromises[key];\n\n      if (responseHandler) {\n        responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n      }\n    }\n  }\n\n  function traceSendingRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose && message.params) {\n        data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n      }\n\n      tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('send-request', message);\n    }\n  }\n\n  function traceSendingNotification(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.params) {\n          data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n\n      tracer.log(`Sending notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('send-notification', message);\n    }\n  }\n\n  function traceSendingResponse(message, method, startTime) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n          } else if (message.error === void 0) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n\n      tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n    } else {\n      logLSPMessage('send-response', message);\n    }\n  }\n\n  function traceReceivedRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose && message.params) {\n        data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n      }\n\n      tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('receive-request', message);\n    }\n  }\n\n  function traceReceivedNotification(message) {\n    if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.params) {\n          data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n\n      tracer.log(`Received notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('receive-notification', message);\n    }\n  }\n\n  function traceReceivedResponse(message, responsePromise) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n\n      if (trace === Trace.Verbose) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n          } else if (message.error === void 0) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n\n      if (responsePromise) {\n        let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n        tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n      } else {\n        tracer.log(`Received response ${message.id} without active response promise.`, data);\n      }\n    } else {\n      logLSPMessage('receive-response', message);\n    }\n  }\n\n  function logLSPMessage(type, message) {\n    if (!tracer || trace === Trace.Off) {\n      return;\n    }\n\n    const lspMessage = {\n      isLSPMessage: true,\n      type,\n      message,\n      timestamp: Date.now()\n    };\n    tracer.log(lspMessage);\n  }\n\n  function throwIfClosedOrDisposed() {\n    if (isClosed()) {\n      throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n    }\n\n    if (isDisposed()) {\n      throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n    }\n  }\n\n  function throwIfListening() {\n    if (isListening()) {\n      throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n    }\n  }\n\n  function throwIfNotListening() {\n    if (!isListening()) {\n      throw new Error('Call listen() first.');\n    }\n  }\n\n  function undefinedToNull(param) {\n    if (param === void 0) {\n      return null;\n    } else {\n      return param;\n    }\n  }\n\n  function computeMessageParams(type, params) {\n    let result;\n    let numberOfParams = type.numberOfParams;\n\n    switch (numberOfParams) {\n      case 0:\n        result = null;\n        break;\n\n      case 1:\n        result = undefinedToNull(params[0]);\n        break;\n\n      default:\n        result = [];\n\n        for (let i = 0; i < params.length && i < numberOfParams; i++) {\n          result.push(undefinedToNull(params[i]));\n        }\n\n        if (params.length < numberOfParams) {\n          for (let i = params.length; i < numberOfParams; i++) {\n            result.push(null);\n          }\n        }\n\n        break;\n    }\n\n    return result;\n  }\n\n  let connection = {\n    sendNotification: (type, ...params) => {\n      throwIfClosedOrDisposed();\n      let method;\n      let messageParams;\n\n      if (Is.string(type)) {\n        method = type;\n\n        switch (params.length) {\n          case 0:\n            messageParams = null;\n            break;\n\n          case 1:\n            messageParams = params[0];\n            break;\n\n          default:\n            messageParams = params;\n            break;\n        }\n      } else {\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n      }\n\n      let notificationMessage = {\n        jsonrpc: version,\n        method: method,\n        params: messageParams\n      };\n      traceSendingNotification(notificationMessage);\n      messageWriter.write(notificationMessage);\n    },\n    onNotification: (type, handler) => {\n      throwIfClosedOrDisposed();\n\n      if (Is.func(type)) {\n        starNotificationHandler = type;\n      } else if (handler) {\n        if (Is.string(type)) {\n          notificationHandlers[type] = {\n            type: undefined,\n            handler\n          };\n        } else {\n          notificationHandlers[type.method] = {\n            type,\n            handler\n          };\n        }\n      }\n    },\n    sendRequest: (type, ...params) => {\n      throwIfClosedOrDisposed();\n      throwIfNotListening();\n      let method;\n      let messageParams;\n      let token = undefined;\n\n      if (Is.string(type)) {\n        method = type;\n\n        switch (params.length) {\n          case 0:\n            messageParams = null;\n            break;\n\n          case 1:\n            // The cancellation token is optional so it can also be undefined.\n            if (cancellation_1.CancellationToken.is(params[0])) {\n              messageParams = null;\n              token = params[0];\n            } else {\n              messageParams = undefinedToNull(params[0]);\n            }\n\n            break;\n\n          default:\n            const last = params.length - 1;\n\n            if (cancellation_1.CancellationToken.is(params[last])) {\n              token = params[last];\n\n              if (params.length === 2) {\n                messageParams = undefinedToNull(params[0]);\n              } else {\n                messageParams = params.slice(0, last).map(value => undefinedToNull(value));\n              }\n            } else {\n              messageParams = params.map(value => undefinedToNull(value));\n            }\n\n            break;\n        }\n      } else {\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n        let numberOfParams = type.numberOfParams;\n        token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n      }\n\n      let id = sequenceNumber++;\n      let result = new Promise((resolve, reject) => {\n        let requestMessage = {\n          jsonrpc: version,\n          id: id,\n          method: method,\n          params: messageParams\n        };\n        let responsePromise = {\n          method: method,\n          timerStart: Date.now(),\n          resolve,\n          reject\n        };\n        traceSendingRequest(requestMessage);\n\n        try {\n          messageWriter.write(requestMessage);\n        } catch (e) {\n          // Writing the message failed. So we need to reject the promise.\n          responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\n          responsePromise = null;\n        }\n\n        if (responsePromise) {\n          responsePromises[String(id)] = responsePromise;\n        }\n      });\n\n      if (token) {\n        token.onCancellationRequested(() => {\n          connection.sendNotification(CancelNotification.type, {\n            id\n          });\n        });\n      }\n\n      return result;\n    },\n    onRequest: (type, handler) => {\n      throwIfClosedOrDisposed();\n\n      if (Is.func(type)) {\n        starRequestHandler = type;\n      } else if (handler) {\n        if (Is.string(type)) {\n          requestHandlers[type] = {\n            type: undefined,\n            handler\n          };\n        } else {\n          requestHandlers[type.method] = {\n            type,\n            handler\n          };\n        }\n      }\n    },\n    trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\n      let _sendNotification = false;\n      let _traceFormat = TraceFormat.Text;\n\n      if (sendNotificationOrTraceOptions !== void 0) {\n        if (Is.boolean(sendNotificationOrTraceOptions)) {\n          _sendNotification = sendNotificationOrTraceOptions;\n        } else {\n          _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n          _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n        }\n      }\n\n      trace = _value;\n      traceFormat = _traceFormat;\n\n      if (trace === Trace.Off) {\n        tracer = undefined;\n      } else {\n        tracer = _tracer;\n      }\n\n      if (_sendNotification && !isClosed() && !isDisposed()) {\n        connection.sendNotification(SetTraceNotification.type, {\n          value: Trace.toString(_value)\n        });\n      }\n    },\n    onError: errorEmitter.event,\n    onClose: closeEmitter.event,\n    onUnhandledNotification: unhandledNotificationEmitter.event,\n    onDispose: disposeEmitter.event,\n    dispose: () => {\n      if (isDisposed()) {\n        return;\n      }\n\n      state = ConnectionState.Disposed;\n      disposeEmitter.fire(undefined);\n      let error = new Error('Connection got disposed.');\n      Object.keys(responsePromises).forEach(key => {\n        responsePromises[key].reject(error);\n      });\n      responsePromises = Object.create(null);\n      requestTokens = Object.create(null);\n      messageQueue = new linkedMap_1.LinkedMap(); // Test for backwards compatibility\n\n      if (Is.func(messageWriter.dispose)) {\n        messageWriter.dispose();\n      }\n\n      if (Is.func(messageReader.dispose)) {\n        messageReader.dispose();\n      }\n    },\n    listen: () => {\n      throwIfClosedOrDisposed();\n      throwIfListening();\n      state = ConnectionState.Listening;\n      messageReader.listen(callback);\n    },\n    inspect: () => {\n      console.log(\"inspect\");\n    }\n  };\n  connection.onNotification(LogTraceNotification.type, params => {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n\n    tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\n  });\n  return connection;\n}\n\nfunction isMessageReader(value) {\n  return value.listen !== void 0 && value.read === void 0;\n}\n\nfunction isMessageWriter(value) {\n  return value.write !== void 0 && value.end === void 0;\n}\n\nfunction createMessageConnection(input, output, logger, strategy) {\n  if (!logger) {\n    logger = exports.NullLogger;\n  }\n\n  let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);\n  let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);\n  return _createMessageConnection(reader, writer, logger, strategy);\n}\n\nexports.createMessageConnection = createMessageConnection;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/vscode-jsonrpc/lib/main.js"],"names":["__export","m","p","exports","hasOwnProperty","Object","defineProperty","value","Is","require","messages_1","RequestType","RequestType0","RequestType1","RequestType2","RequestType3","RequestType4","RequestType5","RequestType6","RequestType7","RequestType8","RequestType9","ResponseError","ErrorCodes","NotificationType","NotificationType0","NotificationType1","NotificationType2","NotificationType3","NotificationType4","NotificationType5","NotificationType6","NotificationType7","NotificationType8","NotificationType9","messageReader_1","MessageReader","StreamMessageReader","IPCMessageReader","SocketMessageReader","messageWriter_1","MessageWriter","StreamMessageWriter","IPCMessageWriter","SocketMessageWriter","events_1","Disposable","Event","Emitter","cancellation_1","CancellationTokenSource","CancellationToken","linkedMap_1","CancelNotification","type","NullLogger","freeze","error","warn","info","log","Trace","fromString","toLowerCase","Off","Messages","Verbose","toString","TraceFormat","JSON","Text","SetTraceNotification","LogTraceNotification","ConnectionErrors","ConnectionError","Error","constructor","code","message","setPrototypeOf","prototype","ConnectionStrategy","is","candidate","func","cancelUndispatched","ConnectionState","_createMessageConnection","messageReader","messageWriter","logger","strategy","sequenceNumber","notificationSquenceNumber","unknownResponseSquenceNumber","version","starRequestHandler","undefined","requestHandlers","create","starNotificationHandler","notificationHandlers","timer","messageQueue","LinkedMap","responsePromises","requestTokens","trace","traceFormat","tracer","state","New","errorEmitter","closeEmitter","unhandledNotificationEmitter","disposeEmitter","createRequestQueueKey","id","createResponseQueueKey","createNotificationQueueKey","addMessageToQueue","queue","isRequestMessage","set","isResponseMessage","_message","isListening","Listening","isClosed","Closed","isDisposed","Disposed","closeHandler","fire","readErrorHandler","writeErrorHandler","data","onClose","onError","triggerMessageQueue","size","setImmediate","processMessageQueue","shift","handleRequest","isNotificationMessage","handleNotification","handleResponse","handleInvalidMessage","callback","method","key","params","toCancel","get","response","result","delete","traceSendingResponse","Date","now","write","requestMessage","reply","resultOrError","startTime","jsonrpc","toJson","replyError","replySuccess","traceReceivedRequest","element","requestHandler","handler","cancellationSource","tokenKey","String","handlerResult","numberOfParams","token","array","promise","then","string","InternalError","MethodNotFound","responseMessage","stringify","responsePromise","traceReceivedResponse","reject","resolve","notificationHandler","source","cancel","traceReceivedNotification","number","responseHandler","traceSendingRequest","logLSPMessage","traceSendingNotification","timerStart","lspMessage","isLSPMessage","timestamp","throwIfClosedOrDisposed","throwIfListening","AlreadyListening","throwIfNotListening","undefinedToNull","param","computeMessageParams","i","length","push","connection","sendNotification","messageParams","notificationMessage","onNotification","sendRequest","last","slice","map","Promise","e","MessageWriteError","onCancellationRequested","onRequest","_value","_tracer","sendNotificationOrTraceOptions","_sendNotification","_traceFormat","boolean","event","onUnhandledNotification","onDispose","dispose","keys","forEach","listen","inspect","console","verbose","isMessageReader","read","isMessageWriter","end","createMessageConnection","input","output","reader","writer"],"mappings":"AAAA;;;;AAIA;AACA;;AACA,SAASA,QAAT,CAAkBC,CAAlB,EAAqB;AACjB,OAAK,IAAIC,CAAT,IAAcD,CAAd,EAAiB,IAAI,CAACE,OAAO,CAACC,cAAR,CAAuBF,CAAvB,CAAL,EAAgCC,OAAO,CAACD,CAAD,CAAP,GAAaD,CAAC,CAACC,CAAD,CAAd;AACpD;;AACDG,MAAM,CAACC,cAAP,CAAsBH,OAAtB,EAA+B,YAA/B,EAA6C;AAAEI,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACAN,OAAO,CAACQ,WAAR,GAAsBD,UAAU,CAACC,WAAjC;AACAR,OAAO,CAACS,YAAR,GAAuBF,UAAU,CAACE,YAAlC;AACAT,OAAO,CAACU,YAAR,GAAuBH,UAAU,CAACG,YAAlC;AACAV,OAAO,CAACW,YAAR,GAAuBJ,UAAU,CAACI,YAAlC;AACAX,OAAO,CAACY,YAAR,GAAuBL,UAAU,CAACK,YAAlC;AACAZ,OAAO,CAACa,YAAR,GAAuBN,UAAU,CAACM,YAAlC;AACAb,OAAO,CAACc,YAAR,GAAuBP,UAAU,CAACO,YAAlC;AACAd,OAAO,CAACe,YAAR,GAAuBR,UAAU,CAACQ,YAAlC;AACAf,OAAO,CAACgB,YAAR,GAAuBT,UAAU,CAACS,YAAlC;AACAhB,OAAO,CAACiB,YAAR,GAAuBV,UAAU,CAACU,YAAlC;AACAjB,OAAO,CAACkB,YAAR,GAAuBX,UAAU,CAACW,YAAlC;AACAlB,OAAO,CAACmB,aAAR,GAAwBZ,UAAU,CAACY,aAAnC;AACAnB,OAAO,CAACoB,UAAR,GAAqBb,UAAU,CAACa,UAAhC;AACApB,OAAO,CAACqB,gBAAR,GAA2Bd,UAAU,CAACc,gBAAtC;AACArB,OAAO,CAACsB,iBAAR,GAA4Bf,UAAU,CAACe,iBAAvC;AACAtB,OAAO,CAACuB,iBAAR,GAA4BhB,UAAU,CAACgB,iBAAvC;AACAvB,OAAO,CAACwB,iBAAR,GAA4BjB,UAAU,CAACiB,iBAAvC;AACAxB,OAAO,CAACyB,iBAAR,GAA4BlB,UAAU,CAACkB,iBAAvC;AACAzB,OAAO,CAAC0B,iBAAR,GAA4BnB,UAAU,CAACmB,iBAAvC;AACA1B,OAAO,CAAC2B,iBAAR,GAA4BpB,UAAU,CAACoB,iBAAvC;AACA3B,OAAO,CAAC4B,iBAAR,GAA4BrB,UAAU,CAACqB,iBAAvC;AACA5B,OAAO,CAAC6B,iBAAR,GAA4BtB,UAAU,CAACsB,iBAAvC;AACA7B,OAAO,CAAC8B,iBAAR,GAA4BvB,UAAU,CAACuB,iBAAvC;AACA9B,OAAO,CAAC+B,iBAAR,GAA4BxB,UAAU,CAACwB,iBAAvC;;AACA,MAAMC,eAAe,GAAG1B,OAAO,CAAC,iBAAD,CAA/B;;AACAN,OAAO,CAACiC,aAAR,GAAwBD,eAAe,CAACC,aAAxC;AACAjC,OAAO,CAACkC,mBAAR,GAA8BF,eAAe,CAACE,mBAA9C;AACAlC,OAAO,CAACmC,gBAAR,GAA2BH,eAAe,CAACG,gBAA3C;AACAnC,OAAO,CAACoC,mBAAR,GAA8BJ,eAAe,CAACI,mBAA9C;;AACA,MAAMC,eAAe,GAAG/B,OAAO,CAAC,iBAAD,CAA/B;;AACAN,OAAO,CAACsC,aAAR,GAAwBD,eAAe,CAACC,aAAxC;AACAtC,OAAO,CAACuC,mBAAR,GAA8BF,eAAe,CAACE,mBAA9C;AACAvC,OAAO,CAACwC,gBAAR,GAA2BH,eAAe,CAACG,gBAA3C;AACAxC,OAAO,CAACyC,mBAAR,GAA8BJ,eAAe,CAACI,mBAA9C;;AACA,MAAMC,QAAQ,GAAGpC,OAAO,CAAC,UAAD,CAAxB;;AACAN,OAAO,CAAC2C,UAAR,GAAqBD,QAAQ,CAACC,UAA9B;AACA3C,OAAO,CAAC4C,KAAR,GAAgBF,QAAQ,CAACE,KAAzB;AACA5C,OAAO,CAAC6C,OAAR,GAAkBH,QAAQ,CAACG,OAA3B;;AACA,MAAMC,cAAc,GAAGxC,OAAO,CAAC,gBAAD,CAA9B;;AACAN,OAAO,CAAC+C,uBAAR,GAAkCD,cAAc,CAACC,uBAAjD;AACA/C,OAAO,CAACgD,iBAAR,GAA4BF,cAAc,CAACE,iBAA3C;;AACA,MAAMC,WAAW,GAAG3C,OAAO,CAAC,aAAD,CAA3B;;AACAT,QAAQ,CAACS,OAAO,CAAC,eAAD,CAAR,CAAR;;AACAT,QAAQ,CAACS,OAAO,CAAC,iBAAD,CAAR,CAAR;;AACA,IAAI4C,kBAAJ;;AACA,CAAC,UAAUA,kBAAV,EAA8B;AAC3BA,EAAAA,kBAAkB,CAACC,IAAnB,GAA0B,IAAI5C,UAAU,CAACc,gBAAf,CAAgC,iBAAhC,CAA1B;AACH,CAFD,EAEG6B,kBAAkB,KAAKA,kBAAkB,GAAG,EAA1B,CAFrB;;AAGAlD,OAAO,CAACoD,UAAR,GAAqBlD,MAAM,CAACmD,MAAP,CAAc;AAC/BC,EAAAA,KAAK,EAAE,MAAM,CAAG,CADe;AAE/BC,EAAAA,IAAI,EAAE,MAAM,CAAG,CAFgB;AAG/BC,EAAAA,IAAI,EAAE,MAAM,CAAG,CAHgB;AAI/BC,EAAAA,GAAG,EAAE,MAAM,CAAG;AAJiB,CAAd,CAArB;AAMA,IAAIC,KAAJ;;AACA,CAAC,UAAUA,KAAV,EAAiB;AACdA,EAAAA,KAAK,CAACA,KAAK,CAAC,KAAD,CAAL,GAAe,CAAhB,CAAL,GAA0B,KAA1B;AACAA,EAAAA,KAAK,CAACA,KAAK,CAAC,UAAD,CAAL,GAAoB,CAArB,CAAL,GAA+B,UAA/B;AACAA,EAAAA,KAAK,CAACA,KAAK,CAAC,SAAD,CAAL,GAAmB,CAApB,CAAL,GAA8B,SAA9B;AACH,CAJD,EAIGA,KAAK,GAAG1D,OAAO,CAAC0D,KAAR,KAAkB1D,OAAO,CAAC0D,KAAR,GAAgB,EAAlC,CAJX;;AAKA,CAAC,UAAUA,KAAV,EAAiB;AACd,WAASC,UAAT,CAAoBvD,KAApB,EAA2B;AACvBA,IAAAA,KAAK,GAAGA,KAAK,CAACwD,WAAN,EAAR;;AACA,YAAQxD,KAAR;AACI,WAAK,KAAL;AACI,eAAOsD,KAAK,CAACG,GAAb;;AACJ,WAAK,UAAL;AACI,eAAOH,KAAK,CAACI,QAAb;;AACJ,WAAK,SAAL;AACI,eAAOJ,KAAK,CAACK,OAAb;;AACJ;AACI,eAAOL,KAAK,CAACG,GAAb;AARR;AAUH;;AACDH,EAAAA,KAAK,CAACC,UAAN,GAAmBA,UAAnB;;AACA,WAASK,QAAT,CAAkB5D,KAAlB,EAAyB;AACrB,YAAQA,KAAR;AACI,WAAKsD,KAAK,CAACG,GAAX;AACI,eAAO,KAAP;;AACJ,WAAKH,KAAK,CAACI,QAAX;AACI,eAAO,UAAP;;AACJ,WAAKJ,KAAK,CAACK,OAAX;AACI,eAAO,SAAP;;AACJ;AACI,eAAO,KAAP;AARR;AAUH;;AACDL,EAAAA,KAAK,CAACM,QAAN,GAAiBA,QAAjB;AACH,CA5BD,EA4BGN,KAAK,GAAG1D,OAAO,CAAC0D,KAAR,KAAkB1D,OAAO,CAAC0D,KAAR,GAAgB,EAAlC,CA5BX;;AA6BA,IAAIO,WAAJ;;AACA,CAAC,UAAUA,WAAV,EAAuB;AACpBA,EAAAA,WAAW,CAAC,MAAD,CAAX,GAAsB,MAAtB;AACAA,EAAAA,WAAW,CAAC,MAAD,CAAX,GAAsB,MAAtB;AACH,CAHD,EAGGA,WAAW,GAAGjE,OAAO,CAACiE,WAAR,KAAwBjE,OAAO,CAACiE,WAAR,GAAsB,EAA9C,CAHjB;;AAIA,CAAC,UAAUA,WAAV,EAAuB;AACpB,WAASN,UAAT,CAAoBvD,KAApB,EAA2B;AACvBA,IAAAA,KAAK,GAAGA,KAAK,CAACwD,WAAN,EAAR;;AACA,QAAIxD,KAAK,KAAK,MAAd,EAAsB;AAClB,aAAO6D,WAAW,CAACC,IAAnB;AACH,KAFD,MAGK;AACD,aAAOD,WAAW,CAACE,IAAnB;AACH;AACJ;;AACDF,EAAAA,WAAW,CAACN,UAAZ,GAAyBA,UAAzB;AACH,CAXD,EAWGM,WAAW,GAAGjE,OAAO,CAACiE,WAAR,KAAwBjE,OAAO,CAACiE,WAAR,GAAsB,EAA9C,CAXjB;;AAYA,IAAIG,oBAAJ;;AACA,CAAC,UAAUA,oBAAV,EAAgC;AAC7BA,EAAAA,oBAAoB,CAACjB,IAArB,GAA4B,IAAI5C,UAAU,CAACc,gBAAf,CAAgC,wBAAhC,CAA5B;AACH,CAFD,EAEG+C,oBAAoB,GAAGpE,OAAO,CAACoE,oBAAR,KAAiCpE,OAAO,CAACoE,oBAAR,GAA+B,EAAhE,CAF1B;;AAGA,IAAIC,oBAAJ;;AACA,CAAC,UAAUA,oBAAV,EAAgC;AAC7BA,EAAAA,oBAAoB,CAAClB,IAArB,GAA4B,IAAI5C,UAAU,CAACc,gBAAf,CAAgC,wBAAhC,CAA5B;AACH,CAFD,EAEGgD,oBAAoB,GAAGrE,OAAO,CAACqE,oBAAR,KAAiCrE,OAAO,CAACqE,oBAAR,GAA+B,EAAhE,CAF1B;;AAGA,IAAIC,gBAAJ;;AACA,CAAC,UAAUA,gBAAV,EAA4B;AACzB;;;AAGAA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,QAAD,CAAhB,GAA6B,CAA9B,CAAhB,GAAmD,QAAnD;AACA;;;;AAGAA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,UAAD,CAAhB,GAA+B,CAAhC,CAAhB,GAAqD,UAArD;AACA;;;;AAGAA,EAAAA,gBAAgB,CAACA,gBAAgB,CAAC,kBAAD,CAAhB,GAAuC,CAAxC,CAAhB,GAA6D,kBAA7D;AACH,CAbD,EAaGA,gBAAgB,GAAGtE,OAAO,CAACsE,gBAAR,KAA6BtE,OAAO,CAACsE,gBAAR,GAA2B,EAAxD,CAbtB;;AAcA,MAAMC,eAAN,SAA8BC,KAA9B,CAAoC;AAChCC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACvB,UAAMA,OAAN;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACAxE,IAAAA,MAAM,CAAC0E,cAAP,CAAsB,IAAtB,EAA4BL,eAAe,CAACM,SAA5C;AACH;;AAL+B;;AAOpC7E,OAAO,CAACuE,eAAR,GAA0BA,eAA1B;AACA,IAAIO,kBAAJ;;AACA,CAAC,UAAUA,kBAAV,EAA8B;AAC3B,WAASC,EAAT,CAAY3E,KAAZ,EAAmB;AACf,QAAI4E,SAAS,GAAG5E,KAAhB;AACA,WAAO4E,SAAS,IAAI3E,EAAE,CAAC4E,IAAH,CAAQD,SAAS,CAACE,kBAAlB,CAApB;AACH;;AACDJ,EAAAA,kBAAkB,CAACC,EAAnB,GAAwBA,EAAxB;AACH,CAND,EAMGD,kBAAkB,GAAG9E,OAAO,CAAC8E,kBAAR,KAA+B9E,OAAO,CAAC8E,kBAAR,GAA6B,EAA5D,CANxB;;AAOA,IAAIK,eAAJ;;AACA,CAAC,UAAUA,eAAV,EAA2B;AACxBA,EAAAA,eAAe,CAACA,eAAe,CAAC,KAAD,CAAf,GAAyB,CAA1B,CAAf,GAA8C,KAA9C;AACAA,EAAAA,eAAe,CAACA,eAAe,CAAC,WAAD,CAAf,GAA+B,CAAhC,CAAf,GAAoD,WAApD;AACAA,EAAAA,eAAe,CAACA,eAAe,CAAC,QAAD,CAAf,GAA4B,CAA7B,CAAf,GAAiD,QAAjD;AACAA,EAAAA,eAAe,CAACA,eAAe,CAAC,UAAD,CAAf,GAA8B,CAA/B,CAAf,GAAmD,UAAnD;AACH,CALD,EAKGA,eAAe,KAAKA,eAAe,GAAG,EAAvB,CALlB;;AAMA,SAASC,wBAAT,CAAkCC,aAAlC,EAAiDC,aAAjD,EAAgEC,MAAhE,EAAwEC,QAAxE,EAAkF;AAC9E,MAAIC,cAAc,GAAG,CAArB;AACA,MAAIC,yBAAyB,GAAG,CAAhC;AACA,MAAIC,4BAA4B,GAAG,CAAnC;AACA,QAAMC,OAAO,GAAG,KAAhB;AACA,MAAIC,kBAAkB,GAAGC,SAAzB;AACA,MAAIC,eAAe,GAAG7F,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAAtB;AACA,MAAIC,uBAAuB,GAAGH,SAA9B;AACA,MAAII,oBAAoB,GAAGhG,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAA3B;AACA,MAAIG,KAAJ;AACA,MAAIC,YAAY,GAAG,IAAInD,WAAW,CAACoD,SAAhB,EAAnB;AACA,MAAIC,gBAAgB,GAAGpG,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAAvB;AACA,MAAIO,aAAa,GAAGrG,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAApB;AACA,MAAIQ,KAAK,GAAG9C,KAAK,CAACG,GAAlB;AACA,MAAI4C,WAAW,GAAGxC,WAAW,CAACE,IAA9B;AACA,MAAIuC,MAAJ;AACA,MAAIC,KAAK,GAAGxB,eAAe,CAACyB,GAA5B;AACA,MAAIC,YAAY,GAAG,IAAInE,QAAQ,CAACG,OAAb,EAAnB;AACA,MAAIiE,YAAY,GAAG,IAAIpE,QAAQ,CAACG,OAAb,EAAnB;AACA,MAAIkE,4BAA4B,GAAG,IAAIrE,QAAQ,CAACG,OAAb,EAAnC;AACA,MAAImE,cAAc,GAAG,IAAItE,QAAQ,CAACG,OAAb,EAArB;;AACA,WAASoE,qBAAT,CAA+BC,EAA/B,EAAmC;AAC/B,WAAO,SAASA,EAAE,CAAClD,QAAH,EAAhB;AACH;;AACD,WAASmD,sBAAT,CAAgCD,EAAhC,EAAoC;AAChC,QAAIA,EAAE,KAAK,IAAX,EAAiB;AACb,aAAO,iBAAiB,CAAC,EAAEvB,4BAAH,EAAiC3B,QAAjC,EAAxB;AACH,KAFD,MAGK;AACD,aAAO,SAASkD,EAAE,CAAClD,QAAH,EAAhB;AACH;AACJ;;AACD,WAASoD,0BAAT,GAAsC;AAClC,WAAO,SAAS,CAAC,EAAE1B,yBAAH,EAA8B1B,QAA9B,EAAhB;AACH;;AACD,WAASqD,iBAAT,CAA2BC,KAA3B,EAAkC3C,OAAlC,EAA2C;AACvC,QAAIpE,UAAU,CAACgH,gBAAX,CAA4B5C,OAA5B,CAAJ,EAA0C;AACtC2C,MAAAA,KAAK,CAACE,GAAN,CAAUP,qBAAqB,CAACtC,OAAO,CAACuC,EAAT,CAA/B,EAA6CvC,OAA7C;AACH,KAFD,MAGK,IAAIpE,UAAU,CAACkH,iBAAX,CAA6B9C,OAA7B,CAAJ,EAA2C;AAC5C2C,MAAAA,KAAK,CAACE,GAAN,CAAUL,sBAAsB,CAACxC,OAAO,CAACuC,EAAT,CAAhC,EAA8CvC,OAA9C;AACH,KAFI,MAGA;AACD2C,MAAAA,KAAK,CAACE,GAAN,CAAUJ,0BAA0B,EAApC,EAAwCzC,OAAxC;AACH;AACJ;;AACD,WAASO,kBAAT,CAA4BwC,QAA5B,EAAsC;AAClC,WAAO5B,SAAP;AACH;;AACD,WAAS6B,WAAT,GAAuB;AACnB,WAAOhB,KAAK,KAAKxB,eAAe,CAACyC,SAAjC;AACH;;AACD,WAASC,QAAT,GAAoB;AAChB,WAAOlB,KAAK,KAAKxB,eAAe,CAAC2C,MAAjC;AACH;;AACD,WAASC,UAAT,GAAsB;AAClB,WAAOpB,KAAK,KAAKxB,eAAe,CAAC6C,QAAjC;AACH;;AACD,WAASC,YAAT,GAAwB;AACpB,QAAItB,KAAK,KAAKxB,eAAe,CAACyB,GAA1B,IAAiCD,KAAK,KAAKxB,eAAe,CAACyC,SAA/D,EAA0E;AACtEjB,MAAAA,KAAK,GAAGxB,eAAe,CAAC2C,MAAxB;AACAhB,MAAAA,YAAY,CAACoB,IAAb,CAAkBpC,SAAlB;AACH,KAJmB,CAKpB;;AACH;;AACD;;AACA,WAASqC,gBAAT,CAA0B7E,KAA1B,EAAiC;AAC7BuD,IAAAA,YAAY,CAACqB,IAAb,CAAkB,CAAC5E,KAAD,EAAQwC,SAAR,EAAmBA,SAAnB,CAAlB;AACH;;AACD,WAASsC,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7BxB,IAAAA,YAAY,CAACqB,IAAb,CAAkBG,IAAlB;AACH;;AACDhD,EAAAA,aAAa,CAACiD,OAAd,CAAsBL,YAAtB;AACA5C,EAAAA,aAAa,CAACkD,OAAd,CAAsBJ,gBAAtB;AACA7C,EAAAA,aAAa,CAACgD,OAAd,CAAsBL,YAAtB;AACA3C,EAAAA,aAAa,CAACiD,OAAd,CAAsBH,iBAAtB;;AACA,WAASI,mBAAT,GAA+B;AAC3B,QAAIrC,KAAK,IAAIC,YAAY,CAACqC,IAAb,KAAsB,CAAnC,EAAsC;AAClC;AACH;;AACDtC,IAAAA,KAAK,GAAGuC,YAAY,CAAC,MAAM;AACvBvC,MAAAA,KAAK,GAAGL,SAAR;AACA6C,MAAAA,mBAAmB;AACtB,KAHmB,CAApB;AAIH;;AACD,WAASA,mBAAT,GAA+B;AAC3B,QAAIvC,YAAY,CAACqC,IAAb,KAAsB,CAA1B,EAA6B;AACzB;AACH;;AACD,QAAI9D,OAAO,GAAGyB,YAAY,CAACwC,KAAb,EAAd;;AACA,QAAI;AACA,UAAIrI,UAAU,CAACgH,gBAAX,CAA4B5C,OAA5B,CAAJ,EAA0C;AACtCkE,QAAAA,aAAa,CAAClE,OAAD,CAAb;AACH,OAFD,MAGK,IAAIpE,UAAU,CAACuI,qBAAX,CAAiCnE,OAAjC,CAAJ,EAA+C;AAChDoE,QAAAA,kBAAkB,CAACpE,OAAD,CAAlB;AACH,OAFI,MAGA,IAAIpE,UAAU,CAACkH,iBAAX,CAA6B9C,OAA7B,CAAJ,EAA2C;AAC5CqE,QAAAA,cAAc,CAACrE,OAAD,CAAd;AACH,OAFI,MAGA;AACDsE,QAAAA,oBAAoB,CAACtE,OAAD,CAApB;AACH;AACJ,KAbD,SAcQ;AACJ6D,MAAAA,mBAAmB;AACtB;AACJ;;AACD,MAAIU,QAAQ,GAAIvE,OAAD,IAAa;AACxB,QAAI;AACA;AACA;AACA,UAAIpE,UAAU,CAACuI,qBAAX,CAAiCnE,OAAjC,KAA6CA,OAAO,CAACwE,MAAR,KAAmBjG,kBAAkB,CAACC,IAAnB,CAAwBgG,MAA5F,EAAoG;AAChG,YAAIC,GAAG,GAAGnC,qBAAqB,CAACtC,OAAO,CAAC0E,MAAR,CAAenC,EAAhB,CAA/B;AACA,YAAIoC,QAAQ,GAAGlD,YAAY,CAACmD,GAAb,CAAiBH,GAAjB,CAAf;;AACA,YAAI7I,UAAU,CAACgH,gBAAX,CAA4B+B,QAA5B,CAAJ,EAA2C;AACvC,cAAIE,QAAQ,GAAGhE,QAAQ,IAAIA,QAAQ,CAACN,kBAArB,GAA0CM,QAAQ,CAACN,kBAAT,CAA4BoE,QAA5B,EAAsCpE,kBAAtC,CAA1C,GAAsGA,kBAAkB,CAACoE,QAAD,CAAvI;;AACA,cAAIE,QAAQ,KAAKA,QAAQ,CAAClG,KAAT,KAAmB,KAAK,CAAxB,IAA6BkG,QAAQ,CAACC,MAAT,KAAoB,KAAK,CAA3D,CAAZ,EAA2E;AACvErD,YAAAA,YAAY,CAACsD,MAAb,CAAoBN,GAApB;AACAI,YAAAA,QAAQ,CAACtC,EAAT,GAAcoC,QAAQ,CAACpC,EAAvB;AACAyC,YAAAA,oBAAoB,CAACH,QAAD,EAAW7E,OAAO,CAACwE,MAAnB,EAA2BS,IAAI,CAACC,GAAL,EAA3B,CAApB;AACAvE,YAAAA,aAAa,CAACwE,KAAd,CAAoBN,QAApB;AACA;AACH;AACJ;AACJ;;AACDnC,MAAAA,iBAAiB,CAACjB,YAAD,EAAezB,OAAf,CAAjB;AACH,KAlBD,SAmBQ;AACJ6D,MAAAA,mBAAmB;AACtB;AACJ,GAvBD;;AAwBA,WAASK,aAAT,CAAuBkB,cAAvB,EAAuC;AACnC,QAAIhC,UAAU,EAAd,EAAkB;AACd;AACA;AACA;AACH;;AACD,aAASiC,KAAT,CAAeC,aAAf,EAA8Bd,MAA9B,EAAsCe,SAAtC,EAAiD;AAC7C,UAAIvF,OAAO,GAAG;AACVwF,QAAAA,OAAO,EAAEvE,OADC;AAEVsB,QAAAA,EAAE,EAAE6C,cAAc,CAAC7C;AAFT,OAAd;;AAIA,UAAI+C,aAAa,YAAY1J,UAAU,CAACY,aAAxC,EAAuD;AACnDwD,QAAAA,OAAO,CAACrB,KAAR,GAAgB2G,aAAa,CAACG,MAAd,EAAhB;AACH,OAFD,MAGK;AACDzF,QAAAA,OAAO,CAAC8E,MAAR,GAAiBQ,aAAa,KAAK,KAAK,CAAvB,GAA2B,IAA3B,GAAkCA,aAAnD;AACH;;AACDN,MAAAA,oBAAoB,CAAChF,OAAD,EAAUwE,MAAV,EAAkBe,SAAlB,CAApB;AACA5E,MAAAA,aAAa,CAACwE,KAAd,CAAoBnF,OAApB;AACH;;AACD,aAAS0F,UAAT,CAAoB/G,KAApB,EAA2B6F,MAA3B,EAAmCe,SAAnC,EAA8C;AAC1C,UAAIvF,OAAO,GAAG;AACVwF,QAAAA,OAAO,EAAEvE,OADC;AAEVsB,QAAAA,EAAE,EAAE6C,cAAc,CAAC7C,EAFT;AAGV5D,QAAAA,KAAK,EAAEA,KAAK,CAAC8G,MAAN;AAHG,OAAd;AAKAT,MAAAA,oBAAoB,CAAChF,OAAD,EAAUwE,MAAV,EAAkBe,SAAlB,CAApB;AACA5E,MAAAA,aAAa,CAACwE,KAAd,CAAoBnF,OAApB;AACH;;AACD,aAAS2F,YAAT,CAAsBb,MAAtB,EAA8BN,MAA9B,EAAsCe,SAAtC,EAAiD;AAC7C;AACA;AACA,UAAIT,MAAM,KAAK,KAAK,CAApB,EAAuB;AACnBA,QAAAA,MAAM,GAAG,IAAT;AACH;;AACD,UAAI9E,OAAO,GAAG;AACVwF,QAAAA,OAAO,EAAEvE,OADC;AAEVsB,QAAAA,EAAE,EAAE6C,cAAc,CAAC7C,EAFT;AAGVuC,QAAAA,MAAM,EAAEA;AAHE,OAAd;AAKAE,MAAAA,oBAAoB,CAAChF,OAAD,EAAUwE,MAAV,EAAkBe,SAAlB,CAApB;AACA5E,MAAAA,aAAa,CAACwE,KAAd,CAAoBnF,OAApB;AACH;;AACD4F,IAAAA,oBAAoB,CAACR,cAAD,CAApB;AACA,QAAIS,OAAO,GAAGzE,eAAe,CAACgE,cAAc,CAACZ,MAAhB,CAA7B;AACA,QAAIhG,IAAJ;AACA,QAAIsH,cAAJ;;AACA,QAAID,OAAJ,EAAa;AACTrH,MAAAA,IAAI,GAAGqH,OAAO,CAACrH,IAAf;AACAsH,MAAAA,cAAc,GAAGD,OAAO,CAACE,OAAzB;AACH;;AACD,QAAIR,SAAS,GAAGN,IAAI,CAACC,GAAL,EAAhB;;AACA,QAAIY,cAAc,IAAI5E,kBAAtB,EAA0C;AACtC,UAAI8E,kBAAkB,GAAG,IAAI7H,cAAc,CAACC,uBAAnB,EAAzB;AACA,UAAI6H,QAAQ,GAAGC,MAAM,CAACd,cAAc,CAAC7C,EAAhB,CAArB;AACAX,MAAAA,aAAa,CAACqE,QAAD,CAAb,GAA0BD,kBAA1B;;AACA,UAAI;AACA,YAAIG,aAAJ;;AACA,YAAIf,cAAc,CAACV,MAAf,KAA0B,KAAK,CAA/B,IAAqClG,IAAI,KAAK,KAAK,CAAd,IAAmBA,IAAI,CAAC4H,cAAL,KAAwB,CAApF,EAAwF;AACpFD,UAAAA,aAAa,GAAGL,cAAc,GACxBA,cAAc,CAACE,kBAAkB,CAACK,KAApB,CADU,GAExBnF,kBAAkB,CAACkE,cAAc,CAACZ,MAAhB,EAAwBwB,kBAAkB,CAACK,KAA3C,CAFxB;AAGH,SAJD,MAKK,IAAI3K,EAAE,CAAC4K,KAAH,CAASlB,cAAc,CAACV,MAAxB,MAAoClG,IAAI,KAAK,KAAK,CAAd,IAAmBA,IAAI,CAAC4H,cAAL,GAAsB,CAA7E,CAAJ,EAAqF;AACtFD,UAAAA,aAAa,GAAGL,cAAc,GACxBA,cAAc,CAAC,GAAGV,cAAc,CAACV,MAAnB,EAA2BsB,kBAAkB,CAACK,KAA9C,CADU,GAExBnF,kBAAkB,CAACkE,cAAc,CAACZ,MAAhB,EAAwB,GAAGY,cAAc,CAACV,MAA1C,EAAkDsB,kBAAkB,CAACK,KAArE,CAFxB;AAGH,SAJI,MAKA;AACDF,UAAAA,aAAa,GAAGL,cAAc,GACxBA,cAAc,CAACV,cAAc,CAACV,MAAhB,EAAwBsB,kBAAkB,CAACK,KAA3C,CADU,GAExBnF,kBAAkB,CAACkE,cAAc,CAACZ,MAAhB,EAAwBY,cAAc,CAACV,MAAvC,EAA+CsB,kBAAkB,CAACK,KAAlE,CAFxB;AAGH;;AACD,YAAIE,OAAO,GAAGJ,aAAd;;AACA,YAAI,CAACA,aAAL,EAAoB;AAChB,iBAAOvE,aAAa,CAACqE,QAAD,CAApB;AACAN,UAAAA,YAAY,CAACQ,aAAD,EAAgBf,cAAc,CAACZ,MAA/B,EAAuCe,SAAvC,CAAZ;AACH,SAHD,MAIK,IAAIgB,OAAO,CAACC,IAAZ,EAAkB;AACnBD,UAAAA,OAAO,CAACC,IAAR,CAAclB,aAAD,IAAmB;AAC5B,mBAAO1D,aAAa,CAACqE,QAAD,CAApB;AACAZ,YAAAA,KAAK,CAACC,aAAD,EAAgBF,cAAc,CAACZ,MAA/B,EAAuCe,SAAvC,CAAL;AACH,WAHD,EAGG5G,KAAK,IAAI;AACR,mBAAOiD,aAAa,CAACqE,QAAD,CAApB;;AACA,gBAAItH,KAAK,YAAY/C,UAAU,CAACY,aAAhC,EAA+C;AAC3CkJ,cAAAA,UAAU,CAAC/G,KAAD,EAAQyG,cAAc,CAACZ,MAAvB,EAA+Be,SAA/B,CAAV;AACH,aAFD,MAGK,IAAI5G,KAAK,IAAIjD,EAAE,CAAC+K,MAAH,CAAU9H,KAAK,CAACqB,OAAhB,CAAb,EAAuC;AACxC0F,cAAAA,UAAU,CAAC,IAAI9J,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsBiK,aAAnD,EAAmE,WAAUtB,cAAc,CAACZ,MAAO,yBAAwB7F,KAAK,CAACqB,OAAQ,EAAzI,CAAD,EAA8IoF,cAAc,CAACZ,MAA7J,EAAqKe,SAArK,CAAV;AACH,aAFI,MAGA;AACDG,cAAAA,UAAU,CAAC,IAAI9J,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsBiK,aAAnD,EAAmE,WAAUtB,cAAc,CAACZ,MAAO,qDAAnG,CAAD,EAA2JY,cAAc,CAACZ,MAA1K,EAAkLe,SAAlL,CAAV;AACH;AACJ,WAdD;AAeH,SAhBI,MAiBA;AACD,iBAAO3D,aAAa,CAACqE,QAAD,CAApB;AACAZ,UAAAA,KAAK,CAACc,aAAD,EAAgBf,cAAc,CAACZ,MAA/B,EAAuCe,SAAvC,CAAL;AACH;AACJ,OA3CD,CA4CA,OAAO5G,KAAP,EAAc;AACV,eAAOiD,aAAa,CAACqE,QAAD,CAApB;;AACA,YAAItH,KAAK,YAAY/C,UAAU,CAACY,aAAhC,EAA+C;AAC3C6I,UAAAA,KAAK,CAAC1G,KAAD,EAAQyG,cAAc,CAACZ,MAAvB,EAA+Be,SAA/B,CAAL;AACH,SAFD,MAGK,IAAI5G,KAAK,IAAIjD,EAAE,CAAC+K,MAAH,CAAU9H,KAAK,CAACqB,OAAhB,CAAb,EAAuC;AACxC0F,UAAAA,UAAU,CAAC,IAAI9J,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsBiK,aAAnD,EAAmE,WAAUtB,cAAc,CAACZ,MAAO,yBAAwB7F,KAAK,CAACqB,OAAQ,EAAzI,CAAD,EAA8IoF,cAAc,CAACZ,MAA7J,EAAqKe,SAArK,CAAV;AACH,SAFI,MAGA;AACDG,UAAAA,UAAU,CAAC,IAAI9J,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsBiK,aAAnD,EAAmE,WAAUtB,cAAc,CAACZ,MAAO,qDAAnG,CAAD,EAA2JY,cAAc,CAACZ,MAA1K,EAAkLe,SAAlL,CAAV;AACH;AACJ;AACJ,KA5DD,MA6DK;AACDG,MAAAA,UAAU,CAAC,IAAI9J,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsBkK,cAAnD,EAAoE,oBAAmBvB,cAAc,CAACZ,MAAO,EAA7G,CAAD,EAAkHY,cAAc,CAACZ,MAAjI,EAAyIe,SAAzI,CAAV;AACH;AACJ;;AACD,WAASlB,cAAT,CAAwBuC,eAAxB,EAAyC;AACrC,QAAIxD,UAAU,EAAd,EAAkB;AACd;AACA;AACH;;AACD,QAAIwD,eAAe,CAACrE,EAAhB,KAAuB,IAA3B,EAAiC;AAC7B,UAAIqE,eAAe,CAACjI,KAApB,EAA2B;AACvBiC,QAAAA,MAAM,CAACjC,KAAP,CAAc,qDAAoDY,IAAI,CAACsH,SAAL,CAAeD,eAAe,CAACjI,KAA/B,EAAsCwC,SAAtC,EAAiD,CAAjD,CAAoD,EAAtH;AACH,OAFD,MAGK;AACDP,QAAAA,MAAM,CAACjC,KAAP,CAAc,8EAAd;AACH;AACJ,KAPD,MAQK;AACD,UAAI8F,GAAG,GAAGyB,MAAM,CAACU,eAAe,CAACrE,EAAjB,CAAhB;AACA,UAAIuE,eAAe,GAAGnF,gBAAgB,CAAC8C,GAAD,CAAtC;AACAsC,MAAAA,qBAAqB,CAACH,eAAD,EAAkBE,eAAlB,CAArB;;AACA,UAAIA,eAAJ,EAAqB;AACjB,eAAOnF,gBAAgB,CAAC8C,GAAD,CAAvB;;AACA,YAAI;AACA,cAAImC,eAAe,CAACjI,KAApB,EAA2B;AACvB,gBAAIA,KAAK,GAAGiI,eAAe,CAACjI,KAA5B;AACAmI,YAAAA,eAAe,CAACE,MAAhB,CAAuB,IAAIpL,UAAU,CAACY,aAAf,CAA6BmC,KAAK,CAACoB,IAAnC,EAAyCpB,KAAK,CAACqB,OAA/C,EAAwDrB,KAAK,CAAC+E,IAA9D,CAAvB;AACH,WAHD,MAIK,IAAIkD,eAAe,CAAC9B,MAAhB,KAA2B,KAAK,CAApC,EAAuC;AACxCgC,YAAAA,eAAe,CAACG,OAAhB,CAAwBL,eAAe,CAAC9B,MAAxC;AACH,WAFI,MAGA;AACD,kBAAM,IAAIjF,KAAJ,CAAU,sBAAV,CAAN;AACH;AACJ,SAXD,CAYA,OAAOlB,KAAP,EAAc;AACV,cAAIA,KAAK,CAACqB,OAAV,EAAmB;AACfY,YAAAA,MAAM,CAACjC,KAAP,CAAc,qBAAoBmI,eAAe,CAACtC,MAAO,0BAAyB7F,KAAK,CAACqB,OAAQ,EAAhG;AACH,WAFD,MAGK;AACDY,YAAAA,MAAM,CAACjC,KAAP,CAAc,qBAAoBmI,eAAe,CAACtC,MAAO,wBAAzD;AACH;AACJ;AACJ;AACJ;AACJ;;AACD,WAASJ,kBAAT,CAA4BpE,OAA5B,EAAqC;AACjC,QAAIoD,UAAU,EAAd,EAAkB;AACd;AACA;AACH;;AACD,QAAI5E,IAAI,GAAG2C,SAAX;AACA,QAAI+F,mBAAJ;;AACA,QAAIlH,OAAO,CAACwE,MAAR,KAAmBjG,kBAAkB,CAACC,IAAnB,CAAwBgG,MAA/C,EAAuD;AACnD0C,MAAAA,mBAAmB,GAAIxC,MAAD,IAAY;AAC9B,YAAInC,EAAE,GAAGmC,MAAM,CAACnC,EAAhB;AACA,YAAI4E,MAAM,GAAGvF,aAAa,CAACsE,MAAM,CAAC3D,EAAD,CAAP,CAA1B;;AACA,YAAI4E,MAAJ,EAAY;AACRA,UAAAA,MAAM,CAACC,MAAP;AACH;AACJ,OAND;AAOH,KARD,MASK;AACD,UAAIvB,OAAO,GAAGtE,oBAAoB,CAACvB,OAAO,CAACwE,MAAT,CAAlC;;AACA,UAAIqB,OAAJ,EAAa;AACTqB,QAAAA,mBAAmB,GAAGrB,OAAO,CAACE,OAA9B;AACAvH,QAAAA,IAAI,GAAGqH,OAAO,CAACrH,IAAf;AACH;AACJ;;AACD,QAAI0I,mBAAmB,IAAI5F,uBAA3B,EAAoD;AAChD,UAAI;AACA+F,QAAAA,yBAAyB,CAACrH,OAAD,CAAzB;;AACA,YAAIA,OAAO,CAAC0E,MAAR,KAAmB,KAAK,CAAxB,IAA8BlG,IAAI,KAAK,KAAK,CAAd,IAAmBA,IAAI,CAAC4H,cAAL,KAAwB,CAA7E,EAAiF;AAC7Ec,UAAAA,mBAAmB,GAAGA,mBAAmB,EAAtB,GAA2B5F,uBAAuB,CAACtB,OAAO,CAACwE,MAAT,CAArE;AACH,SAFD,MAGK,IAAI9I,EAAE,CAAC4K,KAAH,CAAStG,OAAO,CAAC0E,MAAjB,MAA6BlG,IAAI,KAAK,KAAK,CAAd,IAAmBA,IAAI,CAAC4H,cAAL,GAAsB,CAAtE,CAAJ,EAA8E;AAC/Ec,UAAAA,mBAAmB,GAAGA,mBAAmB,CAAC,GAAGlH,OAAO,CAAC0E,MAAZ,CAAtB,GAA4CpD,uBAAuB,CAACtB,OAAO,CAACwE,MAAT,EAAiB,GAAGxE,OAAO,CAAC0E,MAA5B,CAAtF;AACH,SAFI,MAGA;AACDwC,UAAAA,mBAAmB,GAAGA,mBAAmB,CAAClH,OAAO,CAAC0E,MAAT,CAAtB,GAAyCpD,uBAAuB,CAACtB,OAAO,CAACwE,MAAT,EAAiBxE,OAAO,CAAC0E,MAAzB,CAAnF;AACH;AACJ,OAXD,CAYA,OAAO/F,KAAP,EAAc;AACV,YAAIA,KAAK,CAACqB,OAAV,EAAmB;AACfY,UAAAA,MAAM,CAACjC,KAAP,CAAc,yBAAwBqB,OAAO,CAACwE,MAAO,0BAAyB7F,KAAK,CAACqB,OAAQ,EAA5F;AACH,SAFD,MAGK;AACDY,UAAAA,MAAM,CAACjC,KAAP,CAAc,yBAAwBqB,OAAO,CAACwE,MAAO,wBAArD;AACH;AACJ;AACJ,KArBD,MAsBK;AACDpC,MAAAA,4BAA4B,CAACmB,IAA7B,CAAkCvD,OAAlC;AACH;AACJ;;AACD,WAASsE,oBAAT,CAA8BtE,OAA9B,EAAuC;AACnC,QAAI,CAACA,OAAL,EAAc;AACVY,MAAAA,MAAM,CAACjC,KAAP,CAAa,yBAAb;AACA;AACH;;AACDiC,IAAAA,MAAM,CAACjC,KAAP,CAAc,6EAA4EY,IAAI,CAACsH,SAAL,CAAe7G,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAAiC,EAA3H,EALmC,CAMnC;;AACA,QAAI4G,eAAe,GAAG5G,OAAtB;;AACA,QAAItE,EAAE,CAAC+K,MAAH,CAAUG,eAAe,CAACrE,EAA1B,KAAiC7G,EAAE,CAAC4L,MAAH,CAAUV,eAAe,CAACrE,EAA1B,CAArC,EAAoE;AAChE,UAAIkC,GAAG,GAAGyB,MAAM,CAACU,eAAe,CAACrE,EAAjB,CAAhB;AACA,UAAIgF,eAAe,GAAG5F,gBAAgB,CAAC8C,GAAD,CAAtC;;AACA,UAAI8C,eAAJ,EAAqB;AACjBA,QAAAA,eAAe,CAACP,MAAhB,CAAuB,IAAInH,KAAJ,CAAU,mEAAV,CAAvB;AACH;AACJ;AACJ;;AACD,WAAS2H,mBAAT,CAA6BxH,OAA7B,EAAsC;AAClC,QAAI6B,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACD,QAAID,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAAhB,IAA2BY,OAAO,CAAC0E,MAAvC,EAA+C;AAC3ChB,QAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC0E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH;;AACD3C,MAAAA,MAAM,CAACjD,GAAP,CAAY,oBAAmBkB,OAAO,CAACwE,MAAO,OAAMxE,OAAO,CAACuC,EAAG,KAA/D,EAAqEmB,IAArE;AACH,KAND,MAOK;AACD+D,MAAAA,aAAa,CAAC,cAAD,EAAiBzH,OAAjB,CAAb;AACH;AACJ;;AACD,WAAS0H,wBAAT,CAAkC1H,OAAlC,EAA2C;AACvC,QAAI6B,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACD,QAAID,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAApB,EAA6B;AACzB,YAAIY,OAAO,CAAC0E,MAAZ,EAAoB;AAChBhB,UAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC0E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH,SAFD,MAGK;AACDhB,UAAAA,IAAI,GAAG,6BAAP;AACH;AACJ;;AACD3B,MAAAA,MAAM,CAACjD,GAAP,CAAY,yBAAwBkB,OAAO,CAACwE,MAAO,IAAnD,EAAwDd,IAAxD;AACH,KAXD,MAYK;AACD+D,MAAAA,aAAa,CAAC,mBAAD,EAAsBzH,OAAtB,CAAb;AACH;AACJ;;AACD,WAASgF,oBAAT,CAA8BhF,OAA9B,EAAuCwE,MAAvC,EAA+Ce,SAA/C,EAA0D;AACtD,QAAI1D,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACD,QAAID,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAApB,EAA6B;AACzB,YAAIY,OAAO,CAACrB,KAAR,IAAiBqB,OAAO,CAACrB,KAAR,CAAc+E,IAAnC,EAAyC;AACrCA,UAAAA,IAAI,GAAI,eAAcnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAACrB,KAAR,CAAc+E,IAA7B,EAAmC,IAAnC,EAAyC,CAAzC,CAA4C,MAAlE;AACH,SAFD,MAGK;AACD,cAAI1D,OAAO,CAAC8E,MAAZ,EAAoB;AAChBpB,YAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC8E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH,WAFD,MAGK,IAAI9E,OAAO,CAACrB,KAAR,KAAkB,KAAK,CAA3B,EAA8B;AAC/B+E,YAAAA,IAAI,GAAG,yBAAP;AACH;AACJ;AACJ;;AACD3B,MAAAA,MAAM,CAACjD,GAAP,CAAY,qBAAoB0F,MAAO,OAAMxE,OAAO,CAACuC,EAAG,+BAA8B0C,IAAI,CAACC,GAAL,KAAaK,SAAU,IAA7G,EAAkH7B,IAAlH;AACH,KAhBD,MAiBK;AACD+D,MAAAA,aAAa,CAAC,eAAD,EAAkBzH,OAAlB,CAAb;AACH;AACJ;;AACD,WAAS4F,oBAAT,CAA8B5F,OAA9B,EAAuC;AACnC,QAAI6B,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACD,QAAID,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAAhB,IAA2BY,OAAO,CAAC0E,MAAvC,EAA+C;AAC3ChB,QAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC0E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH;;AACD3C,MAAAA,MAAM,CAACjD,GAAP,CAAY,qBAAoBkB,OAAO,CAACwE,MAAO,OAAMxE,OAAO,CAACuC,EAAG,KAAhE,EAAsEmB,IAAtE;AACH,KAND,MAOK;AACD+D,MAAAA,aAAa,CAAC,iBAAD,EAAoBzH,OAApB,CAAb;AACH;AACJ;;AACD,WAASqH,yBAAT,CAAmCrH,OAAnC,EAA4C;AACxC,QAAI6B,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAAxB,IAAkC/B,OAAO,CAACwE,MAAR,KAAmB9E,oBAAoB,CAAClB,IAArB,CAA0BgG,MAAnF,EAA2F;AACvF;AACH;;AACD,QAAI1C,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAApB,EAA6B;AACzB,YAAIY,OAAO,CAAC0E,MAAZ,EAAoB;AAChBhB,UAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC0E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH,SAFD,MAGK;AACDhB,UAAAA,IAAI,GAAG,6BAAP;AACH;AACJ;;AACD3B,MAAAA,MAAM,CAACjD,GAAP,CAAY,0BAAyBkB,OAAO,CAACwE,MAAO,IAApD,EAAyDd,IAAzD;AACH,KAXD,MAYK;AACD+D,MAAAA,aAAa,CAAC,sBAAD,EAAyBzH,OAAzB,CAAb;AACH;AACJ;;AACD,WAAS+G,qBAAT,CAA+B/G,OAA/B,EAAwC8G,eAAxC,EAAyD;AACrD,QAAIjF,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACD,QAAID,WAAW,KAAKxC,WAAW,CAACE,IAAhC,EAAsC;AAClC,UAAIkE,IAAI,GAAGvC,SAAX;;AACA,UAAIU,KAAK,KAAK9C,KAAK,CAACK,OAApB,EAA6B;AACzB,YAAIY,OAAO,CAACrB,KAAR,IAAiBqB,OAAO,CAACrB,KAAR,CAAc+E,IAAnC,EAAyC;AACrCA,UAAAA,IAAI,GAAI,eAAcnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAACrB,KAAR,CAAc+E,IAA7B,EAAmC,IAAnC,EAAyC,CAAzC,CAA4C,MAAlE;AACH,SAFD,MAGK;AACD,cAAI1D,OAAO,CAAC8E,MAAZ,EAAoB;AAChBpB,YAAAA,IAAI,GAAI,WAAUnE,IAAI,CAACsH,SAAL,CAAe7G,OAAO,CAAC8E,MAAvB,EAA+B,IAA/B,EAAqC,CAArC,CAAwC,MAA1D;AACH,WAFD,MAGK,IAAI9E,OAAO,CAACrB,KAAR,KAAkB,KAAK,CAA3B,EAA8B;AAC/B+E,YAAAA,IAAI,GAAG,yBAAP;AACH;AACJ;AACJ;;AACD,UAAIoD,eAAJ,EAAqB;AACjB,YAAInI,KAAK,GAAGqB,OAAO,CAACrB,KAAR,GAAiB,oBAAmBqB,OAAO,CAACrB,KAAR,CAAcqB,OAAQ,KAAIA,OAAO,CAACrB,KAAR,CAAcoB,IAAK,IAAjF,GAAuF,EAAnG;AACAgC,QAAAA,MAAM,CAACjD,GAAP,CAAY,sBAAqBgI,eAAe,CAACtC,MAAO,OAAMxE,OAAO,CAACuC,EAAG,SAAQ0C,IAAI,CAACC,GAAL,KAAa4B,eAAe,CAACa,UAAW,MAAKhJ,KAAM,EAApI,EAAuI+E,IAAvI;AACH,OAHD,MAIK;AACD3B,QAAAA,MAAM,CAACjD,GAAP,CAAY,qBAAoBkB,OAAO,CAACuC,EAAG,mCAA3C,EAA+EmB,IAA/E;AACH;AACJ,KAtBD,MAuBK;AACD+D,MAAAA,aAAa,CAAC,kBAAD,EAAqBzH,OAArB,CAAb;AACH;AACJ;;AACD,WAASyH,aAAT,CAAuBjJ,IAAvB,EAA6BwB,OAA7B,EAAsC;AAClC,QAAI,CAAC+B,MAAD,IAAWF,KAAK,KAAK9C,KAAK,CAACG,GAA/B,EAAoC;AAChC;AACH;;AACD,UAAM0I,UAAU,GAAG;AACfC,MAAAA,YAAY,EAAE,IADC;AAEfrJ,MAAAA,IAFe;AAGfwB,MAAAA,OAHe;AAIf8H,MAAAA,SAAS,EAAE7C,IAAI,CAACC,GAAL;AAJI,KAAnB;AAMAnD,IAAAA,MAAM,CAACjD,GAAP,CAAW8I,UAAX;AACH;;AACD,WAASG,uBAAT,GAAmC;AAC/B,QAAI7E,QAAQ,EAAZ,EAAgB;AACZ,YAAM,IAAItD,eAAJ,CAAoBD,gBAAgB,CAACwD,MAArC,EAA6C,uBAA7C,CAAN;AACH;;AACD,QAAIC,UAAU,EAAd,EAAkB;AACd,YAAM,IAAIxD,eAAJ,CAAoBD,gBAAgB,CAAC0D,QAArC,EAA+C,yBAA/C,CAAN;AACH;AACJ;;AACD,WAAS2E,gBAAT,GAA4B;AACxB,QAAIhF,WAAW,EAAf,EAAmB;AACf,YAAM,IAAIpD,eAAJ,CAAoBD,gBAAgB,CAACsI,gBAArC,EAAuD,iCAAvD,CAAN;AACH;AACJ;;AACD,WAASC,mBAAT,GAA+B;AAC3B,QAAI,CAAClF,WAAW,EAAhB,EAAoB;AAChB,YAAM,IAAInD,KAAJ,CAAU,sBAAV,CAAN;AACH;AACJ;;AACD,WAASsI,eAAT,CAAyBC,KAAzB,EAAgC;AAC5B,QAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAClB,aAAO,IAAP;AACH,KAFD,MAGK;AACD,aAAOA,KAAP;AACH;AACJ;;AACD,WAASC,oBAAT,CAA8B7J,IAA9B,EAAoCkG,MAApC,EAA4C;AACxC,QAAII,MAAJ;AACA,QAAIsB,cAAc,GAAG5H,IAAI,CAAC4H,cAA1B;;AACA,YAAQA,cAAR;AACI,WAAK,CAAL;AACItB,QAAAA,MAAM,GAAG,IAAT;AACA;;AACJ,WAAK,CAAL;AACIA,QAAAA,MAAM,GAAGqD,eAAe,CAACzD,MAAM,CAAC,CAAD,CAAP,CAAxB;AACA;;AACJ;AACII,QAAAA,MAAM,GAAG,EAAT;;AACA,aAAK,IAAIwD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,MAAM,CAAC6D,MAAX,IAAqBD,CAAC,GAAGlC,cAAzC,EAAyDkC,CAAC,EAA1D,EAA8D;AAC1DxD,UAAAA,MAAM,CAAC0D,IAAP,CAAYL,eAAe,CAACzD,MAAM,CAAC4D,CAAD,CAAP,CAA3B;AACH;;AACD,YAAI5D,MAAM,CAAC6D,MAAP,GAAgBnC,cAApB,EAAoC;AAChC,eAAK,IAAIkC,CAAC,GAAG5D,MAAM,CAAC6D,MAApB,EAA4BD,CAAC,GAAGlC,cAAhC,EAAgDkC,CAAC,EAAjD,EAAqD;AACjDxD,YAAAA,MAAM,CAAC0D,IAAP,CAAY,IAAZ;AACH;AACJ;;AACD;AAjBR;;AAmBA,WAAO1D,MAAP;AACH;;AACD,MAAI2D,UAAU,GAAG;AACbC,IAAAA,gBAAgB,EAAE,CAAClK,IAAD,EAAO,GAAGkG,MAAV,KAAqB;AACnCqD,MAAAA,uBAAuB;AACvB,UAAIvD,MAAJ;AACA,UAAImE,aAAJ;;AACA,UAAIjN,EAAE,CAAC+K,MAAH,CAAUjI,IAAV,CAAJ,EAAqB;AACjBgG,QAAAA,MAAM,GAAGhG,IAAT;;AACA,gBAAQkG,MAAM,CAAC6D,MAAf;AACI,eAAK,CAAL;AACII,YAAAA,aAAa,GAAG,IAAhB;AACA;;AACJ,eAAK,CAAL;AACIA,YAAAA,aAAa,GAAGjE,MAAM,CAAC,CAAD,CAAtB;AACA;;AACJ;AACIiE,YAAAA,aAAa,GAAGjE,MAAhB;AACA;AATR;AAWH,OAbD,MAcK;AACDF,QAAAA,MAAM,GAAGhG,IAAI,CAACgG,MAAd;AACAmE,QAAAA,aAAa,GAAGN,oBAAoB,CAAC7J,IAAD,EAAOkG,MAAP,CAApC;AACH;;AACD,UAAIkE,mBAAmB,GAAG;AACtBpD,QAAAA,OAAO,EAAEvE,OADa;AAEtBuD,QAAAA,MAAM,EAAEA,MAFc;AAGtBE,QAAAA,MAAM,EAAEiE;AAHc,OAA1B;AAKAjB,MAAAA,wBAAwB,CAACkB,mBAAD,CAAxB;AACAjI,MAAAA,aAAa,CAACwE,KAAd,CAAoByD,mBAApB;AACH,KA9BY;AA+BbC,IAAAA,cAAc,EAAE,CAACrK,IAAD,EAAOuH,OAAP,KAAmB;AAC/BgC,MAAAA,uBAAuB;;AACvB,UAAIrM,EAAE,CAAC4E,IAAH,CAAQ9B,IAAR,CAAJ,EAAmB;AACf8C,QAAAA,uBAAuB,GAAG9C,IAA1B;AACH,OAFD,MAGK,IAAIuH,OAAJ,EAAa;AACd,YAAIrK,EAAE,CAAC+K,MAAH,CAAUjI,IAAV,CAAJ,EAAqB;AACjB+C,UAAAA,oBAAoB,CAAC/C,IAAD,CAApB,GAA6B;AAAEA,YAAAA,IAAI,EAAE2C,SAAR;AAAmB4E,YAAAA;AAAnB,WAA7B;AACH,SAFD,MAGK;AACDxE,UAAAA,oBAAoB,CAAC/C,IAAI,CAACgG,MAAN,CAApB,GAAoC;AAAEhG,YAAAA,IAAF;AAAQuH,YAAAA;AAAR,WAApC;AACH;AACJ;AACJ,KA5CY;AA6Cb+C,IAAAA,WAAW,EAAE,CAACtK,IAAD,EAAO,GAAGkG,MAAV,KAAqB;AAC9BqD,MAAAA,uBAAuB;AACvBG,MAAAA,mBAAmB;AACnB,UAAI1D,MAAJ;AACA,UAAImE,aAAJ;AACA,UAAItC,KAAK,GAAGlF,SAAZ;;AACA,UAAIzF,EAAE,CAAC+K,MAAH,CAAUjI,IAAV,CAAJ,EAAqB;AACjBgG,QAAAA,MAAM,GAAGhG,IAAT;;AACA,gBAAQkG,MAAM,CAAC6D,MAAf;AACI,eAAK,CAAL;AACII,YAAAA,aAAa,GAAG,IAAhB;AACA;;AACJ,eAAK,CAAL;AACI;AACA,gBAAIxK,cAAc,CAACE,iBAAf,CAAiC+B,EAAjC,CAAoCsE,MAAM,CAAC,CAAD,CAA1C,CAAJ,EAAoD;AAChDiE,cAAAA,aAAa,GAAG,IAAhB;AACAtC,cAAAA,KAAK,GAAG3B,MAAM,CAAC,CAAD,CAAd;AACH,aAHD,MAIK;AACDiE,cAAAA,aAAa,GAAGR,eAAe,CAACzD,MAAM,CAAC,CAAD,CAAP,CAA/B;AACH;;AACD;;AACJ;AACI,kBAAMqE,IAAI,GAAGrE,MAAM,CAAC6D,MAAP,GAAgB,CAA7B;;AACA,gBAAIpK,cAAc,CAACE,iBAAf,CAAiC+B,EAAjC,CAAoCsE,MAAM,CAACqE,IAAD,CAA1C,CAAJ,EAAuD;AACnD1C,cAAAA,KAAK,GAAG3B,MAAM,CAACqE,IAAD,CAAd;;AACA,kBAAIrE,MAAM,CAAC6D,MAAP,KAAkB,CAAtB,EAAyB;AACrBI,gBAAAA,aAAa,GAAGR,eAAe,CAACzD,MAAM,CAAC,CAAD,CAAP,CAA/B;AACH,eAFD,MAGK;AACDiE,gBAAAA,aAAa,GAAGjE,MAAM,CAACsE,KAAP,CAAa,CAAb,EAAgBD,IAAhB,EAAsBE,GAAtB,CAA0BxN,KAAK,IAAI0M,eAAe,CAAC1M,KAAD,CAAlD,CAAhB;AACH;AACJ,aARD,MASK;AACDkN,cAAAA,aAAa,GAAGjE,MAAM,CAACuE,GAAP,CAAWxN,KAAK,IAAI0M,eAAe,CAAC1M,KAAD,CAAnC,CAAhB;AACH;;AACD;AA5BR;AA8BH,OAhCD,MAiCK;AACD+I,QAAAA,MAAM,GAAGhG,IAAI,CAACgG,MAAd;AACAmE,QAAAA,aAAa,GAAGN,oBAAoB,CAAC7J,IAAD,EAAOkG,MAAP,CAApC;AACA,YAAI0B,cAAc,GAAG5H,IAAI,CAAC4H,cAA1B;AACAC,QAAAA,KAAK,GAAGlI,cAAc,CAACE,iBAAf,CAAiC+B,EAAjC,CAAoCsE,MAAM,CAAC0B,cAAD,CAA1C,IAA8D1B,MAAM,CAAC0B,cAAD,CAApE,GAAuFjF,SAA/F;AACH;;AACD,UAAIoB,EAAE,GAAGzB,cAAc,EAAvB;AACA,UAAIgE,MAAM,GAAG,IAAIoE,OAAJ,CAAY,CAACjC,OAAD,EAAUD,MAAV,KAAqB;AAC1C,YAAI5B,cAAc,GAAG;AACjBI,UAAAA,OAAO,EAAEvE,OADQ;AAEjBsB,UAAAA,EAAE,EAAEA,EAFa;AAGjBiC,UAAAA,MAAM,EAAEA,MAHS;AAIjBE,UAAAA,MAAM,EAAEiE;AAJS,SAArB;AAMA,YAAI7B,eAAe,GAAG;AAAEtC,UAAAA,MAAM,EAAEA,MAAV;AAAkBmD,UAAAA,UAAU,EAAE1C,IAAI,CAACC,GAAL,EAA9B;AAA0C+B,UAAAA,OAA1C;AAAmDD,UAAAA;AAAnD,SAAtB;AACAQ,QAAAA,mBAAmB,CAACpC,cAAD,CAAnB;;AACA,YAAI;AACAzE,UAAAA,aAAa,CAACwE,KAAd,CAAoBC,cAApB;AACH,SAFD,CAGA,OAAO+D,CAAP,EAAU;AACN;AACArC,UAAAA,eAAe,CAACE,MAAhB,CAAuB,IAAIpL,UAAU,CAACY,aAAf,CAA6BZ,UAAU,CAACa,UAAX,CAAsB2M,iBAAnD,EAAsED,CAAC,CAACnJ,OAAF,GAAYmJ,CAAC,CAACnJ,OAAd,GAAwB,gBAA9F,CAAvB;AACA8G,UAAAA,eAAe,GAAG,IAAlB;AACH;;AACD,YAAIA,eAAJ,EAAqB;AACjBnF,UAAAA,gBAAgB,CAACuE,MAAM,CAAC3D,EAAD,CAAP,CAAhB,GAA+BuE,eAA/B;AACH;AACJ,OApBY,CAAb;;AAqBA,UAAIT,KAAJ,EAAW;AACPA,QAAAA,KAAK,CAACgD,uBAAN,CAA8B,MAAM;AAChCZ,UAAAA,UAAU,CAACC,gBAAX,CAA4BnK,kBAAkB,CAACC,IAA/C,EAAqD;AAAE+D,YAAAA;AAAF,WAArD;AACH,SAFD;AAGH;;AACD,aAAOuC,MAAP;AACH,KAtHY;AAuHbwE,IAAAA,SAAS,EAAE,CAAC9K,IAAD,EAAOuH,OAAP,KAAmB;AAC1BgC,MAAAA,uBAAuB;;AACvB,UAAIrM,EAAE,CAAC4E,IAAH,CAAQ9B,IAAR,CAAJ,EAAmB;AACf0C,QAAAA,kBAAkB,GAAG1C,IAArB;AACH,OAFD,MAGK,IAAIuH,OAAJ,EAAa;AACd,YAAIrK,EAAE,CAAC+K,MAAH,CAAUjI,IAAV,CAAJ,EAAqB;AACjB4C,UAAAA,eAAe,CAAC5C,IAAD,CAAf,GAAwB;AAAEA,YAAAA,IAAI,EAAE2C,SAAR;AAAmB4E,YAAAA;AAAnB,WAAxB;AACH,SAFD,MAGK;AACD3E,UAAAA,eAAe,CAAC5C,IAAI,CAACgG,MAAN,CAAf,GAA+B;AAAEhG,YAAAA,IAAF;AAAQuH,YAAAA;AAAR,WAA/B;AACH;AACJ;AACJ,KApIY;AAqIblE,IAAAA,KAAK,EAAE,CAAC0H,MAAD,EAASC,OAAT,EAAkBC,8BAAlB,KAAqD;AACxD,UAAIC,iBAAiB,GAAG,KAAxB;AACA,UAAIC,YAAY,GAAGrK,WAAW,CAACE,IAA/B;;AACA,UAAIiK,8BAA8B,KAAK,KAAK,CAA5C,EAA+C;AAC3C,YAAI/N,EAAE,CAACkO,OAAH,CAAWH,8BAAX,CAAJ,EAAgD;AAC5CC,UAAAA,iBAAiB,GAAGD,8BAApB;AACH,SAFD,MAGK;AACDC,UAAAA,iBAAiB,GAAGD,8BAA8B,CAACf,gBAA/B,IAAmD,KAAvE;AACAiB,UAAAA,YAAY,GAAGF,8BAA8B,CAAC3H,WAA/B,IAA8CxC,WAAW,CAACE,IAAzE;AACH;AACJ;;AACDqC,MAAAA,KAAK,GAAG0H,MAAR;AACAzH,MAAAA,WAAW,GAAG6H,YAAd;;AACA,UAAI9H,KAAK,KAAK9C,KAAK,CAACG,GAApB,EAAyB;AACrB6C,QAAAA,MAAM,GAAGZ,SAAT;AACH,OAFD,MAGK;AACDY,QAAAA,MAAM,GAAGyH,OAAT;AACH;;AACD,UAAIE,iBAAiB,IAAI,CAACxG,QAAQ,EAA9B,IAAoC,CAACE,UAAU,EAAnD,EAAuD;AACnDqF,QAAAA,UAAU,CAACC,gBAAX,CAA4BjJ,oBAAoB,CAACjB,IAAjD,EAAuD;AAAE/C,UAAAA,KAAK,EAAEsD,KAAK,CAACM,QAAN,CAAekK,MAAf;AAAT,SAAvD;AACH;AACJ,KA5JY;AA6Jb3F,IAAAA,OAAO,EAAE1B,YAAY,CAAC2H,KA7JT;AA8JblG,IAAAA,OAAO,EAAExB,YAAY,CAAC0H,KA9JT;AA+JbC,IAAAA,uBAAuB,EAAE1H,4BAA4B,CAACyH,KA/JzC;AAgKbE,IAAAA,SAAS,EAAE1H,cAAc,CAACwH,KAhKb;AAiKbG,IAAAA,OAAO,EAAE,MAAM;AACX,UAAI5G,UAAU,EAAd,EAAkB;AACd;AACH;;AACDpB,MAAAA,KAAK,GAAGxB,eAAe,CAAC6C,QAAxB;AACAhB,MAAAA,cAAc,CAACkB,IAAf,CAAoBpC,SAApB;AACA,UAAIxC,KAAK,GAAG,IAAIkB,KAAJ,CAAU,0BAAV,CAAZ;AACAtE,MAAAA,MAAM,CAAC0O,IAAP,CAAYtI,gBAAZ,EAA8BuI,OAA9B,CAAuCzF,GAAD,IAAS;AAC3C9C,QAAAA,gBAAgB,CAAC8C,GAAD,CAAhB,CAAsBuC,MAAtB,CAA6BrI,KAA7B;AACH,OAFD;AAGAgD,MAAAA,gBAAgB,GAAGpG,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAAnB;AACAO,MAAAA,aAAa,GAAGrG,MAAM,CAAC8F,MAAP,CAAc,IAAd,CAAhB;AACAI,MAAAA,YAAY,GAAG,IAAInD,WAAW,CAACoD,SAAhB,EAAf,CAZW,CAaX;;AACA,UAAIhG,EAAE,CAAC4E,IAAH,CAAQK,aAAa,CAACqJ,OAAtB,CAAJ,EAAoC;AAChCrJ,QAAAA,aAAa,CAACqJ,OAAd;AACH;;AACD,UAAItO,EAAE,CAAC4E,IAAH,CAAQI,aAAa,CAACsJ,OAAtB,CAAJ,EAAoC;AAChCtJ,QAAAA,aAAa,CAACsJ,OAAd;AACH;AACJ,KArLY;AAsLbG,IAAAA,MAAM,EAAE,MAAM;AACVpC,MAAAA,uBAAuB;AACvBC,MAAAA,gBAAgB;AAChBhG,MAAAA,KAAK,GAAGxB,eAAe,CAACyC,SAAxB;AACAvC,MAAAA,aAAa,CAACyJ,MAAd,CAAqB5F,QAArB;AACH,KA3LY;AA4Lb6F,IAAAA,OAAO,EAAE,MAAM;AACXC,MAAAA,OAAO,CAACvL,GAAR,CAAY,SAAZ;AACH;AA9LY,GAAjB;AAgMA2J,EAAAA,UAAU,CAACI,cAAX,CAA0BnJ,oBAAoB,CAAClB,IAA/C,EAAsDkG,MAAD,IAAY;AAC7D,QAAI7C,KAAK,KAAK9C,KAAK,CAACG,GAAhB,IAAuB,CAAC6C,MAA5B,EAAoC;AAChC;AACH;;AACDA,IAAAA,MAAM,CAACjD,GAAP,CAAW4F,MAAM,CAAC1E,OAAlB,EAA2B6B,KAAK,KAAK9C,KAAK,CAACK,OAAhB,GAA0BsF,MAAM,CAAC4F,OAAjC,GAA2CnJ,SAAtE;AACH,GALD;AAMA,SAAOsH,UAAP;AACH;;AACD,SAAS8B,eAAT,CAAyB9O,KAAzB,EAAgC;AAC5B,SAAOA,KAAK,CAAC0O,MAAN,KAAiB,KAAK,CAAtB,IAA2B1O,KAAK,CAAC+O,IAAN,KAAe,KAAK,CAAtD;AACH;;AACD,SAASC,eAAT,CAAyBhP,KAAzB,EAAgC;AAC5B,SAAOA,KAAK,CAAC0J,KAAN,KAAgB,KAAK,CAArB,IAA0B1J,KAAK,CAACiP,GAAN,KAAc,KAAK,CAApD;AACH;;AACD,SAASC,uBAAT,CAAiCC,KAAjC,EAAwCC,MAAxC,EAAgDjK,MAAhD,EAAwDC,QAAxD,EAAkE;AAC9D,MAAI,CAACD,MAAL,EAAa;AACTA,IAAAA,MAAM,GAAGvF,OAAO,CAACoD,UAAjB;AACH;;AACD,MAAIqM,MAAM,GAAGP,eAAe,CAACK,KAAD,CAAf,GAAyBA,KAAzB,GAAiC,IAAIvN,eAAe,CAACE,mBAApB,CAAwCqN,KAAxC,CAA9C;AACA,MAAIG,MAAM,GAAGN,eAAe,CAACI,MAAD,CAAf,GAA0BA,MAA1B,GAAmC,IAAInN,eAAe,CAACE,mBAApB,CAAwCiN,MAAxC,CAAhD;AACA,SAAOpK,wBAAwB,CAACqK,MAAD,EAASC,MAAT,EAAiBnK,MAAjB,EAAyBC,QAAzB,CAA/B;AACH;;AACDxF,OAAO,CAACsP,uBAAR,GAAkCA,uBAAlC","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n/// <reference path=\"./thenable.ts\" />\r\n'use strict';\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Is = require(\"./is\");\r\nconst messages_1 = require(\"./messages\");\r\nexports.RequestType = messages_1.RequestType;\r\nexports.RequestType0 = messages_1.RequestType0;\r\nexports.RequestType1 = messages_1.RequestType1;\r\nexports.RequestType2 = messages_1.RequestType2;\r\nexports.RequestType3 = messages_1.RequestType3;\r\nexports.RequestType4 = messages_1.RequestType4;\r\nexports.RequestType5 = messages_1.RequestType5;\r\nexports.RequestType6 = messages_1.RequestType6;\r\nexports.RequestType7 = messages_1.RequestType7;\r\nexports.RequestType8 = messages_1.RequestType8;\r\nexports.RequestType9 = messages_1.RequestType9;\r\nexports.ResponseError = messages_1.ResponseError;\r\nexports.ErrorCodes = messages_1.ErrorCodes;\r\nexports.NotificationType = messages_1.NotificationType;\r\nexports.NotificationType0 = messages_1.NotificationType0;\r\nexports.NotificationType1 = messages_1.NotificationType1;\r\nexports.NotificationType2 = messages_1.NotificationType2;\r\nexports.NotificationType3 = messages_1.NotificationType3;\r\nexports.NotificationType4 = messages_1.NotificationType4;\r\nexports.NotificationType5 = messages_1.NotificationType5;\r\nexports.NotificationType6 = messages_1.NotificationType6;\r\nexports.NotificationType7 = messages_1.NotificationType7;\r\nexports.NotificationType8 = messages_1.NotificationType8;\r\nexports.NotificationType9 = messages_1.NotificationType9;\r\nconst messageReader_1 = require(\"./messageReader\");\r\nexports.MessageReader = messageReader_1.MessageReader;\r\nexports.StreamMessageReader = messageReader_1.StreamMessageReader;\r\nexports.IPCMessageReader = messageReader_1.IPCMessageReader;\r\nexports.SocketMessageReader = messageReader_1.SocketMessageReader;\r\nconst messageWriter_1 = require(\"./messageWriter\");\r\nexports.MessageWriter = messageWriter_1.MessageWriter;\r\nexports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;\r\nexports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;\r\nexports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;\r\nconst events_1 = require(\"./events\");\r\nexports.Disposable = events_1.Disposable;\r\nexports.Event = events_1.Event;\r\nexports.Emitter = events_1.Emitter;\r\nconst cancellation_1 = require(\"./cancellation\");\r\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\r\nexports.CancellationToken = cancellation_1.CancellationToken;\r\nconst linkedMap_1 = require(\"./linkedMap\");\r\n__export(require(\"./pipeSupport\"));\r\n__export(require(\"./socketSupport\"));\r\nvar CancelNotification;\r\n(function (CancelNotification) {\r\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\r\n})(CancelNotification || (CancelNotification = {}));\r\nexports.NullLogger = Object.freeze({\r\n    error: () => { },\r\n    warn: () => { },\r\n    info: () => { },\r\n    log: () => { }\r\n});\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case Trace.Off:\r\n                return 'off';\r\n            case Trace.Messages:\r\n                return 'messages';\r\n            case Trace.Verbose:\r\n                return 'verbose';\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    Trace.toString = toString;\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\nvar TraceFormat;\r\n(function (TraceFormat) {\r\n    TraceFormat[\"Text\"] = \"text\";\r\n    TraceFormat[\"JSON\"] = \"json\";\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\n(function (TraceFormat) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        if (value === 'json') {\r\n            return TraceFormat.JSON;\r\n        }\r\n        else {\r\n            return TraceFormat.Text;\r\n        }\r\n    }\r\n    TraceFormat.fromString = fromString;\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\nvar SetTraceNotification;\r\n(function (SetTraceNotification) {\r\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\r\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\r\nvar LogTraceNotification;\r\n(function (LogTraceNotification) {\r\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\r\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\r\nvar ConnectionErrors;\r\n(function (ConnectionErrors) {\r\n    /**\r\n     * The connection is closed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\r\n    /**\r\n     * The connection got disposed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\r\n    /**\r\n     * The connection is already in listening mode.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\r\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\r\nclass ConnectionError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n        Object.setPrototypeOf(this, ConnectionError.prototype);\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\nvar ConnectionStrategy;\r\n(function (ConnectionStrategy) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.cancelUndispatched);\r\n    }\r\n    ConnectionStrategy.is = is;\r\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\r\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\r\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\r\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nfunction _createMessageConnection(messageReader, messageWriter, logger, strategy) {\r\n    let sequenceNumber = 0;\r\n    let notificationSquenceNumber = 0;\r\n    let unknownResponseSquenceNumber = 0;\r\n    const version = '2.0';\r\n    let starRequestHandler = undefined;\r\n    let requestHandlers = Object.create(null);\r\n    let starNotificationHandler = undefined;\r\n    let notificationHandlers = Object.create(null);\r\n    let timer;\r\n    let messageQueue = new linkedMap_1.LinkedMap();\r\n    let responsePromises = Object.create(null);\r\n    let requestTokens = Object.create(null);\r\n    let trace = Trace.Off;\r\n    let traceFormat = TraceFormat.Text;\r\n    let tracer;\r\n    let state = ConnectionState.New;\r\n    let errorEmitter = new events_1.Emitter();\r\n    let closeEmitter = new events_1.Emitter();\r\n    let unhandledNotificationEmitter = new events_1.Emitter();\r\n    let disposeEmitter = new events_1.Emitter();\r\n    function createRequestQueueKey(id) {\r\n        return 'req-' + id.toString();\r\n    }\r\n    function createResponseQueueKey(id) {\r\n        if (id === null) {\r\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\r\n        }\r\n        else {\r\n            return 'res-' + id.toString();\r\n        }\r\n    }\r\n    function createNotificationQueueKey() {\r\n        return 'not-' + (++notificationSquenceNumber).toString();\r\n    }\r\n    function addMessageToQueue(queue, message) {\r\n        if (messages_1.isRequestMessage(message)) {\r\n            queue.set(createRequestQueueKey(message.id), message);\r\n        }\r\n        else if (messages_1.isResponseMessage(message)) {\r\n            queue.set(createResponseQueueKey(message.id), message);\r\n        }\r\n        else {\r\n            queue.set(createNotificationQueueKey(), message);\r\n        }\r\n    }\r\n    function cancelUndispatched(_message) {\r\n        return undefined;\r\n    }\r\n    function isListening() {\r\n        return state === ConnectionState.Listening;\r\n    }\r\n    function isClosed() {\r\n        return state === ConnectionState.Closed;\r\n    }\r\n    function isDisposed() {\r\n        return state === ConnectionState.Disposed;\r\n    }\r\n    function closeHandler() {\r\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\r\n            state = ConnectionState.Closed;\r\n            closeEmitter.fire(undefined);\r\n        }\r\n        // If the connection is disposed don't sent close events.\r\n    }\r\n    ;\r\n    function readErrorHandler(error) {\r\n        errorEmitter.fire([error, undefined, undefined]);\r\n    }\r\n    function writeErrorHandler(data) {\r\n        errorEmitter.fire(data);\r\n    }\r\n    messageReader.onClose(closeHandler);\r\n    messageReader.onError(readErrorHandler);\r\n    messageWriter.onClose(closeHandler);\r\n    messageWriter.onError(writeErrorHandler);\r\n    function triggerMessageQueue() {\r\n        if (timer || messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        timer = setImmediate(() => {\r\n            timer = undefined;\r\n            processMessageQueue();\r\n        });\r\n    }\r\n    function processMessageQueue() {\r\n        if (messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        let message = messageQueue.shift();\r\n        try {\r\n            if (messages_1.isRequestMessage(message)) {\r\n                handleRequest(message);\r\n            }\r\n            else if (messages_1.isNotificationMessage(message)) {\r\n                handleNotification(message);\r\n            }\r\n            else if (messages_1.isResponseMessage(message)) {\r\n                handleResponse(message);\r\n            }\r\n            else {\r\n                handleInvalidMessage(message);\r\n            }\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    }\r\n    let callback = (message) => {\r\n        try {\r\n            // We have received a cancellation message. Check if the message is still in the queue\r\n            // and cancel it if allowed to do so.\r\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\r\n                let key = createRequestQueueKey(message.params.id);\r\n                let toCancel = messageQueue.get(key);\r\n                if (messages_1.isRequestMessage(toCancel)) {\r\n                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\r\n                    if (response && (response.error !== void 0 || response.result !== void 0)) {\r\n                        messageQueue.delete(key);\r\n                        response.id = toCancel.id;\r\n                        traceSendingResponse(response, message.method, Date.now());\r\n                        messageWriter.write(response);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            addMessageToQueue(messageQueue, message);\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    };\r\n    function handleRequest(requestMessage) {\r\n        if (isDisposed()) {\r\n            // we return here silently since we fired an event when the\r\n            // connection got disposed.\r\n            return;\r\n        }\r\n        function reply(resultOrError, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id\r\n            };\r\n            if (resultOrError instanceof messages_1.ResponseError) {\r\n                message.error = resultOrError.toJson();\r\n            }\r\n            else {\r\n                message.result = resultOrError === void 0 ? null : resultOrError;\r\n            }\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replyError(error, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                error: error.toJson()\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replySuccess(result, method, startTime) {\r\n            // The JSON RPC defines that a response must either have a result or an error\r\n            // So we can't treat undefined as a valid response result.\r\n            if (result === void 0) {\r\n                result = null;\r\n            }\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                result: result\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        traceReceivedRequest(requestMessage);\r\n        let element = requestHandlers[requestMessage.method];\r\n        let type;\r\n        let requestHandler;\r\n        if (element) {\r\n            type = element.type;\r\n            requestHandler = element.handler;\r\n        }\r\n        let startTime = Date.now();\r\n        if (requestHandler || starRequestHandler) {\r\n            let cancellationSource = new cancellation_1.CancellationTokenSource();\r\n            let tokenKey = String(requestMessage.id);\r\n            requestTokens[tokenKey] = cancellationSource;\r\n            try {\r\n                let handlerResult;\r\n                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, cancellationSource.token);\r\n                }\r\n                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(...requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);\r\n                }\r\n                else {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\r\n                }\r\n                let promise = handlerResult;\r\n                if (!handlerResult) {\r\n                    delete requestTokens[tokenKey];\r\n                    replySuccess(handlerResult, requestMessage.method, startTime);\r\n                }\r\n                else if (promise.then) {\r\n                    promise.then((resultOrError) => {\r\n                        delete requestTokens[tokenKey];\r\n                        reply(resultOrError, requestMessage.method, startTime);\r\n                    }, error => {\r\n                        delete requestTokens[tokenKey];\r\n                        if (error instanceof messages_1.ResponseError) {\r\n                            replyError(error, requestMessage.method, startTime);\r\n                        }\r\n                        else if (error && Is.string(error.message)) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                        }\r\n                        else {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    delete requestTokens[tokenKey];\r\n                    reply(handlerResult, requestMessage.method, startTime);\r\n                }\r\n            }\r\n            catch (error) {\r\n                delete requestTokens[tokenKey];\r\n                if (error instanceof messages_1.ResponseError) {\r\n                    reply(error, requestMessage.method, startTime);\r\n                }\r\n                else if (error && Is.string(error.message)) {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                }\r\n                else {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\r\n        }\r\n    }\r\n    function handleResponse(responseMessage) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        if (responseMessage.id === null) {\r\n            if (responseMessage.error) {\r\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\r\n            }\r\n            else {\r\n                logger.error(`Received response message without id. No further error information provided.`);\r\n            }\r\n        }\r\n        else {\r\n            let key = String(responseMessage.id);\r\n            let responsePromise = responsePromises[key];\r\n            traceReceivedResponse(responseMessage, responsePromise);\r\n            if (responsePromise) {\r\n                delete responsePromises[key];\r\n                try {\r\n                    if (responseMessage.error) {\r\n                        let error = responseMessage.error;\r\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\r\n                    }\r\n                    else if (responseMessage.result !== void 0) {\r\n                        responsePromise.resolve(responseMessage.result);\r\n                    }\r\n                    else {\r\n                        throw new Error('Should never happen.');\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    if (error.message) {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\r\n                    }\r\n                    else {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleNotification(message) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        let type = undefined;\r\n        let notificationHandler;\r\n        if (message.method === CancelNotification.type.method) {\r\n            notificationHandler = (params) => {\r\n                let id = params.id;\r\n                let source = requestTokens[String(id)];\r\n                if (source) {\r\n                    source.cancel();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            let element = notificationHandlers[message.method];\r\n            if (element) {\r\n                notificationHandler = element.handler;\r\n                type = element.type;\r\n            }\r\n        }\r\n        if (notificationHandler || starNotificationHandler) {\r\n            try {\r\n                traceReceivedNotification(message);\r\n                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);\r\n                }\r\n                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);\r\n                }\r\n                else {\r\n                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.message) {\r\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\r\n                }\r\n                else {\r\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            unhandledNotificationEmitter.fire(message);\r\n        }\r\n    }\r\n    function handleInvalidMessage(message) {\r\n        if (!message) {\r\n            logger.error('Received empty message.');\r\n            return;\r\n        }\r\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\r\n        // Test whether we find an id to reject the promise\r\n        let responseMessage = message;\r\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\r\n            let key = String(responseMessage.id);\r\n            let responseHandler = responsePromises[key];\r\n            if (responseHandler) {\r\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\r\n            }\r\n        }\r\n    }\r\n    function traceSendingRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-request', message);\r\n        }\r\n    }\r\n    function traceSendingNotification(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Sending notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-notification', message);\r\n        }\r\n    }\r\n    function traceSendingResponse(message, method, startTime) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-response', message);\r\n        }\r\n    }\r\n    function traceReceivedRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-request', message);\r\n        }\r\n    }\r\n    function traceReceivedNotification(message) {\r\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Received notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-notification', message);\r\n        }\r\n    }\r\n    function traceReceivedResponse(message, responsePromise) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            if (responsePromise) {\r\n                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\r\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\r\n            }\r\n            else {\r\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\r\n            }\r\n        }\r\n        else {\r\n            logLSPMessage('receive-response', message);\r\n        }\r\n    }\r\n    function logLSPMessage(type, message) {\r\n        if (!tracer || trace === Trace.Off) {\r\n            return;\r\n        }\r\n        const lspMessage = {\r\n            isLSPMessage: true,\r\n            type,\r\n            message,\r\n            timestamp: Date.now()\r\n        };\r\n        tracer.log(lspMessage);\r\n    }\r\n    function throwIfClosedOrDisposed() {\r\n        if (isClosed()) {\r\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\r\n        }\r\n        if (isDisposed()) {\r\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\r\n        }\r\n    }\r\n    function throwIfListening() {\r\n        if (isListening()) {\r\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\r\n        }\r\n    }\r\n    function throwIfNotListening() {\r\n        if (!isListening()) {\r\n            throw new Error('Call listen() first.');\r\n        }\r\n    }\r\n    function undefinedToNull(param) {\r\n        if (param === void 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function computeMessageParams(type, params) {\r\n        let result;\r\n        let numberOfParams = type.numberOfParams;\r\n        switch (numberOfParams) {\r\n            case 0:\r\n                result = null;\r\n                break;\r\n            case 1:\r\n                result = undefinedToNull(params[0]);\r\n                break;\r\n            default:\r\n                result = [];\r\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\r\n                    result.push(undefinedToNull(params[i]));\r\n                }\r\n                if (params.length < numberOfParams) {\r\n                    for (let i = params.length; i < numberOfParams; i++) {\r\n                        result.push(null);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n    let connection = {\r\n        sendNotification: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            let messageParams;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = params[0];\r\n                        break;\r\n                    default:\r\n                        messageParams = params;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n            }\r\n            let notificationMessage = {\r\n                jsonrpc: version,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingNotification(notificationMessage);\r\n            messageWriter.write(notificationMessage);\r\n        },\r\n        onNotification: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starNotificationHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    notificationHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    notificationHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        sendRequest: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfNotListening();\r\n            let method;\r\n            let messageParams;\r\n            let token = undefined;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        // The cancellation token is optional so it can also be undefined.\r\n                        if (cancellation_1.CancellationToken.is(params[0])) {\r\n                            messageParams = null;\r\n                            token = params[0];\r\n                        }\r\n                        else {\r\n                            messageParams = undefinedToNull(params[0]);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const last = params.length - 1;\r\n                        if (cancellation_1.CancellationToken.is(params[last])) {\r\n                            token = params[last];\r\n                            if (params.length === 2) {\r\n                                messageParams = undefinedToNull(params[0]);\r\n                            }\r\n                            else {\r\n                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));\r\n                            }\r\n                        }\r\n                        else {\r\n                            messageParams = params.map(value => undefinedToNull(value));\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n                let numberOfParams = type.numberOfParams;\r\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\r\n            }\r\n            let id = sequenceNumber++;\r\n            let result = new Promise((resolve, reject) => {\r\n                let requestMessage = {\r\n                    jsonrpc: version,\r\n                    id: id,\r\n                    method: method,\r\n                    params: messageParams\r\n                };\r\n                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };\r\n                traceSendingRequest(requestMessage);\r\n                try {\r\n                    messageWriter.write(requestMessage);\r\n                }\r\n                catch (e) {\r\n                    // Writing the message failed. So we need to reject the promise.\r\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\r\n                    responsePromise = null;\r\n                }\r\n                if (responsePromise) {\r\n                    responsePromises[String(id)] = responsePromise;\r\n                }\r\n            });\r\n            if (token) {\r\n                token.onCancellationRequested(() => {\r\n                    connection.sendNotification(CancelNotification.type, { id });\r\n                });\r\n            }\r\n            return result;\r\n        },\r\n        onRequest: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starRequestHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    requestHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    requestHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\r\n            let _sendNotification = false;\r\n            let _traceFormat = TraceFormat.Text;\r\n            if (sendNotificationOrTraceOptions !== void 0) {\r\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                    _sendNotification = sendNotificationOrTraceOptions;\r\n                }\r\n                else {\r\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\r\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\r\n                }\r\n            }\r\n            trace = _value;\r\n            traceFormat = _traceFormat;\r\n            if (trace === Trace.Off) {\r\n                tracer = undefined;\r\n            }\r\n            else {\r\n                tracer = _tracer;\r\n            }\r\n            if (_sendNotification && !isClosed() && !isDisposed()) {\r\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\r\n            }\r\n        },\r\n        onError: errorEmitter.event,\r\n        onClose: closeEmitter.event,\r\n        onUnhandledNotification: unhandledNotificationEmitter.event,\r\n        onDispose: disposeEmitter.event,\r\n        dispose: () => {\r\n            if (isDisposed()) {\r\n                return;\r\n            }\r\n            state = ConnectionState.Disposed;\r\n            disposeEmitter.fire(undefined);\r\n            let error = new Error('Connection got disposed.');\r\n            Object.keys(responsePromises).forEach((key) => {\r\n                responsePromises[key].reject(error);\r\n            });\r\n            responsePromises = Object.create(null);\r\n            requestTokens = Object.create(null);\r\n            messageQueue = new linkedMap_1.LinkedMap();\r\n            // Test for backwards compatibility\r\n            if (Is.func(messageWriter.dispose)) {\r\n                messageWriter.dispose();\r\n            }\r\n            if (Is.func(messageReader.dispose)) {\r\n                messageReader.dispose();\r\n            }\r\n        },\r\n        listen: () => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfListening();\r\n            state = ConnectionState.Listening;\r\n            messageReader.listen(callback);\r\n        },\r\n        inspect: () => {\r\n            console.log(\"inspect\");\r\n        }\r\n    };\r\n    connection.onNotification(LogTraceNotification.type, (params) => {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\r\n    });\r\n    return connection;\r\n}\r\nfunction isMessageReader(value) {\r\n    return value.listen !== void 0 && value.read === void 0;\r\n}\r\nfunction isMessageWriter(value) {\r\n    return value.write !== void 0 && value.end === void 0;\r\n}\r\nfunction createMessageConnection(input, output, logger, strategy) {\r\n    if (!logger) {\r\n        logger = exports.NullLogger;\r\n    }\r\n    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);\r\n    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);\r\n    return _createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n"]},"metadata":{},"sourceType":"script"}