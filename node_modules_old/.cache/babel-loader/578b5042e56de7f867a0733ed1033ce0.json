{"ast":null,"code":"'use strict';\n\nconst stringWidth = require('string-width');\n\nconst stripAnsi = require('strip-ansi');\n\nconst ESCAPES = new Set(['\\u001B', '\\u009B']);\nconst END_CODE = 39;\nconst ESCAPE_CODES = new Map([[0, 0], [1, 22], [2, 22], [3, 23], [4, 24], [7, 27], [8, 28], [9, 29], [30, 39], [31, 39], [32, 39], [33, 39], [34, 39], [35, 39], [36, 39], [37, 39], [90, 39], [40, 49], [41, 49], [42, 49], [43, 49], [44, 49], [45, 49], [46, 49], [47, 49]]);\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`; // Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\n\n\nconst wordLengths = str => str.split(' ').map(s => stringWidth(s)); // Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\n\n\nconst wrapWord = (rows, word, cols) => {\n  const arr = Array.from(word);\n  let insideEscape = false;\n  let visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n  for (const item of arr.entries()) {\n    const i = item[0];\n    const char = item[1];\n    const charLength = stringWidth(char);\n\n    if (visible + charLength <= cols) {\n      rows[rows.length - 1] += char;\n    } else {\n      rows.push(char);\n      visible = 0;\n    }\n\n    if (ESCAPES.has(char)) {\n      insideEscape = true;\n    } else if (insideEscape && char === 'm') {\n      insideEscape = false;\n      continue;\n    }\n\n    if (insideEscape) {\n      continue;\n    }\n\n    visible += charLength;\n\n    if (visible === cols && i < arr.length - 1) {\n      rows.push('');\n      visible = 0;\n    }\n  } // It's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case\n\n\n  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n    rows[rows.length - 2] += rows.pop();\n  }\n}; // The wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more\n// than cols characters\n//\n// 'soft' allows long words to expand past the column length\n\n\nconst exec = (str, cols, opts) => {\n  const options = opts || {};\n\n  if (str.trim() === '') {\n    return options.trim === false ? str : str.trim();\n  }\n\n  let pre = '';\n  let ret = '';\n  let escapeCode;\n  const lengths = wordLengths(str);\n  const words = str.split(' ');\n  const rows = [''];\n\n  for (const item of Array.from(words).entries()) {\n    const i = item[0];\n    const word = item[1];\n    rows[rows.length - 1] = options.trim === false ? rows[rows.length - 1] : rows[rows.length - 1].trim();\n    let rowLength = stringWidth(rows[rows.length - 1]);\n\n    if (rowLength || word === '') {\n      if (rowLength === cols && options.wordWrap === false) {\n        // If we start with a new word but the current row length equals the length of the columns, add a new row\n        rows.push('');\n        rowLength = 0;\n      }\n\n      rows[rows.length - 1] += ' ';\n      rowLength++;\n    } // In 'hard' wrap mode, the length of a line is\n    // never allowed to extend past 'cols'\n\n\n    if (lengths[i] > cols && options.hard) {\n      if (rowLength) {\n        rows.push('');\n      }\n\n      wrapWord(rows, word, cols);\n      continue;\n    }\n\n    if (rowLength + lengths[i] > cols && rowLength > 0) {\n      if (options.wordWrap === false && rowLength < cols) {\n        wrapWord(rows, word, cols);\n        continue;\n      }\n\n      rows.push('');\n    }\n\n    if (rowLength + lengths[i] > cols && options.wordWrap === false) {\n      wrapWord(rows, word, cols);\n      continue;\n    }\n\n    rows[rows.length - 1] += word;\n  }\n\n  pre = rows.map(r => options.trim === false ? r : r.trim()).join('\\n');\n\n  for (const item of Array.from(pre).entries()) {\n    const i = item[0];\n    const char = item[1];\n    ret += char;\n\n    if (ESCAPES.has(char)) {\n      const code = parseFloat(/\\d[^m]*/.exec(pre.slice(i, i + 4)));\n      escapeCode = code === END_CODE ? null : code;\n    }\n\n    const code = ESCAPE_CODES.get(Number(escapeCode));\n\n    if (escapeCode && code) {\n      if (pre[i + 1] === '\\n') {\n        ret += wrapAnsi(code);\n      } else if (char === '\\n') {\n        ret += wrapAnsi(escapeCode);\n      }\n    }\n  }\n\n  return ret;\n}; // For each newline, invoke the method separately\n\n\nmodule.exports = (str, cols, opts) => {\n  return String(str).normalize().split('\\n').map(line => exec(line, cols, opts)).join('\\n');\n};","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/log-update/node_modules/wrap-ansi/index.js"],"names":["stringWidth","require","stripAnsi","ESCAPES","Set","END_CODE","ESCAPE_CODES","Map","wrapAnsi","code","values","next","value","wordLengths","str","split","map","s","wrapWord","rows","word","cols","arr","Array","from","insideEscape","visible","length","item","entries","i","char","charLength","push","has","pop","exec","opts","options","trim","pre","ret","escapeCode","lengths","words","rowLength","wordWrap","hard","r","join","parseFloat","slice","get","Number","module","exports","String","normalize","line"],"mappings":"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","sourcesContent":["'use strict';\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\n\nconst ESCAPES = new Set([\n\t'\\u001B',\n\t'\\u009B'\n]);\n\nconst END_CODE = 39;\n\nconst ESCAPE_CODES = new Map([\n\t[0, 0],\n\t[1, 22],\n\t[2, 22],\n\t[3, 23],\n\t[4, 24],\n\t[7, 27],\n\t[8, 28],\n\t[9, 29],\n\t[30, 39],\n\t[31, 39],\n\t[32, 39],\n\t[33, 39],\n\t[34, 39],\n\t[35, 39],\n\t[36, 39],\n\t[37, 39],\n\t[90, 39],\n\t[40, 49],\n\t[41, 49],\n\t[42, 49],\n\t[43, 49],\n\t[44, 49],\n\t[45, 49],\n\t[46, 49],\n\t[47, 49]\n]);\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = str => str.split(' ').map(s => stringWidth(s));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, cols) => {\n\tconst arr = Array.from(word);\n\n\tlet insideEscape = false;\n\tlet visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n\tfor (const item of arr.entries()) {\n\t\tconst i = item[0];\n\t\tconst char = item[1];\n\t\tconst charLength = stringWidth(char);\n\n\t\tif (visible + charLength <= cols) {\n\t\t\trows[rows.length - 1] += char;\n\t\t} else {\n\t\t\trows.push(char);\n\t\t\tvisible = 0;\n\t\t}\n\n\t\tif (ESCAPES.has(char)) {\n\t\t\tinsideEscape = true;\n\t\t} else if (insideEscape && char === 'm') {\n\t\t\tinsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible += charLength;\n\n\t\tif (visible === cols && i < arr.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// It's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n};\n\n// The wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more\n// than cols characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (str, cols, opts) => {\n\tconst options = opts || {};\n\n\tif (str.trim() === '') {\n\t\treturn options.trim === false ? str : str.trim();\n\t}\n\n\tlet pre = '';\n\tlet ret = '';\n\tlet escapeCode;\n\n\tconst lengths = wordLengths(str);\n\tconst words = str.split(' ');\n\tconst rows = [''];\n\n\tfor (const item of Array.from(words).entries()) {\n\t\tconst i = item[0];\n\t\tconst word = item[1];\n\n\t\trows[rows.length - 1] = options.trim === false ? rows[rows.length - 1] : rows[rows.length - 1].trim();\n\t\tlet rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (rowLength || word === '') {\n\t\t\tif (rowLength === cols && options.wordWrap === false) {\n\t\t\t\t// If we start with a new word but the current row length equals the length of the columns, add a new row\n\t\t\t\trows.push('');\n\t\t\t\trowLength = 0;\n\t\t\t}\n\n\t\t\trows[rows.length - 1] += ' ';\n\t\t\trowLength++;\n\t\t}\n\n\t\t// In 'hard' wrap mode, the length of a line is\n\t\t// never allowed to extend past 'cols'\n\t\tif (lengths[i] > cols && options.hard) {\n\t\t\tif (rowLength) {\n\t\t\t\trows.push('');\n\t\t\t}\n\t\t\twrapWord(rows, word, cols);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[i] > cols && rowLength > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < cols) {\n\t\t\t\twrapWord(rows, word, cols);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\tif (rowLength + lengths[i] > cols && options.wordWrap === false) {\n\t\t\twrapWord(rows, word, cols);\n\t\t\tcontinue;\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tpre = rows.map(r => options.trim === false ? r : r.trim()).join('\\n');\n\n\tfor (const item of Array.from(pre).entries()) {\n\t\tconst i = item[0];\n\t\tconst char = item[1];\n\n\t\tret += char;\n\n\t\tif (ESCAPES.has(char)) {\n\t\t\tconst code = parseFloat(/\\d[^m]*/.exec(pre.slice(i, i + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tconst code = ESCAPE_CODES.get(Number(escapeCode));\n\n\t\tif (escapeCode && code) {\n\t\t\tif (pre[i + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(code);\n\t\t\t} else if (char === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (str, cols, opts) => {\n\treturn String(str)\n\t\t.normalize()\n\t\t.split('\\n')\n\t\t.map(line => exec(line, cols, opts))\n\t\t.join('\\n');\n};\n"]},"metadata":{},"sourceType":"script"}