{"ast":null,"code":"var common = require('./common');\n\nvar fs = require('fs');\n\ncommon.register('grep', _grep, {\n  globStart: 2,\n  // don't glob-expand the regex\n  canReceivePipe: true,\n  cmdOptions: {\n    'v': 'inverse',\n    'l': 'nameOnly'\n  }\n}); //@\n//@ ### grep([options,] regex_filter, file [, file ...])\n//@ ### grep([options,] regex_filter, file_array)\n//@ Available options:\n//@\n//@ + `-v`: Inverse the sense of the regex and print the lines not matching the criteria.\n//@ + `-l`: Print only filenames of matching files\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`.\n\nfunction _grep(options, regex, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n  if (!files && !pipe) common.error('no paths given', 2);\n  files = [].slice.call(arguments, 2);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var grep = [];\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, {\n        continue: true\n      });\n      return;\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    var lines = contents.split(/\\r*\\n/);\n\n    if (options.nameOnly) {\n      if (contents.match(regex)) {\n        grep.push(file);\n      }\n    } else {\n      lines.forEach(function (line) {\n        var matched = line.match(regex);\n\n        if (options.inverse && !matched || !options.inverse && matched) {\n          grep.push(line);\n        }\n      });\n    }\n  });\n  return grep.join('\\n') + '\\n';\n}\n\nmodule.exports = _grep;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/shelljs/src/grep.js"],"names":["common","require","fs","register","_grep","globStart","canReceivePipe","cmdOptions","options","regex","files","pipe","readFromPipe","error","slice","call","arguments","unshift","grep","forEach","file","existsSync","continue","contents","readFileSync","lines","split","nameOnly","match","push","line","matched","inverse","join","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAhB;;AAEAD,MAAM,CAACG,QAAP,CAAgB,MAAhB,EAAwBC,KAAxB,EAA+B;AAC7BC,EAAAA,SAAS,EAAE,CADkB;AACf;AACdC,EAAAA,cAAc,EAAE,IAFa;AAG7BC,EAAAA,UAAU,EAAE;AACV,SAAK,SADK;AAEV,SAAK;AAFK;AAHiB,CAA/B,E,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASH,KAAT,CAAeI,OAAf,EAAwBC,KAAxB,EAA+BC,KAA/B,EAAsC;AACpC;AACA,MAAIC,IAAI,GAAGX,MAAM,CAACY,YAAP,EAAX;AAEA,MAAI,CAACF,KAAD,IAAU,CAACC,IAAf,EAAqBX,MAAM,CAACa,KAAP,CAAa,gBAAb,EAA+B,CAA/B;AAErBH,EAAAA,KAAK,GAAG,GAAGI,KAAH,CAASC,IAAT,CAAcC,SAAd,EAAyB,CAAzB,CAAR;;AAEA,MAAIL,IAAJ,EAAU;AACRD,IAAAA,KAAK,CAACO,OAAN,CAAc,GAAd;AACD;;AAED,MAAIC,IAAI,GAAG,EAAX;AACAR,EAAAA,KAAK,CAACS,OAAN,CAAc,UAAUC,IAAV,EAAgB;AAC5B,QAAI,CAAClB,EAAE,CAACmB,UAAH,CAAcD,IAAd,CAAD,IAAwBA,IAAI,KAAK,GAArC,EAA0C;AACxCpB,MAAAA,MAAM,CAACa,KAAP,CAAa,gCAAgCO,IAA7C,EAAmD,CAAnD,EAAsD;AAAEE,QAAAA,QAAQ,EAAE;AAAZ,OAAtD;AACA;AACD;;AAED,QAAIC,QAAQ,GAAGH,IAAI,KAAK,GAAT,GAAeT,IAAf,GAAsBT,EAAE,CAACsB,YAAH,CAAgBJ,IAAhB,EAAsB,MAAtB,CAArC;AACA,QAAIK,KAAK,GAAGF,QAAQ,CAACG,KAAT,CAAe,OAAf,CAAZ;;AACA,QAAIlB,OAAO,CAACmB,QAAZ,EAAsB;AACpB,UAAIJ,QAAQ,CAACK,KAAT,CAAenB,KAAf,CAAJ,EAA2B;AACzBS,QAAAA,IAAI,CAACW,IAAL,CAAUT,IAAV;AACD;AACF,KAJD,MAIO;AACLK,MAAAA,KAAK,CAACN,OAAN,CAAc,UAAUW,IAAV,EAAgB;AAC5B,YAAIC,OAAO,GAAGD,IAAI,CAACF,KAAL,CAAWnB,KAAX,CAAd;;AACA,YAAKD,OAAO,CAACwB,OAAR,IAAmB,CAACD,OAArB,IAAkC,CAACvB,OAAO,CAACwB,OAAT,IAAoBD,OAA1D,EAAoE;AAClEb,UAAAA,IAAI,CAACW,IAAL,CAAUC,IAAV;AACD;AACF,OALD;AAMD;AACF,GApBD;AAsBA,SAAOZ,IAAI,CAACe,IAAL,CAAU,IAAV,IAAkB,IAAzB;AACD;;AACDC,MAAM,CAACC,OAAP,GAAiB/B,KAAjB","sourcesContent":["var common = require('./common');\nvar fs = require('fs');\n\ncommon.register('grep', _grep, {\n  globStart: 2, // don't glob-expand the regex\n  canReceivePipe: true,\n  cmdOptions: {\n    'v': 'inverse',\n    'l': 'nameOnly',\n  },\n});\n\n//@\n//@ ### grep([options,] regex_filter, file [, file ...])\n//@ ### grep([options,] regex_filter, file_array)\n//@ Available options:\n//@\n//@ + `-v`: Inverse the sense of the regex and print the lines not matching the criteria.\n//@ + `-l`: Print only filenames of matching files\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`.\nfunction _grep(options, regex, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n\n  if (!files && !pipe) common.error('no paths given', 2);\n\n  files = [].slice.call(arguments, 2);\n\n  if (pipe) {\n    files.unshift('-');\n  }\n\n  var grep = [];\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, { continue: true });\n      return;\n    }\n\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    var lines = contents.split(/\\r*\\n/);\n    if (options.nameOnly) {\n      if (contents.match(regex)) {\n        grep.push(file);\n      }\n    } else {\n      lines.forEach(function (line) {\n        var matched = line.match(regex);\n        if ((options.inverse && !matched) || (!options.inverse && matched)) {\n          grep.push(line);\n        }\n      });\n    }\n  });\n\n  return grep.join('\\n') + '\\n';\n}\nmodule.exports = _grep;\n"]},"metadata":{},"sourceType":"script"}