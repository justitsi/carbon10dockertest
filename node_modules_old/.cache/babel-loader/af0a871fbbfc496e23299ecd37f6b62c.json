{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst castArray_1 = tslib_1.__importDefault(require(\"lodash/castArray\"));\n\nconst util_1 = require(\"util\");\n\nclass ActionBase {\n  constructor() {\n    this.std = 'stderr';\n    this.stdmockOrigs = {\n      stdout: process.stdout.write,\n      stderr: process.stderr.write\n    };\n  }\n\n  start(action, status, opts = {}) {\n    this.std = opts.stdout ? 'stdout' : 'stderr';\n    const task = {\n      action,\n      status,\n      active: Boolean(this.task && this.task.active)\n    };\n    this.task = task;\n\n    this._start();\n\n    task.active = true;\n\n    this._stdout(true);\n  }\n\n  stop(msg = 'done') {\n    const task = this.task;\n\n    if (!task) {\n      return;\n    }\n\n    this._stop(msg);\n\n    task.active = false;\n    this.task = undefined;\n\n    this._stdout(false);\n  }\n\n  get globals() {\n    global['cli-ux'] = global['cli-ux'] || {};\n    const globals = global['cli-ux'];\n    globals.action = globals.action || {};\n    return globals;\n  }\n\n  get task() {\n    return this.globals.action.task;\n  }\n\n  set task(task) {\n    this.globals.action.task = task;\n  }\n\n  get output() {\n    return this.globals.output;\n  }\n\n  set output(output) {\n    this.globals.output = output;\n  }\n\n  get running() {\n    return Boolean(this.task);\n  }\n\n  get status() {\n    return this.task ? this.task.status : undefined;\n  }\n\n  set status(status) {\n    const task = this.task;\n\n    if (!task) {\n      return;\n    }\n\n    if (task.status === status) {\n      return;\n    }\n\n    this._updateStatus(status, task.status);\n\n    task.status = status;\n  }\n\n  async pauseAsync(fn, icon) {\n    const task = this.task;\n    const active = task && task.active;\n\n    if (task && active) {\n      this._pause(icon);\n\n      this._stdout(false);\n\n      task.active = false;\n    }\n\n    const ret = await fn();\n\n    if (task && active) {\n      this._resume();\n    }\n\n    return ret;\n  }\n\n  pause(fn, icon) {\n    const task = this.task;\n    const active = task && task.active;\n\n    if (task && active) {\n      this._pause(icon);\n\n      this._stdout(false);\n\n      task.active = false;\n    }\n\n    const ret = fn();\n\n    if (task && active) {\n      this._resume();\n    }\n\n    return ret;\n  }\n\n  _start() {\n    throw new Error('not implemented');\n  }\n\n  _stop(_) {\n    throw new Error('not implemented');\n  }\n\n  _resume() {\n    if (this.task) this.start(this.task.action, this.task.status);\n  }\n\n  _pause(_) {\n    throw new Error('not implemented');\n  } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  _updateStatus(_, __) {}\n  /**\n   * mock out stdout/stderr so it doesn't screw up the rendering\n   */\n\n\n  _stdout(toggle) {\n    try {\n      const outputs = ['stdout', 'stderr'];\n\n      if (toggle) {\n        if (this.stdmocks) return;\n        this.stdmockOrigs = {\n          stdout: process.stdout.write,\n          stderr: process.stderr.write\n        };\n        this.stdmocks = [];\n\n        for (const std of outputs) {\n          process[std].write = (...args) => {\n            this.stdmocks.push([std, args]);\n          };\n        }\n      } else {\n        if (!this.stdmocks) return; // this._write('stderr', '\\nresetstdmock\\n\\n\\n')\n\n        delete this.stdmocks;\n\n        for (const std of outputs) process[std].write = this.stdmockOrigs[std];\n      }\n    } catch (error) {\n      this._write('stderr', util_1.inspect(error));\n    }\n  }\n  /**\n   * flush mocked stdout/stderr\n   */\n\n\n  _flushStdout() {\n    try {\n      let output = '';\n      let std;\n\n      while (this.stdmocks && this.stdmocks.length) {\n        const cur = this.stdmocks.shift();\n        std = cur[0];\n\n        this._write(std, cur[1]);\n\n        output += cur[1][0].toString('utf8');\n      } // add newline if there isn't one already\n      // otherwise we'll just overwrite it when we render\n\n\n      if (output && std && output[output.length - 1] !== '\\n') {\n        this._write(std, '\\n');\n      }\n    } catch (error) {\n      this._write('stderr', util_1.inspect(error));\n    }\n  }\n  /**\n   * write to the real stdout/stderr\n   */\n\n\n  _write(std, s) {\n    this.stdmockOrigs[std].apply(process[std], castArray_1.default(s));\n  }\n\n}\n\nexports.ActionBase = ActionBase;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/cli-ux/lib/action/base.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","castArray_1","__importDefault","util_1","ActionBase","constructor","std","stdmockOrigs","stdout","process","write","stderr","start","action","status","opts","task","active","Boolean","_start","_stdout","stop","msg","_stop","undefined","globals","global","output","running","_updateStatus","pauseAsync","fn","icon","_pause","ret","_resume","pause","Error","_","__","toggle","outputs","stdmocks","args","push","error","_write","inspect","_flushStdout","length","cur","shift","toString","s","apply","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst castArray_1 = tslib_1.__importDefault(require(\"lodash/castArray\"));\nconst util_1 = require(\"util\");\nclass ActionBase {\n    constructor() {\n        this.std = 'stderr';\n        this.stdmockOrigs = {\n            stdout: process.stdout.write,\n            stderr: process.stderr.write,\n        };\n    }\n    start(action, status, opts = {}) {\n        this.std = opts.stdout ? 'stdout' : 'stderr';\n        const task = { action, status, active: Boolean(this.task && this.task.active) };\n        this.task = task;\n        this._start();\n        task.active = true;\n        this._stdout(true);\n    }\n    stop(msg = 'done') {\n        const task = this.task;\n        if (!task) {\n            return;\n        }\n        this._stop(msg);\n        task.active = false;\n        this.task = undefined;\n        this._stdout(false);\n    }\n    get globals() {\n        global['cli-ux'] = global['cli-ux'] || {};\n        const globals = global['cli-ux'];\n        globals.action = globals.action || {};\n        return globals;\n    }\n    get task() {\n        return this.globals.action.task;\n    }\n    set task(task) {\n        this.globals.action.task = task;\n    }\n    get output() {\n        return this.globals.output;\n    }\n    set output(output) {\n        this.globals.output = output;\n    }\n    get running() {\n        return Boolean(this.task);\n    }\n    get status() {\n        return this.task ? this.task.status : undefined;\n    }\n    set status(status) {\n        const task = this.task;\n        if (!task) {\n            return;\n        }\n        if (task.status === status) {\n            return;\n        }\n        this._updateStatus(status, task.status);\n        task.status = status;\n    }\n    async pauseAsync(fn, icon) {\n        const task = this.task;\n        const active = task && task.active;\n        if (task && active) {\n            this._pause(icon);\n            this._stdout(false);\n            task.active = false;\n        }\n        const ret = await fn();\n        if (task && active) {\n            this._resume();\n        }\n        return ret;\n    }\n    pause(fn, icon) {\n        const task = this.task;\n        const active = task && task.active;\n        if (task && active) {\n            this._pause(icon);\n            this._stdout(false);\n            task.active = false;\n        }\n        const ret = fn();\n        if (task && active) {\n            this._resume();\n        }\n        return ret;\n    }\n    _start() {\n        throw new Error('not implemented');\n    }\n    _stop(_) {\n        throw new Error('not implemented');\n    }\n    _resume() {\n        if (this.task)\n            this.start(this.task.action, this.task.status);\n    }\n    _pause(_) {\n        throw new Error('not implemented');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    _updateStatus(_, __) { }\n    /**\n     * mock out stdout/stderr so it doesn't screw up the rendering\n     */\n    _stdout(toggle) {\n        try {\n            const outputs = ['stdout', 'stderr'];\n            if (toggle) {\n                if (this.stdmocks)\n                    return;\n                this.stdmockOrigs = {\n                    stdout: process.stdout.write,\n                    stderr: process.stderr.write,\n                };\n                this.stdmocks = [];\n                for (const std of outputs) {\n                    process[std].write = (...args) => {\n                        this.stdmocks.push([std, args]);\n                    };\n                }\n            }\n            else {\n                if (!this.stdmocks)\n                    return;\n                // this._write('stderr', '\\nresetstdmock\\n\\n\\n')\n                delete this.stdmocks;\n                for (const std of outputs)\n                    process[std].write = this.stdmockOrigs[std];\n            }\n        }\n        catch (error) {\n            this._write('stderr', util_1.inspect(error));\n        }\n    }\n    /**\n     * flush mocked stdout/stderr\n     */\n    _flushStdout() {\n        try {\n            let output = '';\n            let std;\n            while (this.stdmocks && this.stdmocks.length) {\n                const cur = this.stdmocks.shift();\n                std = cur[0];\n                this._write(std, cur[1]);\n                output += cur[1][0].toString('utf8');\n            }\n            // add newline if there isn't one already\n            // otherwise we'll just overwrite it when we render\n            if (output && std && output[output.length - 1] !== '\\n') {\n                this._write(std, '\\n');\n            }\n        }\n        catch (error) {\n            this._write('stderr', util_1.inspect(error));\n        }\n    }\n    /**\n     * write to the real stdout/stderr\n     */\n    _write(std, s) {\n        this.stdmockOrigs[std].apply(process[std], castArray_1.default(s));\n    }\n}\nexports.ActionBase = ActionBase;\n"]},"metadata":{},"sourceType":"script"}