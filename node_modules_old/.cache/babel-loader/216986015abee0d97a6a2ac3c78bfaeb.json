{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url = require(\"url\");\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst child_process_1 = require(\"child_process\");\n/**\r\n * @deprecated Use the `vscode-uri` npm module which provides a more\r\n * complete implementation of handling VS Code URIs.\r\n */\n\n\nfunction uriToFilePath(uri) {\n  let parsed = url.parse(uri);\n\n  if (parsed.protocol !== 'file:' || !parsed.path) {\n    return undefined;\n  }\n\n  let segments = parsed.path.split('/');\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    segments[i] = decodeURIComponent(segments[i]);\n  }\n\n  if (process.platform === 'win32' && segments.length > 1) {\n    let first = segments[0];\n    let second = segments[1]; // Do we have a drive letter and we started with a / which is the\n    // case if the first segement is empty (see split above)\n\n    if (first.length === 0 && second.length > 1 && second[1] === ':') {\n      // Remove first slash\n      segments.shift();\n    }\n  }\n\n  return path.normalize(segments.join('/'));\n}\n\nexports.uriToFilePath = uriToFilePath;\n\nfunction isWindows() {\n  return process.platform === 'win32';\n}\n\nfunction resolveModule(workspaceRoot, moduleName) {\n  let nodePathKey = 'NODE_PATH';\n  return new Promise((resolve, reject) => {\n    let nodePath = [];\n\n    if (workspaceRoot) {\n      nodePath.push(path.join(workspaceRoot, 'node_modules'));\n    }\n\n    child_process_1.exec('npm config get prefix', (error, stdout, _stderr) => {\n      if (!error) {\n        let globalPath = stdout.replace(/[\\s\\r\\n]+$/, '');\n\n        if (globalPath.length > 0) {\n          if (isWindows()) {\n            nodePath.push(path.join(globalPath, 'node_modules'));\n          } else {\n            nodePath.push(path.join(globalPath, 'lib', 'node_modules'));\n          }\n        }\n      }\n\n      let separator = isWindows() ? ';' : ':';\n      let env = process.env;\n      let newEnv = Object.create(null);\n      Object.keys(env).forEach(key => newEnv[key] = env[key]);\n\n      if (newEnv[nodePathKey]) {\n        newEnv[nodePathKey] = nodePath.join(separator) + separator + newEnv[nodePathKey];\n      } else {\n        newEnv[nodePathKey] = nodePath.join(separator);\n      }\n\n      newEnv['ELECTRON_RUN_AS_NODE'] = '1';\n\n      try {\n        let cp = child_process_1.fork(path.join(__dirname, 'resolve.js'), [], {\n          env: newEnv,\n          execArgv: []\n        });\n\n        if (cp.pid === void 0) {\n          reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\n          return;\n        }\n\n        cp.on('message', message => {\n          if (message.command === 'resolve') {\n            let toRequire = moduleName;\n\n            if (message.success) {\n              toRequire = message.result;\n            }\n\n            cp.send({\n              command: 'exit'\n            });\n\n            try {\n              resolve(require(toRequire));\n            } catch (error) {\n              reject(error);\n            }\n          }\n        });\n        let message = {\n          command: 'resolve',\n          args: moduleName\n        };\n        cp.send(message);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  });\n}\n\nexports.resolveModule = resolveModule;\n\nfunction resolve(moduleName, nodePath, cwd, tracer) {\n  const nodePathKey = 'NODE_PATH';\n  const app = [\"var p = process;\", \"p.on('message',function(m){\", \"if(m.c==='e'){\", \"p.exit(0);\", \"}\", \"else if(m.c==='rs'){\", \"try{\", \"var r=require.resolve(m.a);\", \"p.send({c:'r',s:true,r:r});\", \"}\", \"catch(err){\", \"p.send({c:'r',s:false});\", \"}\", \"}\", \"});\"].join('');\n  return new Promise((resolve, reject) => {\n    let env = process.env;\n    let newEnv = Object.create(null);\n    Object.keys(env).forEach(key => newEnv[key] = env[key]);\n\n    if (nodePath) {\n      if (newEnv[nodePathKey]) {\n        newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];\n      } else {\n        newEnv[nodePathKey] = nodePath;\n      }\n\n      if (tracer) {\n        tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);\n      }\n    }\n\n    newEnv['ELECTRON_RUN_AS_NODE'] = '1';\n\n    try {\n      let cp = child_process_1.fork('', [], {\n        cwd: cwd,\n        env: newEnv,\n        execArgv: ['-e', app]\n      });\n\n      if (cp.pid === void 0) {\n        reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\n        return;\n      }\n\n      cp.on('error', error => {\n        reject(error);\n      });\n      cp.on('message', message => {\n        if (message.c === 'r') {\n          cp.send({\n            c: 'e'\n          });\n\n          if (message.s) {\n            resolve(message.r);\n          } else {\n            reject(new Error(`Failed to resolve module: ${moduleName}`));\n          }\n        }\n      });\n      let message = {\n        c: 'rs',\n        a: moduleName\n      };\n      cp.send(message);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nexports.resolve = resolve;\n\nfunction resolveGlobalNodePath(tracer) {\n  let npmCommand = 'npm';\n  let options = {\n    encoding: 'utf8'\n  };\n\n  if (isWindows()) {\n    npmCommand = 'npm.cmd';\n    options.shell = true;\n  }\n\n  let handler = () => {};\n\n  try {\n    process.on('SIGPIPE', handler);\n    let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;\n\n    if (!stdout) {\n      if (tracer) {\n        tracer(`'npm config get prefix' didn't return a value.`);\n      }\n\n      return undefined;\n    }\n\n    let prefix = stdout.trim();\n\n    if (tracer) {\n      tracer(`'npm config get prefix' value is: ${prefix}`);\n    }\n\n    if (prefix.length > 0) {\n      if (isWindows()) {\n        return path.join(prefix, 'node_modules');\n      } else {\n        return path.join(prefix, 'lib', 'node_modules');\n      }\n    }\n\n    return undefined;\n  } catch (err) {\n    return undefined;\n  } finally {\n    process.removeListener('SIGPIPE', handler);\n  }\n}\n\nexports.resolveGlobalNodePath = resolveGlobalNodePath;\n\nfunction resolveGlobalYarnPath(tracer) {\n  let yarnCommand = 'yarn';\n  let options = {\n    encoding: 'utf8'\n  };\n\n  if (isWindows()) {\n    yarnCommand = 'yarn.cmd';\n    options.shell = true;\n  }\n\n  let handler = () => {};\n\n  try {\n    process.on('SIGPIPE', handler);\n    let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);\n    let stdout = results.stdout;\n\n    if (!stdout) {\n      if (tracer) {\n        tracer(`'yarn global dir' didn't return a value.`);\n\n        if (results.stderr) {\n          tracer(results.stderr);\n        }\n      }\n\n      return undefined;\n    }\n\n    let lines = stdout.trim().split(/\\r?\\n/);\n\n    for (let line of lines) {\n      try {\n        let yarn = JSON.parse(line);\n\n        if (yarn.type === 'log') {\n          return path.join(yarn.data, 'node_modules');\n        }\n      } catch (e) {// Do nothing. Ignore the line\n      }\n    }\n\n    return undefined;\n  } catch (err) {\n    return undefined;\n  } finally {\n    process.removeListener('SIGPIPE', handler);\n  }\n}\n\nexports.resolveGlobalYarnPath = resolveGlobalYarnPath;\nvar FileSystem;\n\n(function (FileSystem) {\n  let _isCaseSensitive = undefined;\n\n  function isCaseSensitive() {\n    if (_isCaseSensitive !== void 0) {\n      return _isCaseSensitive;\n    }\n\n    if (process.platform === 'win32') {\n      _isCaseSensitive = false;\n    } else {\n      // convert current file name to upper case / lower case and check if file exists\n      // (guards against cases when name is already all uppercase or lowercase)\n      _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());\n    }\n\n    return _isCaseSensitive;\n  }\n\n  FileSystem.isCaseSensitive = isCaseSensitive;\n\n  function isParent(parent, child) {\n    if (isCaseSensitive()) {\n      return path.normalize(child).indexOf(path.normalize(parent)) === 0;\n    } else {\n      return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) == 0;\n    }\n  }\n\n  FileSystem.isParent = isParent;\n})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));\n\nfunction resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {\n  if (nodePath) {\n    if (!path.isAbsolute(nodePath)) {\n      nodePath = path.join(workspaceRoot, nodePath);\n    }\n\n    return resolve(moduleName, nodePath, nodePath, tracer).then(value => {\n      if (FileSystem.isParent(nodePath, value)) {\n        return value;\n      } else {\n        return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));\n      }\n    }).then(undefined, _error => {\n      return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n    });\n  } else {\n    return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n  }\n}\n\nexports.resolveModulePath = resolveModulePath;\n/**\r\n * Resolves the given module relative to the given workspace root. In contrast to\r\n * `resolveModule` this method considers the parent chain as well.\r\n */\n\nfunction resolveModule2(workspaceRoot, moduleName, nodePath, tracer) {\n  return resolveModulePath(workspaceRoot, moduleName, nodePath, tracer).then(path => {\n    if (tracer) {\n      tracer(`Module ${moduleName} got resolved to ${path}`);\n    }\n\n    return require(path);\n  });\n}\n\nexports.resolveModule2 = resolveModule2;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/vscode-languageserver/lib/files.js"],"names":["Object","defineProperty","exports","value","url","require","path","fs","child_process_1","uriToFilePath","uri","parsed","parse","protocol","undefined","segments","split","i","len","length","decodeURIComponent","process","platform","first","second","shift","normalize","join","isWindows","resolveModule","workspaceRoot","moduleName","nodePathKey","Promise","resolve","reject","nodePath","push","exec","error","stdout","_stderr","globalPath","replace","separator","env","newEnv","create","keys","forEach","key","cp","fork","__dirname","execArgv","pid","Error","on","message","command","toRequire","success","result","send","args","cwd","tracer","app","delimiter","c","s","r","a","resolveGlobalNodePath","npmCommand","options","encoding","shell","handler","spawnSync","prefix","trim","err","removeListener","resolveGlobalYarnPath","yarnCommand","results","stderr","lines","line","yarn","JSON","type","data","e","FileSystem","_isCaseSensitive","isCaseSensitive","existsSync","__filename","toUpperCase","toLowerCase","isParent","parent","child","indexOf","resolveModulePath","isAbsolute","then","_error","resolveModule2"],"mappings":"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","sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst url = require(\"url\");\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\nconst child_process_1 = require(\"child_process\");\r\n/**\r\n * @deprecated Use the `vscode-uri` npm module which provides a more\r\n * complete implementation of handling VS Code URIs.\r\n */\r\nfunction uriToFilePath(uri) {\r\n    let parsed = url.parse(uri);\r\n    if (parsed.protocol !== 'file:' || !parsed.path) {\r\n        return undefined;\r\n    }\r\n    let segments = parsed.path.split('/');\r\n    for (var i = 0, len = segments.length; i < len; i++) {\r\n        segments[i] = decodeURIComponent(segments[i]);\r\n    }\r\n    if (process.platform === 'win32' && segments.length > 1) {\r\n        let first = segments[0];\r\n        let second = segments[1];\r\n        // Do we have a drive letter and we started with a / which is the\r\n        // case if the first segement is empty (see split above)\r\n        if (first.length === 0 && second.length > 1 && second[1] === ':') {\r\n            // Remove first slash\r\n            segments.shift();\r\n        }\r\n    }\r\n    return path.normalize(segments.join('/'));\r\n}\r\nexports.uriToFilePath = uriToFilePath;\r\nfunction isWindows() {\r\n    return process.platform === 'win32';\r\n}\r\nfunction resolveModule(workspaceRoot, moduleName) {\r\n    let nodePathKey = 'NODE_PATH';\r\n    return new Promise((resolve, reject) => {\r\n        let nodePath = [];\r\n        if (workspaceRoot) {\r\n            nodePath.push(path.join(workspaceRoot, 'node_modules'));\r\n        }\r\n        child_process_1.exec('npm config get prefix', (error, stdout, _stderr) => {\r\n            if (!error) {\r\n                let globalPath = stdout.replace(/[\\s\\r\\n]+$/, '');\r\n                if (globalPath.length > 0) {\r\n                    if (isWindows()) {\r\n                        nodePath.push(path.join(globalPath, 'node_modules'));\r\n                    }\r\n                    else {\r\n                        nodePath.push(path.join(globalPath, 'lib', 'node_modules'));\r\n                    }\r\n                }\r\n            }\r\n            let separator = isWindows() ? ';' : ':';\r\n            let env = process.env;\r\n            let newEnv = Object.create(null);\r\n            Object.keys(env).forEach(key => newEnv[key] = env[key]);\r\n            if (newEnv[nodePathKey]) {\r\n                newEnv[nodePathKey] = nodePath.join(separator) + separator + newEnv[nodePathKey];\r\n            }\r\n            else {\r\n                newEnv[nodePathKey] = nodePath.join(separator);\r\n            }\r\n            newEnv['ELECTRON_RUN_AS_NODE'] = '1';\r\n            try {\r\n                let cp = child_process_1.fork(path.join(__dirname, 'resolve.js'), [], { env: newEnv, execArgv: [] });\r\n                if (cp.pid === void 0) {\r\n                    reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\r\n                    return;\r\n                }\r\n                cp.on('message', (message) => {\r\n                    if (message.command === 'resolve') {\r\n                        let toRequire = moduleName;\r\n                        if (message.success) {\r\n                            toRequire = message.result;\r\n                        }\r\n                        cp.send({ command: 'exit' });\r\n                        try {\r\n                            resolve(require(toRequire));\r\n                        }\r\n                        catch (error) {\r\n                            reject(error);\r\n                        }\r\n                    }\r\n                });\r\n                let message = {\r\n                    command: 'resolve',\r\n                    args: moduleName\r\n                };\r\n                cp.send(message);\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    });\r\n}\r\nexports.resolveModule = resolveModule;\r\nfunction resolve(moduleName, nodePath, cwd, tracer) {\r\n    const nodePathKey = 'NODE_PATH';\r\n    const app = [\r\n        \"var p = process;\",\r\n        \"p.on('message',function(m){\",\r\n        \"if(m.c==='e'){\",\r\n        \"p.exit(0);\",\r\n        \"}\",\r\n        \"else if(m.c==='rs'){\",\r\n        \"try{\",\r\n        \"var r=require.resolve(m.a);\",\r\n        \"p.send({c:'r',s:true,r:r});\",\r\n        \"}\",\r\n        \"catch(err){\",\r\n        \"p.send({c:'r',s:false});\",\r\n        \"}\",\r\n        \"}\",\r\n        \"});\"\r\n    ].join('');\r\n    return new Promise((resolve, reject) => {\r\n        let env = process.env;\r\n        let newEnv = Object.create(null);\r\n        Object.keys(env).forEach(key => newEnv[key] = env[key]);\r\n        if (nodePath) {\r\n            if (newEnv[nodePathKey]) {\r\n                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];\r\n            }\r\n            else {\r\n                newEnv[nodePathKey] = nodePath;\r\n            }\r\n            if (tracer) {\r\n                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);\r\n            }\r\n        }\r\n        newEnv['ELECTRON_RUN_AS_NODE'] = '1';\r\n        try {\r\n            let cp = child_process_1.fork('', [], {\r\n                cwd: cwd,\r\n                env: newEnv,\r\n                execArgv: ['-e', app]\r\n            });\r\n            if (cp.pid === void 0) {\r\n                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\r\n                return;\r\n            }\r\n            cp.on('error', (error) => {\r\n                reject(error);\r\n            });\r\n            cp.on('message', (message) => {\r\n                if (message.c === 'r') {\r\n                    cp.send({ c: 'e' });\r\n                    if (message.s) {\r\n                        resolve(message.r);\r\n                    }\r\n                    else {\r\n                        reject(new Error(`Failed to resolve module: ${moduleName}`));\r\n                    }\r\n                }\r\n            });\r\n            let message = {\r\n                c: 'rs',\r\n                a: moduleName\r\n            };\r\n            cp.send(message);\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\nexports.resolve = resolve;\r\nfunction resolveGlobalNodePath(tracer) {\r\n    let npmCommand = 'npm';\r\n    let options = {\r\n        encoding: 'utf8'\r\n    };\r\n    if (isWindows()) {\r\n        npmCommand = 'npm.cmd';\r\n        options.shell = true;\r\n    }\r\n    let handler = () => { };\r\n    try {\r\n        process.on('SIGPIPE', handler);\r\n        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;\r\n        if (!stdout) {\r\n            if (tracer) {\r\n                tracer(`'npm config get prefix' didn't return a value.`);\r\n            }\r\n            return undefined;\r\n        }\r\n        let prefix = stdout.trim();\r\n        if (tracer) {\r\n            tracer(`'npm config get prefix' value is: ${prefix}`);\r\n        }\r\n        if (prefix.length > 0) {\r\n            if (isWindows()) {\r\n                return path.join(prefix, 'node_modules');\r\n            }\r\n            else {\r\n                return path.join(prefix, 'lib', 'node_modules');\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    catch (err) {\r\n        return undefined;\r\n    }\r\n    finally {\r\n        process.removeListener('SIGPIPE', handler);\r\n    }\r\n}\r\nexports.resolveGlobalNodePath = resolveGlobalNodePath;\r\nfunction resolveGlobalYarnPath(tracer) {\r\n    let yarnCommand = 'yarn';\r\n    let options = {\r\n        encoding: 'utf8'\r\n    };\r\n    if (isWindows()) {\r\n        yarnCommand = 'yarn.cmd';\r\n        options.shell = true;\r\n    }\r\n    let handler = () => { };\r\n    try {\r\n        process.on('SIGPIPE', handler);\r\n        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);\r\n        let stdout = results.stdout;\r\n        if (!stdout) {\r\n            if (tracer) {\r\n                tracer(`'yarn global dir' didn't return a value.`);\r\n                if (results.stderr) {\r\n                    tracer(results.stderr);\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n        let lines = stdout.trim().split(/\\r?\\n/);\r\n        for (let line of lines) {\r\n            try {\r\n                let yarn = JSON.parse(line);\r\n                if (yarn.type === 'log') {\r\n                    return path.join(yarn.data, 'node_modules');\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Do nothing. Ignore the line\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    catch (err) {\r\n        return undefined;\r\n    }\r\n    finally {\r\n        process.removeListener('SIGPIPE', handler);\r\n    }\r\n}\r\nexports.resolveGlobalYarnPath = resolveGlobalYarnPath;\r\nvar FileSystem;\r\n(function (FileSystem) {\r\n    let _isCaseSensitive = undefined;\r\n    function isCaseSensitive() {\r\n        if (_isCaseSensitive !== void 0) {\r\n            return _isCaseSensitive;\r\n        }\r\n        if (process.platform === 'win32') {\r\n            _isCaseSensitive = false;\r\n        }\r\n        else {\r\n            // convert current file name to upper case / lower case and check if file exists\r\n            // (guards against cases when name is already all uppercase or lowercase)\r\n            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());\r\n        }\r\n        return _isCaseSensitive;\r\n    }\r\n    FileSystem.isCaseSensitive = isCaseSensitive;\r\n    function isParent(parent, child) {\r\n        if (isCaseSensitive()) {\r\n            return path.normalize(child).indexOf(path.normalize(parent)) === 0;\r\n        }\r\n        else {\r\n            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) == 0;\r\n        }\r\n    }\r\n    FileSystem.isParent = isParent;\r\n})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));\r\nfunction resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {\r\n    if (nodePath) {\r\n        if (!path.isAbsolute(nodePath)) {\r\n            nodePath = path.join(workspaceRoot, nodePath);\r\n        }\r\n        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {\r\n            if (FileSystem.isParent(nodePath, value)) {\r\n                return value;\r\n            }\r\n            else {\r\n                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));\r\n            }\r\n        }).then(undefined, (_error) => {\r\n            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\r\n        });\r\n    }\r\n    else {\r\n        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\r\n    }\r\n}\r\nexports.resolveModulePath = resolveModulePath;\r\n/**\r\n * Resolves the given module relative to the given workspace root. In contrast to\r\n * `resolveModule` this method considers the parent chain as well.\r\n */\r\nfunction resolveModule2(workspaceRoot, moduleName, nodePath, tracer) {\r\n    return resolveModulePath(workspaceRoot, moduleName, nodePath, tracer).then((path) => {\r\n        if (tracer) {\r\n            tracer(`Module ${moduleName} got resolved to ${path}`);\r\n        }\r\n        return require(path);\r\n    });\r\n}\r\nexports.resolveModule2 = resolveModule2;\r\n"]},"metadata":{},"sourceType":"script"}