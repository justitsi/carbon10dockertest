{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniqueTypeNamesWithFields = exports.existedTypeNameMessage = exports.duplicateTypeNameMessage = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nfunction duplicateTypeNameMessage(typeName) {\n  return `There can be only one type named \"${typeName}\".`;\n}\n\nexports.duplicateTypeNameMessage = duplicateTypeNameMessage;\n\nfunction existedTypeNameMessage(typeName) {\n  return `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`;\n}\n\nexports.existedTypeNameMessage = existedTypeNameMessage;\n\nfunction UniqueTypeNamesWithFields(context) {\n  const knownTypes = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n    const typeFromSchema = schema && schema.getType(typeName);\n    const typeNodeFromSchema = typeFromSchema && typeFromSchema.astNode;\n    const typeNodeFromDefs = knownTypes[typeName];\n    const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n\n    if (duplicateTypeNode) {\n      const possibleErrors = [];\n      const {\n        kind,\n        fields\n      } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n      const fieldsDiff = Object.entries(fields);\n      const typesHaveSameShape = fieldsDiff.length === 0 || fieldsDiff.every(([fieldName, types]) => {\n        if (types.length === 2) {\n          possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_FIELD_TYPE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName, fieldName)}A field was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${typeName}.${fieldName}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the fields and their types must be identical.`, [node, duplicateTypeNode]));\n          return true;\n        }\n\n        return false;\n      });\n\n      if (typesHaveSameShape) {\n        possibleErrors.forEach(error => context.reportError(error));\n\n        if (kind.length > 0) {\n          context.reportError(utils_1.errorWithCode('VALUE_TYPE_KIND_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}Found kind mismatch on expected value type belonging to services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`. \\`${typeName}\\` is defined as both a \\`${kind[0]}\\` and a \\`${kind[1]}\\`. In order to define \\`${typeName}\\` in multiple places, the kinds must be identical.`, [node, duplicateTypeNode]));\n        }\n\n        if (utils_1.isTypeNodeAnEntity(node) || utils_1.isTypeNodeAnEntity(duplicateTypeNode)) {\n          const entityNode = utils_1.isTypeNodeAnEntity(duplicateTypeNode) ? duplicateTypeNode : node;\n          context.reportError(utils_1.errorWithCode('VALUE_TYPE_NO_ENTITY', `${utils_1.logServiceAndType(entityNode.serviceName, typeName)}Value types cannot be entities (using the \\`@key\\` directive). Please ensure that the \\`${typeName}\\` type is extended properly or remove the \\`@key\\` directive if this is not an entity.`, [node, duplicateTypeNode]));\n        }\n\n        return false;\n      }\n    }\n\n    if (typeFromSchema) {\n      context.reportError(new graphql_1.GraphQLError(existedTypeNameMessage(typeName), node.name));\n      return;\n    }\n\n    if (knownTypes[typeName]) {\n      context.reportError(new graphql_1.GraphQLError(duplicateTypeNameMessage(typeName), [knownTypes[typeName], node.name]));\n    } else {\n      knownTypes[typeName] = node;\n    }\n\n    return false;\n  }\n}\n\nexports.UniqueTypeNamesWithFields = UniqueTypeNamesWithFields;","map":{"version":3,"sources":["../../../../src/composition/validate/sdl/uniqueTypeNamesWithFields.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UniqueTypeNamesWithFields = exports.existedTypeNameMessage = exports.duplicateTypeNameMessage = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nfunction duplicateTypeNameMessage(typeName) {\n    return `There can be only one type named \"${typeName}\".`;\n}\nexports.duplicateTypeNameMessage = duplicateTypeNameMessage;\nfunction existedTypeNameMessage(typeName) {\n    return `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`;\n}\nexports.existedTypeNameMessage = existedTypeNameMessage;\nfunction UniqueTypeNamesWithFields(context) {\n    const knownTypes = Object.create(null);\n    const schema = context.getSchema();\n    return {\n        ObjectTypeDefinition: checkTypeName,\n        InterfaceTypeDefinition: checkTypeName,\n        InputObjectTypeDefinition: checkTypeName,\n    };\n    function checkTypeName(node) {\n        const typeName = node.name.value;\n        const typeFromSchema = schema && schema.getType(typeName);\n        const typeNodeFromSchema = typeFromSchema &&\n            typeFromSchema.astNode;\n        const typeNodeFromDefs = knownTypes[typeName];\n        const duplicateTypeNode = typeNodeFromSchema || typeNodeFromDefs;\n        if (duplicateTypeNode) {\n            const possibleErrors = [];\n            const { kind, fields } = utils_1.diffTypeNodes(node, duplicateTypeNode);\n            const fieldsDiff = Object.entries(fields);\n            const typesHaveSameShape = fieldsDiff.length === 0 ||\n                fieldsDiff.every(([fieldName, types]) => {\n                    if (types.length === 2) {\n                        possibleErrors.push(utils_1.errorWithCode('VALUE_TYPE_FIELD_TYPE_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName, fieldName)}A field was defined differently in different services. \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\` define \\`${typeName}.${fieldName}\\` as a ${types[1]} and ${types[0]} respectively. In order to define \\`${typeName}\\` in multiple places, the fields and their types must be identical.`, [node, duplicateTypeNode]));\n                        return true;\n                    }\n                    return false;\n                });\n            if (typesHaveSameShape) {\n                possibleErrors.forEach(error => context.reportError(error));\n                if (kind.length > 0) {\n                    context.reportError(utils_1.errorWithCode('VALUE_TYPE_KIND_MISMATCH', `${utils_1.logServiceAndType(duplicateTypeNode.serviceName, typeName)}Found kind mismatch on expected value type belonging to services \\`${duplicateTypeNode.serviceName}\\` and \\`${node.serviceName}\\`. \\`${typeName}\\` is defined as both a \\`${kind[0]}\\` and a \\`${kind[1]}\\`. In order to define \\`${typeName}\\` in multiple places, the kinds must be identical.`, [node, duplicateTypeNode]));\n                }\n                if (utils_1.isTypeNodeAnEntity(node) || utils_1.isTypeNodeAnEntity(duplicateTypeNode)) {\n                    const entityNode = utils_1.isTypeNodeAnEntity(duplicateTypeNode)\n                        ? duplicateTypeNode\n                        : node;\n                    context.reportError(utils_1.errorWithCode('VALUE_TYPE_NO_ENTITY', `${utils_1.logServiceAndType(entityNode.serviceName, typeName)}Value types cannot be entities (using the \\`@key\\` directive). Please ensure that the \\`${typeName}\\` type is extended properly or remove the \\`@key\\` directive if this is not an entity.`, [node, duplicateTypeNode]));\n                }\n                return false;\n            }\n        }\n        if (typeFromSchema) {\n            context.reportError(new graphql_1.GraphQLError(existedTypeNameMessage(typeName), node.name));\n            return;\n        }\n        if (knownTypes[typeName]) {\n            context.reportError(new graphql_1.GraphQLError(duplicateTypeNameMessage(typeName), [\n                knownTypes[typeName],\n                node.name,\n            ]));\n        }\n        else {\n            knownTypes[typeName] = node;\n        }\n        return false;\n    }\n}\nexports.UniqueTypeNamesWithFields = UniqueTypeNamesWithFields;\n//# sourceMappingURL=uniqueTypeNamesWithFields.js.map"]},"metadata":{},"sourceType":"script"}