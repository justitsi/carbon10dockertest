{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar common = require('./common');\n\nvar os = require('os');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink'\n  },\n  wrapOutput: false\n}); // Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\n\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  } // Check the mtimes of the files if the '-u' flag is provided\n\n\n  try {\n    if (options.update && fs.statSync(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {// If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (fs.lstatSync(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      fs.lstatSync(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {// it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n  } else {\n    var BUF_LENGTH = 64 * 1024;\n    var buf = new Buffer(BUF_LENGTH);\n    var bytesRead = BUF_LENGTH;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === BUF_LENGTH) {\n      bytesRead = fs.readSync(fdr, buf, 0, BUF_LENGTH, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n    fs.chmodSync(destFile, fs.statSync(srcFile).mode);\n  }\n} // Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\n\n\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {}; // Ensure there is not a run away recursive copy\n\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++; // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n\n  try {\n    var checkDir = fs.statSync(sourceDir);\n    fs.mkdirSync(destDir, checkDir.mode);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = fs.lstatSync(srcFile);\n    var symlinkFull;\n\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n        continue;\n      }\n    }\n\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n\n      try {\n        fs.lstatSync(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {// it doesn't exist, so no work needs to be done\n      }\n\n      fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = fs.statSync(srcFile);\n\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n} // cpdirSyncRecursive\n\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = fs.lstatSync(srcFile);\n\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = fs.statSync(srcFile);\n\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n} //@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if source is newer than dest\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\n\n\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  } // Get sources, dest\n\n\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && fs.statSync(dest); // Dest is not existing dir, but multiple sources given\n\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  } // Dest is an existing file, but -n is given\n\n\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    var srcStat = fs.statSync(src);\n\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", {\n          continue: true\n        });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;\n\n        try {\n          fs.statSync(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, {\n            no_force: options.no_force,\n            followsymlink: options.followsymlink\n          });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      if (fs.existsSync(thisDest) && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", {\n          continue: true\n        });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\n\nmodule.exports = _cp;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/shelljs/src/cp.js"],"names":["fs","require","path","common","os","register","_cp","cmdOptions","wrapOutput","copyFileSync","srcFile","destFile","options","existsSync","error","update","statSync","mtime","e","lstatSync","isSymbolicLink","followsymlink","unlinkSync","symlinkFull","readlinkSync","symlinkSync","platform","BUF_LENGTH","buf","Buffer","bytesRead","pos","fdr","fdw","openSync","code","readSync","writeSync","closeSync","chmodSync","mode","cpdirSyncRecursive","sourceDir","destDir","currentDepth","opts","config","maxdepth","checkDir","mkdirSync","files","readdirSync","i","length","srcFileStat","cpcheckcycle","console","isDirectory","no_force","log","cyclecheck","sourcerealpath","realpathSync","symlinkrealpath","re","RegExp","test","sources","dest","noFollowsymlink","recursive","arguments","slice","call","destExists","destStat","isFile","ShellString","forEach","src","continue","srcStat","newDest","join","basename","dirname","thisDest","normalize","relative","state","errorCode","module","exports"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar os = require('os');\n\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink',\n  },\n  wrapOutput: false,\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && fs.statSync(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n\n  if (fs.lstatSync(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      fs.lstatSync(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n  } else {\n    var BUF_LENGTH = 64 * 1024;\n    var buf = new Buffer(BUF_LENGTH);\n    var bytesRead = BUF_LENGTH;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n\n    while (bytesRead === BUF_LENGTH) {\n      bytesRead = fs.readSync(fdr, buf, 0, BUF_LENGTH, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n\n    fs.chmodSync(destFile, fs.statSync(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    var checkDir = fs.statSync(sourceDir);\n    fs.mkdirSync(destDir, checkDir.mode);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = fs.lstatSync(srcFile);\n\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        fs.lstatSync(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, os.platform() === 'win32' ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = fs.statSync(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n} // cpdirSyncRecursive\n\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = fs.lstatSync(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = fs.statSync(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if source is newer than dest\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n\n  sources.forEach(function (src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, { continue: true });\n      return; // skip file\n    }\n    var srcStat = fs.statSync(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", { continue: true });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = (destStat && destStat.isDirectory()) ?\n            path.join(dest, path.basename(src)) :\n            dest;\n\n        try {\n          fs.statSync(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n\n      if (fs.existsSync(thisDest) && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", { continue: true });\n        return;\n      }\n\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n"]},"metadata":{},"sourceType":"script"}