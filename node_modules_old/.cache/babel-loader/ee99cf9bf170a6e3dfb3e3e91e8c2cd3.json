{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n\n      var didEat = false; // If a match, treat the total upcoming matches as one token\n\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array && // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n\n          return match;\n        }\n      } // No match available.\n\n\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n\n      var indent = 0;\n\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n\n    var isMatched = false;\n\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n\n    return isMatched;\n  };\n\n  return CharacterStream;\n}();\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\n\nexports.default = CharacterStream;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/@apollographql/graphql-language-service-parser/dist/CharacterStream.js"],"names":["Object","defineProperty","exports","value","_classCallCheck","instance","Constructor","TypeError","CharacterStream","sourceText","_this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","isMatched","_testNextCharacter","undefined","eatWhile","match","didEat","eatSpace","skipToEnd","skipTo","position","consume","arguments","caseFold","token","regex","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whitespaces","pos","charCodeAt","current","prototype","character","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CharacterStream = function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n      var didEat = false;\n\n      // If a match, treat the total upcoming matches as one token\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array &&\n        // String.match returns 'index' property, which flow fails to detect\n        // for some reason. The below is a workaround, but an easier solution\n        // is just checking if `match.index === 0`\n        _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n\n      // No match available.\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n      var indent = 0;\n      if (match && match.length === 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  CharacterStream.prototype._testNextCharacter = function _testNextCharacter(pattern) {\n    var character = this._sourceText.charAt(this._pos);\n    var isMatched = false;\n    if (typeof pattern === 'string') {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  };\n\n  return CharacterStream;\n}(); /**\n      *  Copyright (c) Facebook, Inc.\n      *  All rights reserved.\n      *\n      *  This source code is licensed under the license found in the\n      *  LICENSE file in the root directory of this source tree.\n      *\n      *  \n      */\n\n/**\n * CharacterStream implements a stream of character tokens given a source text.\n * The API design follows that of CodeMirror.StringStream.\n *\n * Required:\n *\n *      sourceText: (string), A raw GraphQL source text. Works best if a line\n *        is supplied.\n *\n */\n\nexports.default = CharacterStream;"]},"metadata":{},"sourceType":"script"}