{"ast":null,"code":"'use strict';\n\nconst isPromise = require('is-promise');\n\nconst streamToObservable = require('@samverschueren/stream-to-observable');\n\nconst Subject = require('rxjs').Subject;\n\nconst renderer = require('./renderer');\n\nconst state = require('./state');\n\nconst utils = require('./utils');\n\nconst ListrError = require('./listr-error');\n\nconst defaultSkipFn = () => false;\n\nclass Task extends Subject {\n  constructor(listr, task, options) {\n    super();\n\n    if (!task) {\n      throw new TypeError('Expected a task');\n    }\n\n    if (typeof task.title !== 'string') {\n      throw new TypeError(`Expected property \\`title\\` to be of type \\`string\\`, got \\`${typeof task.title}\\``);\n    }\n\n    if (typeof task.task !== 'function') {\n      throw new TypeError(`Expected property \\`task\\` to be of type \\`function\\`, got \\`${typeof task.task}\\``);\n    }\n\n    if (task.skip && typeof task.skip !== 'function') {\n      throw new TypeError(`Expected property \\`skip\\` to be of type \\`function\\`, got \\`${typeof task.skip}\\``);\n    }\n\n    if (task.enabled && typeof task.enabled !== 'function') {\n      throw new TypeError(`Expected property \\`enabled\\` to be of type \\`function\\`, got \\`${typeof task.enabled}\\``);\n    }\n\n    this._listr = listr;\n    this._options = options || {};\n    this._subtasks = [];\n    this._enabledFn = task.enabled;\n    this._isEnabled = true;\n    this.output = undefined;\n    this.title = task.title;\n    this.skip = task.skip || defaultSkipFn;\n    this.task = task.task;\n  }\n\n  get subtasks() {\n    return this._subtasks;\n  }\n\n  set state(state) {\n    this._state = state;\n    this.next({\n      type: 'STATE'\n    });\n  }\n\n  get state() {\n    return state.toString(this._state);\n  }\n\n  check(ctx) {\n    // Check if a task is enabled or disabled\n    if (this._state === undefined && this._enabledFn) {\n      const isEnabled = this._enabledFn(ctx);\n\n      if (this._isEnabled !== isEnabled) {\n        this._isEnabled = isEnabled;\n        this.next({\n          type: 'ENABLED',\n          data: isEnabled\n        });\n      }\n    }\n  }\n\n  hasSubtasks() {\n    return this._subtasks.length > 0;\n  }\n\n  isPending() {\n    return this._state === state.PENDING;\n  }\n\n  isSkipped() {\n    return this._state === state.SKIPPED;\n  }\n\n  isCompleted() {\n    return this._state === state.COMPLETED;\n  }\n\n  isEnabled() {\n    return this._isEnabled;\n  }\n\n  hasFailed() {\n    return this._state === state.FAILED;\n  }\n\n  run(context, wrapper) {\n    const handleResult = result => {\n      // Detect the subtask\n      if (utils.isListr(result)) {\n        result._options = Object.assign(this._options, result._options);\n        result.exitOnError = result._options.exitOnError;\n        result.setRenderer(renderer.getRenderer('silent'));\n        this._subtasks = result.tasks;\n        this.next({\n          type: 'SUBTASKS'\n        });\n        return result.run(context);\n      } // Detect stream\n\n\n      if (utils.isStream(result)) {\n        result = streamToObservable(result);\n      } // Detect Observable\n\n\n      if (utils.isObservable(result)) {\n        result = new Promise((resolve, reject) => {\n          result.subscribe({\n            next: data => {\n              this.output = data;\n              this.next({\n                type: 'DATA',\n                data\n              });\n            },\n            error: reject,\n            complete: resolve\n          });\n        });\n      } // Detect promise\n\n\n      if (isPromise(result)) {\n        return result.then(handleResult);\n      }\n\n      return result;\n    };\n\n    return Promise.resolve().then(() => {\n      this.state = state.PENDING;\n      return this.skip(context);\n    }).then(skipped => {\n      if (skipped) {\n        if (typeof skipped === 'string') {\n          this.output = skipped;\n        }\n\n        this.state = state.SKIPPED;\n        return;\n      }\n\n      return handleResult(this.task(context, wrapper));\n    }).then(() => {\n      if (this.isPending()) {\n        this.state = state.COMPLETED;\n      }\n    }).catch(error => {\n      this.state = state.FAILED;\n\n      if (error instanceof ListrError) {\n        wrapper.report(error);\n        return;\n      }\n\n      if (!this.hasSubtasks()) {\n        // Do not show the message if we have subtasks as the error is already shown in the subtask\n        this.output = error.message;\n      }\n\n      this.next({\n        type: 'DATA',\n        data: error.message\n      });\n      wrapper.report(error);\n\n      if (this._listr.exitOnError !== false) {\n        // Do not exit when explicitely set to `false`\n        throw error;\n      }\n    }).then(() => {\n      // Mark the Observable as completed\n      this.complete();\n    });\n  }\n\n}\n\nmodule.exports = Task;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/listr/lib/task.js"],"names":["isPromise","require","streamToObservable","Subject","renderer","state","utils","ListrError","defaultSkipFn","Task","constructor","listr","task","options","TypeError","title","skip","enabled","_listr","_options","_subtasks","_enabledFn","_isEnabled","output","undefined","subtasks","_state","next","type","toString","check","ctx","isEnabled","data","hasSubtasks","length","isPending","PENDING","isSkipped","SKIPPED","isCompleted","COMPLETED","hasFailed","FAILED","run","context","wrapper","handleResult","result","isListr","Object","assign","exitOnError","setRenderer","getRenderer","tasks","isStream","isObservable","Promise","resolve","reject","subscribe","error","complete","then","skipped","catch","report","message","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst isPromise = require('is-promise');\nconst streamToObservable = require('@samverschueren/stream-to-observable');\nconst Subject = require('rxjs').Subject;\nconst renderer = require('./renderer');\nconst state = require('./state');\nconst utils = require('./utils');\nconst ListrError = require('./listr-error');\n\nconst defaultSkipFn = () => false;\n\nclass Task extends Subject {\n\tconstructor(listr, task, options) {\n\t\tsuper();\n\n\t\tif (!task) {\n\t\t\tthrow new TypeError('Expected a task');\n\t\t}\n\n\t\tif (typeof task.title !== 'string') {\n\t\t\tthrow new TypeError(`Expected property \\`title\\` to be of type \\`string\\`, got \\`${typeof task.title}\\``);\n\t\t}\n\n\t\tif (typeof task.task !== 'function') {\n\t\t\tthrow new TypeError(`Expected property \\`task\\` to be of type \\`function\\`, got \\`${typeof task.task}\\``);\n\t\t}\n\n\t\tif (task.skip && typeof task.skip !== 'function') {\n\t\t\tthrow new TypeError(`Expected property \\`skip\\` to be of type \\`function\\`, got \\`${typeof task.skip}\\``);\n\t\t}\n\n\t\tif (task.enabled && typeof task.enabled !== 'function') {\n\t\t\tthrow new TypeError(`Expected property \\`enabled\\` to be of type \\`function\\`, got \\`${typeof task.enabled}\\``);\n\t\t}\n\n\t\tthis._listr = listr;\n\t\tthis._options = options || {};\n\t\tthis._subtasks = [];\n\t\tthis._enabledFn = task.enabled;\n\t\tthis._isEnabled = true;\n\n\t\tthis.output = undefined;\n\t\tthis.title = task.title;\n\t\tthis.skip = task.skip || defaultSkipFn;\n\t\tthis.task = task.task;\n\t}\n\n\tget subtasks() {\n\t\treturn this._subtasks;\n\t}\n\n\tset state(state) {\n\t\tthis._state = state;\n\n\t\tthis.next({\n\t\t\ttype: 'STATE'\n\t\t});\n\t}\n\n\tget state() {\n\t\treturn state.toString(this._state);\n\t}\n\n\tcheck(ctx) {\n\t\t// Check if a task is enabled or disabled\n\t\tif (this._state === undefined && this._enabledFn) {\n\t\t\tconst isEnabled = this._enabledFn(ctx);\n\n\t\t\tif (this._isEnabled !== isEnabled) {\n\t\t\t\tthis._isEnabled = isEnabled;\n\n\t\t\t\tthis.next({\n\t\t\t\t\ttype: 'ENABLED',\n\t\t\t\t\tdata: isEnabled\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\thasSubtasks() {\n\t\treturn this._subtasks.length > 0;\n\t}\n\n\tisPending() {\n\t\treturn this._state === state.PENDING;\n\t}\n\n\tisSkipped() {\n\t\treturn this._state === state.SKIPPED;\n\t}\n\n\tisCompleted() {\n\t\treturn this._state === state.COMPLETED;\n\t}\n\n\tisEnabled() {\n\t\treturn this._isEnabled;\n\t}\n\n\thasFailed() {\n\t\treturn this._state === state.FAILED;\n\t}\n\n\trun(context, wrapper) {\n\t\tconst handleResult = result => {\n\t\t\t// Detect the subtask\n\t\t\tif (utils.isListr(result)) {\n\t\t\t\tresult._options = Object.assign(this._options, result._options);\n\n\t\t\t\tresult.exitOnError = result._options.exitOnError;\n\n\t\t\t\tresult.setRenderer(renderer.getRenderer('silent'));\n\t\t\t\tthis._subtasks = result.tasks;\n\n\t\t\t\tthis.next({\n\t\t\t\t\ttype: 'SUBTASKS'\n\t\t\t\t});\n\n\t\t\t\treturn result.run(context);\n\t\t\t}\n\n\t\t\t// Detect stream\n\t\t\tif (utils.isStream(result)) {\n\t\t\t\tresult = streamToObservable(result);\n\t\t\t}\n\n\t\t\t// Detect Observable\n\t\t\tif (utils.isObservable(result)) {\n\t\t\t\tresult = new Promise((resolve, reject) => {\n\t\t\t\t\tresult.subscribe({\n\t\t\t\t\t\tnext: data => {\n\t\t\t\t\t\t\tthis.output = data;\n\n\t\t\t\t\t\t\tthis.next({\n\t\t\t\t\t\t\t\ttype: 'DATA',\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: reject,\n\t\t\t\t\t\tcomplete: resolve\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Detect promise\n\t\t\tif (isPromise(result)) {\n\t\t\t\treturn result.then(handleResult);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tthis.state = state.PENDING;\n\t\t\t\treturn this.skip(context);\n\t\t\t})\n\t\t\t.then(skipped => {\n\t\t\t\tif (skipped) {\n\t\t\t\t\tif (typeof skipped === 'string') {\n\t\t\t\t\t\tthis.output = skipped;\n\t\t\t\t\t}\n\t\t\t\t\tthis.state = state.SKIPPED;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn handleResult(this.task(context, wrapper));\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\tif (this.isPending()) {\n\t\t\t\t\tthis.state = state.COMPLETED;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthis.state = state.FAILED;\n\n\t\t\t\tif (error instanceof ListrError) {\n\t\t\t\t\twrapper.report(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.hasSubtasks()) {\n\t\t\t\t\t// Do not show the message if we have subtasks as the error is already shown in the subtask\n\t\t\t\t\tthis.output = error.message;\n\t\t\t\t}\n\n\t\t\t\tthis.next({\n\t\t\t\t\ttype: 'DATA',\n\t\t\t\t\tdata: error.message\n\t\t\t\t});\n\n\t\t\t\twrapper.report(error);\n\n\t\t\t\tif (this._listr.exitOnError !== false) {\n\t\t\t\t\t// Do not exit when explicitely set to `false`\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\t// Mark the Observable as completed\n\t\t\t\tthis.complete();\n\t\t\t});\n\t}\n}\n\nmodule.exports = Task;\n"]},"metadata":{},"sourceType":"script"}