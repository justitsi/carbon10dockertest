{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFederationType = exports.federationTypes = exports.serviceField = exports.entitiesField = exports.AnyType = exports.ServiceType = exports.EntityType = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nexports.EntityType = new graphql_1.GraphQLUnionType({\n  name: '_Entity',\n  types: []\n});\nexports.ServiceType = new graphql_1.GraphQLObjectType({\n  name: '_Service',\n  fields: {\n    sdl: {\n      type: graphql_1.GraphQLString,\n      description: 'The sdl representing the federated service capabilities. Includes federation directives, removes federation types, and includes rest of full schema after schema directives have been applied'\n    }\n  }\n});\nexports.AnyType = new graphql_1.GraphQLScalarType({\n  name: '_Any',\n\n  serialize(value) {\n    return value;\n  }\n\n});\n\nfunction isPromise(value) {\n  return Boolean(value && 'then' in value && typeof value.then === 'function');\n}\n\nfunction addTypeNameToPossibleReturn(maybeObject, typename) {\n  if (maybeObject !== null && typeof maybeObject === 'object') {\n    Object.defineProperty(maybeObject, '__typename', {\n      value: typename\n    });\n  }\n\n  return maybeObject;\n}\n\nexports.entitiesField = {\n  type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(exports.EntityType)),\n  args: {\n    representations: {\n      type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(new graphql_1.GraphQLNonNull(exports.AnyType)))\n    }\n  },\n\n  resolve(_source, {\n    representations\n  }, context, info) {\n    return representations.map(reference => {\n      const {\n        __typename\n      } = reference;\n      const type = info.schema.getType(__typename);\n\n      if (!type || !graphql_1.isObjectType(type)) {\n        throw new Error(`The _entities resolver tried to load an entity for type \"${__typename}\", but no object type of that name was found in the schema`);\n      }\n\n      const resolveReference = type.resolveReference ? type.resolveReference : function defaultResolveReference() {\n        return reference;\n      };\n      const result = resolveReference(reference, context, info);\n\n      if (isPromise(result)) {\n        return result.then(x => addTypeNameToPossibleReturn(x, __typename));\n      }\n\n      return addTypeNameToPossibleReturn(result, __typename);\n    });\n  }\n\n};\nexports.serviceField = {\n  type: new graphql_1.GraphQLNonNull(exports.ServiceType)\n};\nexports.federationTypes = [exports.ServiceType, exports.AnyType, exports.EntityType];\n\nfunction isFederationType(type) {\n  return graphql_1.isNamedType(type) && exports.federationTypes.some(({\n    name\n  }) => name === type.name);\n}\n\nexports.isFederationType = isFederationType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFederationType = exports.federationTypes = exports.serviceField = exports.entitiesField = exports.AnyType = exports.ServiceType = exports.EntityType = void 0;\nconst graphql_1 = require(\"graphql\");\nexports.EntityType = new graphql_1.GraphQLUnionType({\n    name: '_Entity',\n    types: [],\n});\nexports.ServiceType = new graphql_1.GraphQLObjectType({\n    name: '_Service',\n    fields: {\n        sdl: {\n            type: graphql_1.GraphQLString,\n            description: 'The sdl representing the federated service capabilities. Includes federation directives, removes federation types, and includes rest of full schema after schema directives have been applied',\n        },\n    },\n});\nexports.AnyType = new graphql_1.GraphQLScalarType({\n    name: '_Any',\n    serialize(value) {\n        return value;\n    },\n});\nfunction isPromise(value) {\n    return Boolean(value && 'then' in value && typeof value.then === 'function');\n}\nfunction addTypeNameToPossibleReturn(maybeObject, typename) {\n    if (maybeObject !== null && typeof maybeObject === 'object') {\n        Object.defineProperty(maybeObject, '__typename', {\n            value: typename,\n        });\n    }\n    return maybeObject;\n}\nexports.entitiesField = {\n    type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(exports.EntityType)),\n    args: {\n        representations: {\n            type: new graphql_1.GraphQLNonNull(new graphql_1.GraphQLList(new graphql_1.GraphQLNonNull(exports.AnyType))),\n        },\n    },\n    resolve(_source, { representations }, context, info) {\n        return representations.map((reference) => {\n            const { __typename } = reference;\n            const type = info.schema.getType(__typename);\n            if (!type || !graphql_1.isObjectType(type)) {\n                throw new Error(`The _entities resolver tried to load an entity for type \"${__typename}\", but no object type of that name was found in the schema`);\n            }\n            const resolveReference = type.resolveReference\n                ? type.resolveReference\n                : function defaultResolveReference() {\n                    return reference;\n                };\n            const result = resolveReference(reference, context, info);\n            if (isPromise(result)) {\n                return result.then((x) => addTypeNameToPossibleReturn(x, __typename));\n            }\n            return addTypeNameToPossibleReturn(result, __typename);\n        });\n    },\n};\nexports.serviceField = {\n    type: new graphql_1.GraphQLNonNull(exports.ServiceType),\n};\nexports.federationTypes = [\n    exports.ServiceType,\n    exports.AnyType,\n    exports.EntityType,\n];\nfunction isFederationType(type) {\n    return (graphql_1.isNamedType(type) && exports.federationTypes.some(({ name }) => name === type.name));\n}\nexports.isFederationType = isFederationType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}