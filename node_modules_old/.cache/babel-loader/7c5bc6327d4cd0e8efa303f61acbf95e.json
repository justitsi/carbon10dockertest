{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFederationMetadata = exports.defaultRootOperationNameLookup = exports.reservedRootFields = exports.isFederationDirective = exports.executableDirectiveLocations = exports.isNotNullOrUndefined = exports.mapValues = exports.defKindToExtKind = exports.typeNodesAreEquivalent = exports.diffTypeNodes = exports.isTypeNodeAnEntity = exports.selectionIncludesField = exports.findFieldsThatReturnType = exports.findTypesContainingFieldWithReturnType = exports.errorWithCode = exports.logDirective = exports.logServiceAndType = exports.hasMatchingFieldInDirectives = exports.parseSelections = exports.stripTypeSystemDirectivesFromTypeDefs = exports.stripExternalFieldsFromTypeDefs = exports.findDirectivesOnTypeOrField = exports.mapFieldNamesToServiceName = exports.isStringValueNode = void 0;\n\nrequire(\"apollo-server-env\");\n\nconst graphql_1 = require(\"graphql\");\n\nconst directives_1 = __importDefault(require(\"../directives\"));\n\nfunction isStringValueNode(node) {\n  return node.kind === graphql_1.Kind.STRING;\n}\n\nexports.isStringValueNode = isStringValueNode;\n\nfunction mapFieldNamesToServiceName(fields, serviceName) {\n  return fields.reduce((prev, next) => {\n    prev[next.name.value] = serviceName;\n    return prev;\n  }, Object.create(null));\n}\n\nexports.mapFieldNamesToServiceName = mapFieldNamesToServiceName;\n\nfunction findDirectivesOnTypeOrField(node, directiveName) {\n  return node && node.directives ? node.directives.filter(directive => directive.name.value === directiveName) : [];\n}\n\nexports.findDirectivesOnTypeOrField = findDirectivesOnTypeOrField;\n\nfunction stripExternalFieldsFromTypeDefs(typeDefs, serviceName) {\n  const strippedFields = [];\n  const typeDefsWithoutExternalFields = graphql_1.visit(typeDefs, {\n    ObjectTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName),\n    InterfaceTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName)\n  });\n  return {\n    typeDefsWithoutExternalFields,\n    strippedFields\n  };\n}\n\nexports.stripExternalFieldsFromTypeDefs = stripExternalFieldsFromTypeDefs;\n\nfunction stripTypeSystemDirectivesFromTypeDefs(typeDefs) {\n  const typeDefsWithoutTypeSystemDirectives = graphql_1.visit(typeDefs, {\n    Directive(node) {\n      if (node.name.value === 'deprecated' || node.name.value === 'specifiedBy') return;\n      const isFederationDirective = directives_1.default.some(({\n        name\n      }) => name === node.name.value);\n      return isFederationDirective ? undefined : null;\n    }\n\n  });\n  return typeDefsWithoutTypeSystemDirectives;\n}\n\nexports.stripTypeSystemDirectivesFromTypeDefs = stripTypeSystemDirectivesFromTypeDefs;\n\nfunction removeExternalFieldsFromExtensionVisitor(collector, serviceName) {\n  return node => {\n    let fields = node.fields;\n\n    if (fields) {\n      fields = fields.filter(field => {\n        const externalDirectives = findDirectivesOnTypeOrField(field, 'external');\n\n        if (externalDirectives.length > 0) {\n          collector.push({\n            field,\n            parentTypeName: node.name.value,\n            serviceName\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }\n\n    return Object.assign(Object.assign({}, node), {\n      fields\n    });\n  };\n}\n\nfunction parseSelections(source) {\n  return graphql_1.parse(`query { ${source} }`).definitions[0].selectionSet.selections;\n}\n\nexports.parseSelections = parseSelections;\n\nfunction hasMatchingFieldInDirectives({\n  directives,\n  fieldNameToMatch,\n  namedType\n}) {\n  return Boolean(namedType.astNode && directives.map(keyDirective => keyDirective.arguments && isStringValueNode(keyDirective.arguments[0].value) ? {\n    typeName: namedType.astNode.name.value,\n    keyArgument: keyDirective.arguments[0].value.value\n  } : null).filter(isNotNullOrUndefined).flatMap(selection => parseSelections(selection.keyArgument)).some(field => field.kind === graphql_1.Kind.FIELD && field.name.value === fieldNameToMatch));\n}\n\nexports.hasMatchingFieldInDirectives = hasMatchingFieldInDirectives;\n\nexports.logServiceAndType = (serviceName, typeName, fieldName) => `[${serviceName}] ${typeName}${fieldName ? `.${fieldName} -> ` : ' -> '}`;\n\nfunction logDirective(directiveName) {\n  return `[@${directiveName}] -> `;\n}\n\nexports.logDirective = logDirective;\n\nfunction errorWithCode(code, message, nodes) {\n  return new graphql_1.GraphQLError(message, nodes, undefined, undefined, undefined, undefined, {\n    code\n  });\n}\n\nexports.errorWithCode = errorWithCode;\n\nfunction findTypesContainingFieldWithReturnType(schema, node) {\n  const returnType = graphql_1.getNamedType(node.type);\n  if (!graphql_1.isObjectType(returnType)) return [];\n  const containingTypes = [];\n  const types = schema.getTypeMap();\n\n  for (const selectionSetType of Object.values(types)) {\n    if (!graphql_1.isObjectType(selectionSetType)) continue;\n    const allFields = selectionSetType.getFields();\n    Object.values(allFields).forEach(field => {\n      const fieldReturnType = graphql_1.getNamedType(field.type);\n\n      if (fieldReturnType === returnType) {\n        containingTypes.push(fieldReturnType);\n      }\n    });\n  }\n\n  return containingTypes;\n}\n\nexports.findTypesContainingFieldWithReturnType = findTypesContainingFieldWithReturnType;\n\nfunction findFieldsThatReturnType({\n  schema,\n  typeToFind\n}) {\n  if (!graphql_1.isObjectType(typeToFind)) return [];\n  const fieldsThatReturnType = [];\n  const types = schema.getTypeMap();\n\n  for (const selectionSetType of Object.values(types)) {\n    if (!graphql_1.isObjectType(selectionSetType)) continue;\n    const fieldsOnNamedType = selectionSetType.getFields();\n    Object.values(fieldsOnNamedType).forEach(field => {\n      const fieldReturnType = graphql_1.getNamedType(field.type);\n\n      if (fieldReturnType === typeToFind) {\n        fieldsThatReturnType.push(field);\n      }\n    });\n  }\n\n  return fieldsThatReturnType;\n}\n\nexports.findFieldsThatReturnType = findFieldsThatReturnType;\n\nfunction selectionIncludesField({\n  selections,\n  selectionSetType,\n  typeToFind,\n  fieldToFind\n}) {\n  for (const selection of selections) {\n    const selectionName = selection.name.value;\n    if (selectionName === fieldToFind && graphql_1.isEqualType(selectionSetType, typeToFind)) return true;\n    const typeIncludesField = selectionName && Object.keys(selectionSetType.getFields()).includes(selectionName);\n    if (!selectionName || !typeIncludesField) continue;\n    const returnType = graphql_1.getNamedType(selectionSetType.getFields()[selectionName].type);\n    if (!returnType || !graphql_1.isObjectType(returnType)) continue;\n    const subselections = selection.selectionSet && selection.selectionSet.selections;\n\n    if (subselections) {\n      const selectionDoesIncludeField = selectionIncludesField({\n        selectionSetType: returnType,\n        selections: subselections,\n        typeToFind,\n        fieldToFind\n      });\n      if (selectionDoesIncludeField) return true;\n    }\n  }\n\n  return false;\n}\n\nexports.selectionIncludesField = selectionIncludesField;\n\nfunction isTypeNodeAnEntity(node) {\n  let isEntity = false;\n  graphql_1.visit(node, {\n    Directive(directive) {\n      if (directive.name.value === 'key') {\n        isEntity = true;\n        return graphql_1.BREAK;\n      }\n    }\n\n  });\n  return isEntity;\n}\n\nexports.isTypeNodeAnEntity = isTypeNodeAnEntity;\n\nfunction diffTypeNodes(firstNode, secondNode) {\n  const fieldsDiff = Object.create(null);\n  const unionTypesDiff = Object.create(null);\n  const locationsDiff = new Set();\n  const argumentsDiff = Object.create(null);\n  const document = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [firstNode, secondNode]\n  };\n\n  function fieldVisitor(node) {\n    const fieldName = node.name.value;\n    const type = graphql_1.print(node.type);\n\n    if (!fieldsDiff[fieldName]) {\n      fieldsDiff[fieldName] = [type];\n      return;\n    }\n\n    const fieldTypes = fieldsDiff[fieldName];\n\n    if (fieldTypes[0] === type) {\n      delete fieldsDiff[fieldName];\n    } else {\n      fieldTypes.push(type);\n    }\n  }\n\n  graphql_1.visit(document, {\n    FieldDefinition: fieldVisitor,\n    InputValueDefinition: fieldVisitor,\n\n    UnionTypeDefinition(node) {\n      if (!node.types) return graphql_1.BREAK;\n\n      for (const namedTypeNode of node.types) {\n        const name = namedTypeNode.name.value;\n\n        if (unionTypesDiff[name]) {\n          delete unionTypesDiff[name];\n        } else {\n          unionTypesDiff[name] = true;\n        }\n      }\n    },\n\n    DirectiveDefinition(node) {\n      node.locations.forEach(location => {\n        const locationName = location.value;\n\n        if (locationsDiff.has(locationName)) {\n          locationsDiff.delete(locationName);\n        } else {\n          locationsDiff.add(locationName);\n        }\n      });\n      if (!node.arguments) return;\n      node.arguments.forEach(argument => {\n        const argumentName = argument.name.value;\n        const printedType = graphql_1.print(argument.type);\n\n        if (argumentsDiff[argumentName]) {\n          if (printedType === argumentsDiff[argumentName][0]) {\n            delete argumentsDiff[argumentName];\n          } else {\n            argumentsDiff[argumentName].push(printedType);\n          }\n        } else {\n          argumentsDiff[argumentName] = [printedType];\n        }\n      });\n    }\n\n  });\n  const typeNameDiff = firstNode.name.value === secondNode.name.value ? [] : [firstNode.name.value, secondNode.name.value];\n  const kindDiff = firstNode.kind === secondNode.kind ? [] : [firstNode.kind, secondNode.kind];\n  return {\n    name: typeNameDiff,\n    kind: kindDiff,\n    fields: fieldsDiff,\n    unionTypes: unionTypesDiff,\n    locations: Array.from(locationsDiff),\n    args: argumentsDiff\n  };\n}\n\nexports.diffTypeNodes = diffTypeNodes;\n\nfunction typeNodesAreEquivalent(firstNode, secondNode) {\n  const {\n    name,\n    kind,\n    fields,\n    unionTypes,\n    locations,\n    args\n  } = diffTypeNodes(firstNode, secondNode);\n  return name.length === 0 && kind.length === 0 && Object.keys(fields).length === 0 && Object.keys(unionTypes).length === 0 && locations.length === 0 && Object.keys(args).length === 0;\n}\n\nexports.typeNodesAreEquivalent = typeNodesAreEquivalent;\nexports.defKindToExtKind = {\n  [graphql_1.Kind.SCALAR_TYPE_DEFINITION]: graphql_1.Kind.SCALAR_TYPE_EXTENSION,\n  [graphql_1.Kind.OBJECT_TYPE_DEFINITION]: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n  [graphql_1.Kind.INTERFACE_TYPE_DEFINITION]: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n  [graphql_1.Kind.UNION_TYPE_DEFINITION]: graphql_1.Kind.UNION_TYPE_EXTENSION,\n  [graphql_1.Kind.ENUM_TYPE_DEFINITION]: graphql_1.Kind.ENUM_TYPE_EXTENSION,\n  [graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION]: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION\n};\n\nfunction mapValues(object, callback) {\n  const result = Object.create(null);\n\n  for (const [key, value] of Object.entries(object)) {\n    result[key] = callback(value);\n  }\n\n  return result;\n}\n\nexports.mapValues = mapValues;\n\nfunction isNotNullOrUndefined(value) {\n  return value !== null && typeof value !== 'undefined';\n}\n\nexports.isNotNullOrUndefined = isNotNullOrUndefined;\nexports.executableDirectiveLocations = ['QUERY', 'MUTATION', 'SUBSCRIPTION', 'FIELD', 'FRAGMENT_DEFINITION', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT', 'VARIABLE_DEFINITION'];\n\nfunction isFederationDirective(directive) {\n  return directives_1.default.some(({\n    name\n  }) => name === directive.name);\n}\n\nexports.isFederationDirective = isFederationDirective;\nexports.reservedRootFields = ['_service', '_entities'];\nexports.defaultRootOperationNameLookup = {\n  query: 'Query',\n  mutation: 'Mutation',\n  subscription: 'Subscription'\n};\n\nfunction getFederationMetadata(obj) {\n  var _a, _b, _c;\n\n  if (typeof obj === \"undefined\") return undefined;else if (graphql_1.isNamedType(obj)) return (_a = obj.extensions) === null || _a === void 0 ? void 0 : _a.federation;else if (graphql_1.isDirective(obj)) return (_b = obj.extensions) === null || _b === void 0 ? void 0 : _b.federation;else return (_c = obj.extensions) === null || _c === void 0 ? void 0 : _c.federation;\n}\n\nexports.getFederationMetadata = getFederationMetadata;","map":{"version":3,"sources":["../../src/composition/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFederationMetadata = exports.defaultRootOperationNameLookup = exports.reservedRootFields = exports.isFederationDirective = exports.executableDirectiveLocations = exports.isNotNullOrUndefined = exports.mapValues = exports.defKindToExtKind = exports.typeNodesAreEquivalent = exports.diffTypeNodes = exports.isTypeNodeAnEntity = exports.selectionIncludesField = exports.findFieldsThatReturnType = exports.findTypesContainingFieldWithReturnType = exports.errorWithCode = exports.logDirective = exports.logServiceAndType = exports.hasMatchingFieldInDirectives = exports.parseSelections = exports.stripTypeSystemDirectivesFromTypeDefs = exports.stripExternalFieldsFromTypeDefs = exports.findDirectivesOnTypeOrField = exports.mapFieldNamesToServiceName = exports.isStringValueNode = void 0;\nrequire(\"apollo-server-env\");\nconst graphql_1 = require(\"graphql\");\nconst directives_1 = __importDefault(require(\"../directives\"));\nfunction isStringValueNode(node) {\n    return node.kind === graphql_1.Kind.STRING;\n}\nexports.isStringValueNode = isStringValueNode;\nfunction mapFieldNamesToServiceName(fields, serviceName) {\n    return fields.reduce((prev, next) => {\n        prev[next.name.value] = serviceName;\n        return prev;\n    }, Object.create(null));\n}\nexports.mapFieldNamesToServiceName = mapFieldNamesToServiceName;\nfunction findDirectivesOnTypeOrField(node, directiveName) {\n    return node && node.directives\n        ? node.directives.filter(directive => directive.name.value === directiveName)\n        : [];\n}\nexports.findDirectivesOnTypeOrField = findDirectivesOnTypeOrField;\nfunction stripExternalFieldsFromTypeDefs(typeDefs, serviceName) {\n    const strippedFields = [];\n    const typeDefsWithoutExternalFields = graphql_1.visit(typeDefs, {\n        ObjectTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName),\n        InterfaceTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName),\n    });\n    return { typeDefsWithoutExternalFields, strippedFields };\n}\nexports.stripExternalFieldsFromTypeDefs = stripExternalFieldsFromTypeDefs;\nfunction stripTypeSystemDirectivesFromTypeDefs(typeDefs) {\n    const typeDefsWithoutTypeSystemDirectives = graphql_1.visit(typeDefs, {\n        Directive(node) {\n            if (node.name.value === 'deprecated' || node.name.value === 'specifiedBy')\n                return;\n            const isFederationDirective = directives_1.default.some(({ name }) => name === node.name.value);\n            return isFederationDirective ? undefined : null;\n        },\n    });\n    return typeDefsWithoutTypeSystemDirectives;\n}\nexports.stripTypeSystemDirectivesFromTypeDefs = stripTypeSystemDirectivesFromTypeDefs;\nfunction removeExternalFieldsFromExtensionVisitor(collector, serviceName) {\n    return (node) => {\n        let fields = node.fields;\n        if (fields) {\n            fields = fields.filter(field => {\n                const externalDirectives = findDirectivesOnTypeOrField(field, 'external');\n                if (externalDirectives.length > 0) {\n                    collector.push({\n                        field,\n                        parentTypeName: node.name.value,\n                        serviceName,\n                    });\n                    return false;\n                }\n                return true;\n            });\n        }\n        return Object.assign(Object.assign({}, node), { fields });\n    };\n}\nfunction parseSelections(source) {\n    return graphql_1.parse(`query { ${source} }`)\n        .definitions[0].selectionSet.selections;\n}\nexports.parseSelections = parseSelections;\nfunction hasMatchingFieldInDirectives({ directives, fieldNameToMatch, namedType, }) {\n    return Boolean(namedType.astNode &&\n        directives\n            .map(keyDirective => keyDirective.arguments &&\n            isStringValueNode(keyDirective.arguments[0].value)\n            ? {\n                typeName: namedType.astNode.name.value,\n                keyArgument: keyDirective.arguments[0].value.value,\n            }\n            : null)\n            .filter(isNotNullOrUndefined)\n            .flatMap(selection => parseSelections(selection.keyArgument))\n            .some(field => field.kind === graphql_1.Kind.FIELD && field.name.value === fieldNameToMatch));\n}\nexports.hasMatchingFieldInDirectives = hasMatchingFieldInDirectives;\nexports.logServiceAndType = (serviceName, typeName, fieldName) => `[${serviceName}] ${typeName}${fieldName ? `.${fieldName} -> ` : ' -> '}`;\nfunction logDirective(directiveName) {\n    return `[@${directiveName}] -> `;\n}\nexports.logDirective = logDirective;\nfunction errorWithCode(code, message, nodes) {\n    return new graphql_1.GraphQLError(message, nodes, undefined, undefined, undefined, undefined, {\n        code,\n    });\n}\nexports.errorWithCode = errorWithCode;\nfunction findTypesContainingFieldWithReturnType(schema, node) {\n    const returnType = graphql_1.getNamedType(node.type);\n    if (!graphql_1.isObjectType(returnType))\n        return [];\n    const containingTypes = [];\n    const types = schema.getTypeMap();\n    for (const selectionSetType of Object.values(types)) {\n        if (!graphql_1.isObjectType(selectionSetType))\n            continue;\n        const allFields = selectionSetType.getFields();\n        Object.values(allFields).forEach(field => {\n            const fieldReturnType = graphql_1.getNamedType(field.type);\n            if (fieldReturnType === returnType) {\n                containingTypes.push(fieldReturnType);\n            }\n        });\n    }\n    return containingTypes;\n}\nexports.findTypesContainingFieldWithReturnType = findTypesContainingFieldWithReturnType;\nfunction findFieldsThatReturnType({ schema, typeToFind, }) {\n    if (!graphql_1.isObjectType(typeToFind))\n        return [];\n    const fieldsThatReturnType = [];\n    const types = schema.getTypeMap();\n    for (const selectionSetType of Object.values(types)) {\n        if (!graphql_1.isObjectType(selectionSetType))\n            continue;\n        const fieldsOnNamedType = selectionSetType.getFields();\n        Object.values(fieldsOnNamedType).forEach(field => {\n            const fieldReturnType = graphql_1.getNamedType(field.type);\n            if (fieldReturnType === typeToFind) {\n                fieldsThatReturnType.push(field);\n            }\n        });\n    }\n    return fieldsThatReturnType;\n}\nexports.findFieldsThatReturnType = findFieldsThatReturnType;\nfunction selectionIncludesField({ selections, selectionSetType, typeToFind, fieldToFind, }) {\n    for (const selection of selections) {\n        const selectionName = selection.name.value;\n        if (selectionName === fieldToFind &&\n            graphql_1.isEqualType(selectionSetType, typeToFind))\n            return true;\n        const typeIncludesField = selectionName &&\n            Object.keys(selectionSetType.getFields()).includes(selectionName);\n        if (!selectionName || !typeIncludesField)\n            continue;\n        const returnType = graphql_1.getNamedType(selectionSetType.getFields()[selectionName].type);\n        if (!returnType || !graphql_1.isObjectType(returnType))\n            continue;\n        const subselections = selection.selectionSet && selection.selectionSet.selections;\n        if (subselections) {\n            const selectionDoesIncludeField = selectionIncludesField({\n                selectionSetType: returnType,\n                selections: subselections,\n                typeToFind,\n                fieldToFind,\n            });\n            if (selectionDoesIncludeField)\n                return true;\n        }\n    }\n    return false;\n}\nexports.selectionIncludesField = selectionIncludesField;\nfunction isTypeNodeAnEntity(node) {\n    let isEntity = false;\n    graphql_1.visit(node, {\n        Directive(directive) {\n            if (directive.name.value === 'key') {\n                isEntity = true;\n                return graphql_1.BREAK;\n            }\n        },\n    });\n    return isEntity;\n}\nexports.isTypeNodeAnEntity = isTypeNodeAnEntity;\nfunction diffTypeNodes(firstNode, secondNode) {\n    const fieldsDiff = Object.create(null);\n    const unionTypesDiff = Object.create(null);\n    const locationsDiff = new Set();\n    const argumentsDiff = Object.create(null);\n    const document = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [firstNode, secondNode],\n    };\n    function fieldVisitor(node) {\n        const fieldName = node.name.value;\n        const type = graphql_1.print(node.type);\n        if (!fieldsDiff[fieldName]) {\n            fieldsDiff[fieldName] = [type];\n            return;\n        }\n        const fieldTypes = fieldsDiff[fieldName];\n        if (fieldTypes[0] === type) {\n            delete fieldsDiff[fieldName];\n        }\n        else {\n            fieldTypes.push(type);\n        }\n    }\n    graphql_1.visit(document, {\n        FieldDefinition: fieldVisitor,\n        InputValueDefinition: fieldVisitor,\n        UnionTypeDefinition(node) {\n            if (!node.types)\n                return graphql_1.BREAK;\n            for (const namedTypeNode of node.types) {\n                const name = namedTypeNode.name.value;\n                if (unionTypesDiff[name]) {\n                    delete unionTypesDiff[name];\n                }\n                else {\n                    unionTypesDiff[name] = true;\n                }\n            }\n        },\n        DirectiveDefinition(node) {\n            node.locations.forEach(location => {\n                const locationName = location.value;\n                if (locationsDiff.has(locationName)) {\n                    locationsDiff.delete(locationName);\n                }\n                else {\n                    locationsDiff.add(locationName);\n                }\n            });\n            if (!node.arguments)\n                return;\n            node.arguments.forEach(argument => {\n                const argumentName = argument.name.value;\n                const printedType = graphql_1.print(argument.type);\n                if (argumentsDiff[argumentName]) {\n                    if (printedType === argumentsDiff[argumentName][0]) {\n                        delete argumentsDiff[argumentName];\n                    }\n                    else {\n                        argumentsDiff[argumentName].push(printedType);\n                    }\n                }\n                else {\n                    argumentsDiff[argumentName] = [printedType];\n                }\n            });\n        },\n    });\n    const typeNameDiff = firstNode.name.value === secondNode.name.value\n        ? []\n        : [firstNode.name.value, secondNode.name.value];\n    const kindDiff = firstNode.kind === secondNode.kind ? [] : [firstNode.kind, secondNode.kind];\n    return {\n        name: typeNameDiff,\n        kind: kindDiff,\n        fields: fieldsDiff,\n        unionTypes: unionTypesDiff,\n        locations: Array.from(locationsDiff),\n        args: argumentsDiff,\n    };\n}\nexports.diffTypeNodes = diffTypeNodes;\nfunction typeNodesAreEquivalent(firstNode, secondNode) {\n    const { name, kind, fields, unionTypes, locations, args } = diffTypeNodes(firstNode, secondNode);\n    return (name.length === 0 &&\n        kind.length === 0 &&\n        Object.keys(fields).length === 0 &&\n        Object.keys(unionTypes).length === 0 &&\n        locations.length === 0 &&\n        Object.keys(args).length === 0);\n}\nexports.typeNodesAreEquivalent = typeNodesAreEquivalent;\nexports.defKindToExtKind = {\n    [graphql_1.Kind.SCALAR_TYPE_DEFINITION]: graphql_1.Kind.SCALAR_TYPE_EXTENSION,\n    [graphql_1.Kind.OBJECT_TYPE_DEFINITION]: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n    [graphql_1.Kind.INTERFACE_TYPE_DEFINITION]: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n    [graphql_1.Kind.UNION_TYPE_DEFINITION]: graphql_1.Kind.UNION_TYPE_EXTENSION,\n    [graphql_1.Kind.ENUM_TYPE_DEFINITION]: graphql_1.Kind.ENUM_TYPE_EXTENSION,\n    [graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION]: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\nfunction mapValues(object, callback) {\n    const result = Object.create(null);\n    for (const [key, value] of Object.entries(object)) {\n        result[key] = callback(value);\n    }\n    return result;\n}\nexports.mapValues = mapValues;\nfunction isNotNullOrUndefined(value) {\n    return value !== null && typeof value !== 'undefined';\n}\nexports.isNotNullOrUndefined = isNotNullOrUndefined;\nexports.executableDirectiveLocations = [\n    'QUERY',\n    'MUTATION',\n    'SUBSCRIPTION',\n    'FIELD',\n    'FRAGMENT_DEFINITION',\n    'FRAGMENT_SPREAD',\n    'INLINE_FRAGMENT',\n    'VARIABLE_DEFINITION',\n];\nfunction isFederationDirective(directive) {\n    return directives_1.default.some(({ name }) => name === directive.name);\n}\nexports.isFederationDirective = isFederationDirective;\nexports.reservedRootFields = ['_service', '_entities'];\nexports.defaultRootOperationNameLookup = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription',\n};\nfunction getFederationMetadata(obj) {\n    var _a, _b, _c;\n    if (typeof obj === \"undefined\")\n        return undefined;\n    else if (graphql_1.isNamedType(obj))\n        return (_a = obj.extensions) === null || _a === void 0 ? void 0 : _a.federation;\n    else if (graphql_1.isDirective(obj))\n        return (_b = obj.extensions) === null || _b === void 0 ? void 0 : _b.federation;\n    else\n        return (_c = obj.extensions) === null || _c === void 0 ? void 0 : _c.federation;\n}\nexports.getFederationMetadata = getFederationMetadata;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}