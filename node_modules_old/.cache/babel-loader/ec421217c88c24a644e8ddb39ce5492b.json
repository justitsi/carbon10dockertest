{"ast":null,"code":"\"use strict\"; // tslint:disable interface-over-type-literal\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst deps_1 = tslib_1.__importDefault(require(\"./deps\")); // eslint-disable-next-line new-cap\n\n\nconst m = deps_1.default() // eslint-disable-next-line node/no-missing-require\n.add('errors', () => require('./errors')) // eslint-disable-next-line node/no-missing-require\n.add('util', () => require('./util'));\nlet debug;\n\ntry {\n  // eslint-disable-next-line no-negated-condition\n  if (process.env.CLI_FLAGS_DEBUG !== '1') debug = () => {};else // eslint-disable-next-line node/no-extraneous-require\n    debug = require('debug')('@oclif/parser');\n} catch (_a) {\n  debug = () => {};\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.raw = [];\n    const {\n      pickBy\n    } = m.util;\n    this.context = input.context || {};\n    this.argv = input.argv.slice(0);\n\n    this._setNames();\n\n    this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n    this.metaData = {};\n  }\n\n  parse() {\n    this._debugInput();\n\n    const findLongFlag = arg => {\n      const name = arg.slice(2);\n\n      if (this.input.flags[name]) {\n        return name;\n      }\n\n      if (arg.startsWith('--no-')) {\n        const flag = this.booleanFlags[arg.slice(5)];\n        if (flag && flag.allowNo) return flag.name;\n      }\n    };\n\n    const findShortFlag = arg => {\n      return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n    };\n\n    const parseFlag = arg => {\n      const long = arg.startsWith('--');\n      const name = long ? findLongFlag(arg) : findShortFlag(arg);\n\n      if (!name) {\n        const i = arg.indexOf('=');\n\n        if (i !== -1) {\n          const sliced = arg.slice(i + 1);\n          this.argv.unshift(sliced);\n          const equalsParsed = parseFlag(arg.slice(0, i));\n\n          if (!equalsParsed) {\n            this.argv.shift();\n          }\n\n          return equalsParsed;\n        }\n\n        return false;\n      }\n\n      const flag = this.input.flags[name];\n\n      if (flag.type === 'option') {\n        this.currentFlag = flag;\n        let input;\n\n        if (long || arg.length < 3) {\n          input = this.argv.shift();\n        } else {\n          input = arg.slice(arg[2] === '=' ? 3 : 2);\n        }\n\n        if (typeof input !== 'string') {\n          throw new m.errors.CLIError(`Flag --${name} expects a value`);\n        }\n\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input\n        });\n      } else {\n        this.raw.push({\n          type: 'flag',\n          flag: flag.name,\n          input: arg\n        }); // push the rest of the short characters back on the stack\n\n        if (!long && arg.length > 2) {\n          this.argv.unshift(`-${arg.slice(2)}`);\n        }\n      }\n\n      return true;\n    };\n\n    let parsingFlags = true;\n\n    while (this.argv.length) {\n      const input = this.argv.shift();\n\n      if (parsingFlags && input.startsWith('-') && input !== '-') {\n        // attempt to parse as arg\n        if (this.input['--'] !== false && input === '--') {\n          parsingFlags = false;\n          continue;\n        }\n\n        if (parseFlag(input)) {\n          continue;\n        } // not actually a flag if it reaches here so parse as an arg\n\n      }\n\n      if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n        this.raw.push({\n          type: 'flag',\n          flag: this.currentFlag.name,\n          input\n        });\n        continue;\n      } // not a flag, parse as arg\n\n\n      const arg = this.input.args[this._argTokens.length];\n      if (arg) arg.input = input;\n      this.raw.push({\n        type: 'arg',\n        input\n      });\n    }\n\n    const argv = this._argv();\n\n    const args = this._args(argv);\n\n    const flags = this._flags();\n\n    this._debugOutput(argv, args, flags);\n\n    return {\n      args,\n      argv,\n      flags,\n      raw: this.raw,\n      metadata: this.metaData\n    };\n  }\n\n  _args(argv) {\n    const args = {};\n\n    for (let i = 0; i < this.input.args.length; i++) {\n      const arg = this.input.args[i];\n      args[arg.name] = argv[i];\n    }\n\n    return args;\n  }\n\n  _flags() {\n    const flags = {};\n    this.metaData.flags = {};\n\n    for (const token of this._flagTokens) {\n      const flag = this.input.flags[token.flag];\n      if (!flag) throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n\n      if (flag.type === 'boolean') {\n        if (token.input === `--no-${flag.name}`) {\n          flags[token.flag] = false;\n        } else {\n          flags[token.flag] = true;\n        }\n\n        flags[token.flag] = flag.parse(flags[token.flag], this.context);\n      } else {\n        const input = token.input;\n\n        if (flag.options && !flag.options.includes(input)) {\n          throw new m.errors.FlagInvalidOptionError(flag, input);\n        }\n\n        const value = flag.parse ? flag.parse(input, this.context) : input;\n\n        if (flag.multiple) {\n          flags[token.flag] = flags[token.flag] || [];\n          flags[token.flag].push(value);\n        } else {\n          flags[token.flag] = value;\n        }\n      }\n    }\n\n    for (const k of Object.keys(this.input.flags)) {\n      const flag = this.input.flags[k];\n      if (flags[k]) continue;\n\n      if (flag.type === 'option' && flag.env) {\n        const input = process.env[flag.env];\n        if (input) flags[k] = flag.parse(input, this.context);\n      }\n\n      if (!(k in flags) && flag.default !== undefined) {\n        this.metaData.flags[k] = {\n          setFromDefault: true\n        };\n\n        if (typeof flag.default === 'function') {\n          flags[k] = flag.default(Object.assign({\n            options: flag,\n            flags\n          }, this.context));\n        } else {\n          flags[k] = flag.default;\n        }\n      }\n    }\n\n    return flags;\n  }\n\n  _argv() {\n    const args = [];\n    const tokens = this._argTokens;\n\n    for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n      const token = tokens[i];\n      const arg = this.input.args[i];\n\n      if (token) {\n        if (arg) {\n          if (arg.options && !arg.options.includes(token.input)) {\n            throw new m.errors.ArgInvalidOptionError(arg, token.input);\n          }\n\n          args[i] = arg.parse(token.input);\n        } else {\n          args[i] = token.input;\n        }\n      } else if ('default' in arg) {\n        if (typeof arg.default === 'function') {\n          args[i] = arg.default();\n        } else {\n          args[i] = arg.default;\n        }\n      }\n    }\n\n    return args;\n  }\n\n  _debugOutput(args, flags, argv) {\n    if (argv.length > 0) {\n      debug('argv: %o', argv);\n    }\n\n    if (Object.keys(args).length > 0) {\n      debug('args: %o', args);\n    }\n\n    if (Object.keys(flags).length > 0) {\n      debug('flags: %o', flags);\n    }\n  }\n\n  _debugInput() {\n    debug('input: %s', this.argv.join(' '));\n\n    if (this.input.args.length > 0) {\n      debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n    }\n\n    if (Object.keys(this.input.flags).length === 0) return;\n    debug('available flags: %s', Object.keys(this.input.flags).map(f => `--${f}`).join(' '));\n  }\n\n  get _argTokens() {\n    return this.raw.filter(o => o.type === 'arg');\n  }\n\n  get _flagTokens() {\n    return this.raw.filter(o => o.type === 'flag');\n  }\n\n  _setNames() {\n    for (const k of Object.keys(this.input.flags)) {\n      this.input.flags[k].name = k;\n    }\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"sources":["/Users/hristobelchev/test_projects/testing_react/react-box-app/box-app/node_modules/@oclif/parser/lib/parse.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","deps_1","__importDefault","m","default","add","debug","process","env","CLI_FLAGS_DEBUG","_a","Parser","constructor","input","raw","pickBy","util","context","argv","slice","_setNames","booleanFlags","flags","f","type","metaData","parse","_debugInput","findLongFlag","arg","name","startsWith","flag","allowNo","findShortFlag","keys","find","k","char","parseFlag","long","i","indexOf","sliced","unshift","equalsParsed","shift","currentFlag","length","errors","CLIError","push","parsingFlags","multiple","args","_argTokens","_argv","_args","_flags","_debugOutput","metadata","token","_flagTokens","options","includes","FlagInvalidOptionError","undefined","setFromDefault","assign","tokens","Math","max","ArgInvalidOptionError","join","map","a","filter","o"],"mappings":"AAAA,a,CACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,QAAD,CAA/B,CAAf,C,CACA;;;AACA,MAAMG,CAAC,GAAGF,MAAM,CAACG,OAAP,GACN;AADM,CAELC,GAFK,CAED,QAFC,EAES,MAAML,OAAO,CAAC,UAAD,CAFtB,EAGN;AAHM,CAILK,GAJK,CAID,MAJC,EAIO,MAAML,OAAO,CAAC,QAAD,CAJpB,CAAV;AAKA,IAAIM,KAAJ;;AACA,IAAI;AACA;AACA,MAAIC,OAAO,CAACC,GAAR,CAAYC,eAAZ,KAAgC,GAApC,EACIH,KAAK,GAAG,MAAM,CAAG,CAAjB,CADJ,KAGI;AACAA,IAAAA,KAAK,GAAGN,OAAO,CAAC,OAAD,CAAP,CAAiB,eAAjB,CAAR;AACP,CAPD,CAQA,OAAOU,EAAP,EAAW;AACPJ,EAAAA,KAAK,GAAG,MAAM,CAAG,CAAjB;AACH;;AACD,MAAMK,MAAN,CAAa;AACTC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKC,GAAL,GAAW,EAAX;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAaZ,CAAC,CAACa,IAArB;AACA,SAAKC,OAAL,GAAeJ,KAAK,CAACI,OAAN,IAAiB,EAAhC;AACA,SAAKC,IAAL,GAAYL,KAAK,CAACK,IAAN,CAAWC,KAAX,CAAiB,CAAjB,CAAZ;;AACA,SAAKC,SAAL;;AACA,SAAKC,YAAL,GAAoBN,MAAM,CAACF,KAAK,CAACS,KAAP,EAAcC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,SAA9B,CAA1B;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACH;;AACDC,EAAAA,KAAK,GAAG;AACJ,SAAKC,WAAL;;AACA,UAAMC,YAAY,GAAIC,GAAD,IAAS;AAC1B,YAAMC,IAAI,GAAGD,GAAG,CAACV,KAAJ,CAAU,CAAV,CAAb;;AACA,UAAI,KAAKN,KAAL,CAAWS,KAAX,CAAiBQ,IAAjB,CAAJ,EAA4B;AACxB,eAAOA,IAAP;AACH;;AACD,UAAID,GAAG,CAACE,UAAJ,CAAe,OAAf,CAAJ,EAA6B;AACzB,cAAMC,IAAI,GAAG,KAAKX,YAAL,CAAkBQ,GAAG,CAACV,KAAJ,CAAU,CAAV,CAAlB,CAAb;AACA,YAAIa,IAAI,IAAIA,IAAI,CAACC,OAAjB,EACI,OAAOD,IAAI,CAACF,IAAZ;AACP;AACJ,KAVD;;AAWA,UAAMI,aAAa,GAAIL,GAAD,IAAS;AAC3B,aAAOlC,MAAM,CAACwC,IAAP,CAAY,KAAKtB,KAAL,CAAWS,KAAvB,EAA8Bc,IAA9B,CAAmCC,CAAC,IAAI,KAAKxB,KAAL,CAAWS,KAAX,CAAiBe,CAAjB,EAAoBC,IAApB,KAA6BT,GAAG,CAAC,CAAD,CAAxE,CAAP;AACH,KAFD;;AAGA,UAAMU,SAAS,GAAIV,GAAD,IAAS;AACvB,YAAMW,IAAI,GAAGX,GAAG,CAACE,UAAJ,CAAe,IAAf,CAAb;AACA,YAAMD,IAAI,GAAGU,IAAI,GAAGZ,YAAY,CAACC,GAAD,CAAf,GAAuBK,aAAa,CAACL,GAAD,CAArD;;AACA,UAAI,CAACC,IAAL,EAAW;AACP,cAAMW,CAAC,GAAGZ,GAAG,CAACa,OAAJ,CAAY,GAAZ,CAAV;;AACA,YAAID,CAAC,KAAK,CAAC,CAAX,EAAc;AACV,gBAAME,MAAM,GAAGd,GAAG,CAACV,KAAJ,CAAUsB,CAAC,GAAG,CAAd,CAAf;AACA,eAAKvB,IAAL,CAAU0B,OAAV,CAAkBD,MAAlB;AACA,gBAAME,YAAY,GAAGN,SAAS,CAACV,GAAG,CAACV,KAAJ,CAAU,CAAV,EAAasB,CAAb,CAAD,CAA9B;;AACA,cAAI,CAACI,YAAL,EAAmB;AACf,iBAAK3B,IAAL,CAAU4B,KAAV;AACH;;AACD,iBAAOD,YAAP;AACH;;AACD,eAAO,KAAP;AACH;;AACD,YAAMb,IAAI,GAAG,KAAKnB,KAAL,CAAWS,KAAX,CAAiBQ,IAAjB,CAAb;;AACA,UAAIE,IAAI,CAACR,IAAL,KAAc,QAAlB,EAA4B;AACxB,aAAKuB,WAAL,GAAmBf,IAAnB;AACA,YAAInB,KAAJ;;AACA,YAAI2B,IAAI,IAAIX,GAAG,CAACmB,MAAJ,GAAa,CAAzB,EAA4B;AACxBnC,UAAAA,KAAK,GAAG,KAAKK,IAAL,CAAU4B,KAAV,EAAR;AACH,SAFD,MAGK;AACDjC,UAAAA,KAAK,GAAGgB,GAAG,CAACV,KAAJ,CAAUU,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,GAAiB,CAAjB,GAAqB,CAA/B,CAAR;AACH;;AACD,YAAI,OAAOhB,KAAP,KAAiB,QAArB,EAA+B;AAC3B,gBAAM,IAAIV,CAAC,CAAC8C,MAAF,CAASC,QAAb,CAAuB,UAASpB,IAAK,kBAArC,CAAN;AACH;;AACD,aAAKhB,GAAL,CAASqC,IAAT,CAAc;AAAE3B,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA,IAAI,EAAEA,IAAI,CAACF,IAA3B;AAAiCjB,UAAAA;AAAjC,SAAd;AACH,OAbD,MAcK;AACD,aAAKC,GAAL,CAASqC,IAAT,CAAc;AAAE3B,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA,IAAI,EAAEA,IAAI,CAACF,IAA3B;AAAiCjB,UAAAA,KAAK,EAAEgB;AAAxC,SAAd,EADC,CAED;;AACA,YAAI,CAACW,IAAD,IAASX,GAAG,CAACmB,MAAJ,GAAa,CAA1B,EAA6B;AACzB,eAAK9B,IAAL,CAAU0B,OAAV,CAAmB,IAAGf,GAAG,CAACV,KAAJ,CAAU,CAAV,CAAa,EAAnC;AACH;AACJ;;AACD,aAAO,IAAP;AACH,KAvCD;;AAwCA,QAAIiC,YAAY,GAAG,IAAnB;;AACA,WAAO,KAAKlC,IAAL,CAAU8B,MAAjB,EAAyB;AACrB,YAAMnC,KAAK,GAAG,KAAKK,IAAL,CAAU4B,KAAV,EAAd;;AACA,UAAIM,YAAY,IAAIvC,KAAK,CAACkB,UAAN,CAAiB,GAAjB,CAAhB,IAAyClB,KAAK,KAAK,GAAvD,EAA4D;AACxD;AACA,YAAI,KAAKA,KAAL,CAAW,IAAX,MAAqB,KAArB,IAA8BA,KAAK,KAAK,IAA5C,EAAkD;AAC9CuC,UAAAA,YAAY,GAAG,KAAf;AACA;AACH;;AACD,YAAIb,SAAS,CAAC1B,KAAD,CAAb,EAAsB;AAClB;AACH,SARuD,CASxD;;AACH;;AACD,UAAIuC,YAAY,IAAI,KAAKL,WAArB,IAAoC,KAAKA,WAAL,CAAiBM,QAAzD,EAAmE;AAC/D,aAAKvC,GAAL,CAASqC,IAAT,CAAc;AAAE3B,UAAAA,IAAI,EAAE,MAAR;AAAgBQ,UAAAA,IAAI,EAAE,KAAKe,WAAL,CAAiBjB,IAAvC;AAA6CjB,UAAAA;AAA7C,SAAd;AACA;AACH,OAhBoB,CAiBrB;;;AACA,YAAMgB,GAAG,GAAG,KAAKhB,KAAL,CAAWyC,IAAX,CAAgB,KAAKC,UAAL,CAAgBP,MAAhC,CAAZ;AACA,UAAInB,GAAJ,EACIA,GAAG,CAAChB,KAAJ,GAAYA,KAAZ;AACJ,WAAKC,GAAL,CAASqC,IAAT,CAAc;AAAE3B,QAAAA,IAAI,EAAE,KAAR;AAAeX,QAAAA;AAAf,OAAd;AACH;;AACD,UAAMK,IAAI,GAAG,KAAKsC,KAAL,EAAb;;AACA,UAAMF,IAAI,GAAG,KAAKG,KAAL,CAAWvC,IAAX,CAAb;;AACA,UAAMI,KAAK,GAAG,KAAKoC,MAAL,EAAd;;AACA,SAAKC,YAAL,CAAkBzC,IAAlB,EAAwBoC,IAAxB,EAA8BhC,KAA9B;;AACA,WAAO;AACHgC,MAAAA,IADG;AAEHpC,MAAAA,IAFG;AAGHI,MAAAA,KAHG;AAIHR,MAAAA,GAAG,EAAE,KAAKA,GAJP;AAKH8C,MAAAA,QAAQ,EAAE,KAAKnC;AALZ,KAAP;AAOH;;AACDgC,EAAAA,KAAK,CAACvC,IAAD,EAAO;AACR,UAAMoC,IAAI,GAAG,EAAb;;AACA,SAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5B,KAAL,CAAWyC,IAAX,CAAgBN,MAApC,EAA4CP,CAAC,EAA7C,EAAiD;AAC7C,YAAMZ,GAAG,GAAG,KAAKhB,KAAL,CAAWyC,IAAX,CAAgBb,CAAhB,CAAZ;AACAa,MAAAA,IAAI,CAACzB,GAAG,CAACC,IAAL,CAAJ,GAAiBZ,IAAI,CAACuB,CAAD,CAArB;AACH;;AACD,WAAOa,IAAP;AACH;;AACDI,EAAAA,MAAM,GAAG;AACL,UAAMpC,KAAK,GAAG,EAAd;AACA,SAAKG,QAAL,CAAcH,KAAd,GAAsB,EAAtB;;AACA,SAAK,MAAMuC,KAAX,IAAoB,KAAKC,WAAzB,EAAsC;AAClC,YAAM9B,IAAI,GAAG,KAAKnB,KAAL,CAAWS,KAAX,CAAiBuC,KAAK,CAAC7B,IAAvB,CAAb;AACA,UAAI,CAACA,IAAL,EACI,MAAM,IAAI7B,CAAC,CAAC8C,MAAF,CAASC,QAAb,CAAuB,mBAAkBW,KAAK,CAAC7B,IAAK,EAApD,CAAN;;AACJ,UAAIA,IAAI,CAACR,IAAL,KAAc,SAAlB,EAA6B;AACzB,YAAIqC,KAAK,CAAChD,KAAN,KAAiB,QAAOmB,IAAI,CAACF,IAAK,EAAtC,EAAyC;AACrCR,UAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,GAAoB,KAApB;AACH,SAFD,MAGK;AACDV,UAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,GAAoB,IAApB;AACH;;AACDV,QAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,GAAoBA,IAAI,CAACN,KAAL,CAAWJ,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAhB,EAA8B,KAAKf,OAAnC,CAApB;AACH,OARD,MASK;AACD,cAAMJ,KAAK,GAAGgD,KAAK,CAAChD,KAApB;;AACA,YAAImB,IAAI,CAAC+B,OAAL,IAAgB,CAAC/B,IAAI,CAAC+B,OAAL,CAAaC,QAAb,CAAsBnD,KAAtB,CAArB,EAAmD;AAC/C,gBAAM,IAAIV,CAAC,CAAC8C,MAAF,CAASgB,sBAAb,CAAoCjC,IAApC,EAA0CnB,KAA1C,CAAN;AACH;;AACD,cAAMf,KAAK,GAAGkC,IAAI,CAACN,KAAL,GAAaM,IAAI,CAACN,KAAL,CAAWb,KAAX,EAAkB,KAAKI,OAAvB,CAAb,GAA+CJ,KAA7D;;AACA,YAAImB,IAAI,CAACqB,QAAT,EAAmB;AACf/B,UAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,GAAoBV,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,IAAqB,EAAzC;AACAV,UAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,CAAkBmB,IAAlB,CAAuBrD,KAAvB;AACH,SAHD,MAIK;AACDwB,UAAAA,KAAK,CAACuC,KAAK,CAAC7B,IAAP,CAAL,GAAoBlC,KAApB;AACH;AACJ;AACJ;;AACD,SAAK,MAAMuC,CAAX,IAAgB1C,MAAM,CAACwC,IAAP,CAAY,KAAKtB,KAAL,CAAWS,KAAvB,CAAhB,EAA+C;AAC3C,YAAMU,IAAI,GAAG,KAAKnB,KAAL,CAAWS,KAAX,CAAiBe,CAAjB,CAAb;AACA,UAAIf,KAAK,CAACe,CAAD,CAAT,EACI;;AACJ,UAAIL,IAAI,CAACR,IAAL,KAAc,QAAd,IAA0BQ,IAAI,CAACxB,GAAnC,EAAwC;AACpC,cAAMK,KAAK,GAAGN,OAAO,CAACC,GAAR,CAAYwB,IAAI,CAACxB,GAAjB,CAAd;AACA,YAAIK,KAAJ,EACIS,KAAK,CAACe,CAAD,CAAL,GAAWL,IAAI,CAACN,KAAL,CAAWb,KAAX,EAAkB,KAAKI,OAAvB,CAAX;AACP;;AACD,UAAI,EAAEoB,CAAC,IAAIf,KAAP,KAAiBU,IAAI,CAAC5B,OAAL,KAAiB8D,SAAtC,EAAiD;AAC7C,aAAKzC,QAAL,CAAcH,KAAd,CAAoBe,CAApB,IAAyB;AAAE8B,UAAAA,cAAc,EAAE;AAAlB,SAAzB;;AACA,YAAI,OAAOnC,IAAI,CAAC5B,OAAZ,KAAwB,UAA5B,EAAwC;AACpCkB,UAAAA,KAAK,CAACe,CAAD,CAAL,GAAWL,IAAI,CAAC5B,OAAL,CAAaT,MAAM,CAACyE,MAAP,CAAc;AAAEL,YAAAA,OAAO,EAAE/B,IAAX;AAAiBV,YAAAA;AAAjB,WAAd,EAAwC,KAAKL,OAA7C,CAAb,CAAX;AACH,SAFD,MAGK;AACDK,UAAAA,KAAK,CAACe,CAAD,CAAL,GAAWL,IAAI,CAAC5B,OAAhB;AACH;AACJ;AACJ;;AACD,WAAOkB,KAAP;AACH;;AACDkC,EAAAA,KAAK,GAAG;AACJ,UAAMF,IAAI,GAAG,EAAb;AACA,UAAMe,MAAM,GAAG,KAAKd,UAApB;;AACA,SAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,IAAI,CAACC,GAAL,CAAS,KAAK1D,KAAL,CAAWyC,IAAX,CAAgBN,MAAzB,EAAiCqB,MAAM,CAACrB,MAAxC,CAApB,EAAqEP,CAAC,EAAtE,EAA0E;AACtE,YAAMoB,KAAK,GAAGQ,MAAM,CAAC5B,CAAD,CAApB;AACA,YAAMZ,GAAG,GAAG,KAAKhB,KAAL,CAAWyC,IAAX,CAAgBb,CAAhB,CAAZ;;AACA,UAAIoB,KAAJ,EAAW;AACP,YAAIhC,GAAJ,EAAS;AACL,cAAIA,GAAG,CAACkC,OAAJ,IAAe,CAAClC,GAAG,CAACkC,OAAJ,CAAYC,QAAZ,CAAqBH,KAAK,CAAChD,KAA3B,CAApB,EAAuD;AACnD,kBAAM,IAAIV,CAAC,CAAC8C,MAAF,CAASuB,qBAAb,CAAmC3C,GAAnC,EAAwCgC,KAAK,CAAChD,KAA9C,CAAN;AACH;;AACDyC,UAAAA,IAAI,CAACb,CAAD,CAAJ,GAAUZ,GAAG,CAACH,KAAJ,CAAUmC,KAAK,CAAChD,KAAhB,CAAV;AACH,SALD,MAMK;AACDyC,UAAAA,IAAI,CAACb,CAAD,CAAJ,GAAUoB,KAAK,CAAChD,KAAhB;AACH;AACJ,OAVD,MAWK,IAAI,aAAagB,GAAjB,EAAsB;AACvB,YAAI,OAAOA,GAAG,CAACzB,OAAX,KAAuB,UAA3B,EAAuC;AACnCkD,UAAAA,IAAI,CAACb,CAAD,CAAJ,GAAUZ,GAAG,CAACzB,OAAJ,EAAV;AACH,SAFD,MAGK;AACDkD,UAAAA,IAAI,CAACb,CAAD,CAAJ,GAAUZ,GAAG,CAACzB,OAAd;AACH;AACJ;AACJ;;AACD,WAAOkD,IAAP;AACH;;AACDK,EAAAA,YAAY,CAACL,IAAD,EAAOhC,KAAP,EAAcJ,IAAd,EAAoB;AAC5B,QAAIA,IAAI,CAAC8B,MAAL,GAAc,CAAlB,EAAqB;AACjB1C,MAAAA,KAAK,CAAC,UAAD,EAAaY,IAAb,CAAL;AACH;;AACD,QAAIvB,MAAM,CAACwC,IAAP,CAAYmB,IAAZ,EAAkBN,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B1C,MAAAA,KAAK,CAAC,UAAD,EAAagD,IAAb,CAAL;AACH;;AACD,QAAI3D,MAAM,CAACwC,IAAP,CAAYb,KAAZ,EAAmB0B,MAAnB,GAA4B,CAAhC,EAAmC;AAC/B1C,MAAAA,KAAK,CAAC,WAAD,EAAcgB,KAAd,CAAL;AACH;AACJ;;AACDK,EAAAA,WAAW,GAAG;AACVrB,IAAAA,KAAK,CAAC,WAAD,EAAc,KAAKY,IAAL,CAAUuD,IAAV,CAAe,GAAf,CAAd,CAAL;;AACA,QAAI,KAAK5D,KAAL,CAAWyC,IAAX,CAAgBN,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B1C,MAAAA,KAAK,CAAC,oBAAD,EAAuB,KAAKO,KAAL,CAAWyC,IAAX,CAAgBoB,GAAhB,CAAoBC,CAAC,IAAIA,CAAC,CAAC7C,IAA3B,EAAiC2C,IAAjC,CAAsC,GAAtC,CAAvB,CAAL;AACH;;AACD,QAAI9E,MAAM,CAACwC,IAAP,CAAY,KAAKtB,KAAL,CAAWS,KAAvB,EAA8B0B,MAA9B,KAAyC,CAA7C,EACI;AACJ1C,IAAAA,KAAK,CAAC,qBAAD,EAAwBX,MAAM,CAACwC,IAAP,CAAY,KAAKtB,KAAL,CAAWS,KAAvB,EACxBoD,GADwB,CACpBnD,CAAC,IAAK,KAAIA,CAAE,EADQ,EAExBkD,IAFwB,CAEnB,GAFmB,CAAxB,CAAL;AAGH;;AACD,MAAIlB,UAAJ,GAAiB;AACb,WAAO,KAAKzC,GAAL,CAAS8D,MAAT,CAAgBC,CAAC,IAAIA,CAAC,CAACrD,IAAF,KAAW,KAAhC,CAAP;AACH;;AACD,MAAIsC,WAAJ,GAAkB;AACd,WAAO,KAAKhD,GAAL,CAAS8D,MAAT,CAAgBC,CAAC,IAAIA,CAAC,CAACrD,IAAF,KAAW,MAAhC,CAAP;AACH;;AACDJ,EAAAA,SAAS,GAAG;AACR,SAAK,MAAMiB,CAAX,IAAgB1C,MAAM,CAACwC,IAAP,CAAY,KAAKtB,KAAL,CAAWS,KAAvB,CAAhB,EAA+C;AAC3C,WAAKT,KAAL,CAAWS,KAAX,CAAiBe,CAAjB,EAAoBP,IAApB,GAA2BO,CAA3B;AACH;AACJ;;AA/NQ;;AAiObxC,OAAO,CAACc,MAAR,GAAiBA,MAAjB","sourcesContent":["\"use strict\";\n// tslint:disable interface-over-type-literal\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst deps_1 = tslib_1.__importDefault(require(\"./deps\"));\n// eslint-disable-next-line new-cap\nconst m = deps_1.default()\n    // eslint-disable-next-line node/no-missing-require\n    .add('errors', () => require('./errors'))\n    // eslint-disable-next-line node/no-missing-require\n    .add('util', () => require('./util'));\nlet debug;\ntry {\n    // eslint-disable-next-line no-negated-condition\n    if (process.env.CLI_FLAGS_DEBUG !== '1')\n        debug = () => { };\n    else\n        // eslint-disable-next-line node/no-extraneous-require\n        debug = require('debug')('@oclif/parser');\n}\ncatch (_a) {\n    debug = () => { };\n}\nclass Parser {\n    constructor(input) {\n        this.input = input;\n        this.raw = [];\n        const { pickBy } = m.util;\n        this.context = input.context || {};\n        this.argv = input.argv.slice(0);\n        this._setNames();\n        this.booleanFlags = pickBy(input.flags, f => f.type === 'boolean');\n        this.metaData = {};\n    }\n    parse() {\n        this._debugInput();\n        const findLongFlag = (arg) => {\n            const name = arg.slice(2);\n            if (this.input.flags[name]) {\n                return name;\n            }\n            if (arg.startsWith('--no-')) {\n                const flag = this.booleanFlags[arg.slice(5)];\n                if (flag && flag.allowNo)\n                    return flag.name;\n            }\n        };\n        const findShortFlag = (arg) => {\n            return Object.keys(this.input.flags).find(k => this.input.flags[k].char === arg[1]);\n        };\n        const parseFlag = (arg) => {\n            const long = arg.startsWith('--');\n            const name = long ? findLongFlag(arg) : findShortFlag(arg);\n            if (!name) {\n                const i = arg.indexOf('=');\n                if (i !== -1) {\n                    const sliced = arg.slice(i + 1);\n                    this.argv.unshift(sliced);\n                    const equalsParsed = parseFlag(arg.slice(0, i));\n                    if (!equalsParsed) {\n                        this.argv.shift();\n                    }\n                    return equalsParsed;\n                }\n                return false;\n            }\n            const flag = this.input.flags[name];\n            if (flag.type === 'option') {\n                this.currentFlag = flag;\n                let input;\n                if (long || arg.length < 3) {\n                    input = this.argv.shift();\n                }\n                else {\n                    input = arg.slice(arg[2] === '=' ? 3 : 2);\n                }\n                if (typeof input !== 'string') {\n                    throw new m.errors.CLIError(`Flag --${name} expects a value`);\n                }\n                this.raw.push({ type: 'flag', flag: flag.name, input });\n            }\n            else {\n                this.raw.push({ type: 'flag', flag: flag.name, input: arg });\n                // push the rest of the short characters back on the stack\n                if (!long && arg.length > 2) {\n                    this.argv.unshift(`-${arg.slice(2)}`);\n                }\n            }\n            return true;\n        };\n        let parsingFlags = true;\n        while (this.argv.length) {\n            const input = this.argv.shift();\n            if (parsingFlags && input.startsWith('-') && input !== '-') {\n                // attempt to parse as arg\n                if (this.input['--'] !== false && input === '--') {\n                    parsingFlags = false;\n                    continue;\n                }\n                if (parseFlag(input)) {\n                    continue;\n                }\n                // not actually a flag if it reaches here so parse as an arg\n            }\n            if (parsingFlags && this.currentFlag && this.currentFlag.multiple) {\n                this.raw.push({ type: 'flag', flag: this.currentFlag.name, input });\n                continue;\n            }\n            // not a flag, parse as arg\n            const arg = this.input.args[this._argTokens.length];\n            if (arg)\n                arg.input = input;\n            this.raw.push({ type: 'arg', input });\n        }\n        const argv = this._argv();\n        const args = this._args(argv);\n        const flags = this._flags();\n        this._debugOutput(argv, args, flags);\n        return {\n            args,\n            argv,\n            flags,\n            raw: this.raw,\n            metadata: this.metaData,\n        };\n    }\n    _args(argv) {\n        const args = {};\n        for (let i = 0; i < this.input.args.length; i++) {\n            const arg = this.input.args[i];\n            args[arg.name] = argv[i];\n        }\n        return args;\n    }\n    _flags() {\n        const flags = {};\n        this.metaData.flags = {};\n        for (const token of this._flagTokens) {\n            const flag = this.input.flags[token.flag];\n            if (!flag)\n                throw new m.errors.CLIError(`Unexpected flag ${token.flag}`);\n            if (flag.type === 'boolean') {\n                if (token.input === `--no-${flag.name}`) {\n                    flags[token.flag] = false;\n                }\n                else {\n                    flags[token.flag] = true;\n                }\n                flags[token.flag] = flag.parse(flags[token.flag], this.context);\n            }\n            else {\n                const input = token.input;\n                if (flag.options && !flag.options.includes(input)) {\n                    throw new m.errors.FlagInvalidOptionError(flag, input);\n                }\n                const value = flag.parse ? flag.parse(input, this.context) : input;\n                if (flag.multiple) {\n                    flags[token.flag] = flags[token.flag] || [];\n                    flags[token.flag].push(value);\n                }\n                else {\n                    flags[token.flag] = value;\n                }\n            }\n        }\n        for (const k of Object.keys(this.input.flags)) {\n            const flag = this.input.flags[k];\n            if (flags[k])\n                continue;\n            if (flag.type === 'option' && flag.env) {\n                const input = process.env[flag.env];\n                if (input)\n                    flags[k] = flag.parse(input, this.context);\n            }\n            if (!(k in flags) && flag.default !== undefined) {\n                this.metaData.flags[k] = { setFromDefault: true };\n                if (typeof flag.default === 'function') {\n                    flags[k] = flag.default(Object.assign({ options: flag, flags }, this.context));\n                }\n                else {\n                    flags[k] = flag.default;\n                }\n            }\n        }\n        return flags;\n    }\n    _argv() {\n        const args = [];\n        const tokens = this._argTokens;\n        for (let i = 0; i < Math.max(this.input.args.length, tokens.length); i++) {\n            const token = tokens[i];\n            const arg = this.input.args[i];\n            if (token) {\n                if (arg) {\n                    if (arg.options && !arg.options.includes(token.input)) {\n                        throw new m.errors.ArgInvalidOptionError(arg, token.input);\n                    }\n                    args[i] = arg.parse(token.input);\n                }\n                else {\n                    args[i] = token.input;\n                }\n            }\n            else if ('default' in arg) {\n                if (typeof arg.default === 'function') {\n                    args[i] = arg.default();\n                }\n                else {\n                    args[i] = arg.default;\n                }\n            }\n        }\n        return args;\n    }\n    _debugOutput(args, flags, argv) {\n        if (argv.length > 0) {\n            debug('argv: %o', argv);\n        }\n        if (Object.keys(args).length > 0) {\n            debug('args: %o', args);\n        }\n        if (Object.keys(flags).length > 0) {\n            debug('flags: %o', flags);\n        }\n    }\n    _debugInput() {\n        debug('input: %s', this.argv.join(' '));\n        if (this.input.args.length > 0) {\n            debug('available args: %s', this.input.args.map(a => a.name).join(' '));\n        }\n        if (Object.keys(this.input.flags).length === 0)\n            return;\n        debug('available flags: %s', Object.keys(this.input.flags)\n            .map(f => `--${f}`)\n            .join(' '));\n    }\n    get _argTokens() {\n        return this.raw.filter(o => o.type === 'arg');\n    }\n    get _flagTokens() {\n        return this.raw.filter(o => o.type === 'flag');\n    }\n    _setNames() {\n        for (const k of Object.keys(this.input.flags)) {\n            this.input.flags[k].name = k;\n        }\n    }\n}\nexports.Parser = Parser;\n"]},"metadata":{},"sourceType":"script"}